{"question": "public class AnySanitizers { public static final Set<SanitizerInfo> sanitizerInfos; static { Set<SanitizerInfo> builder = new HashSet<>(); builder.add(new SanitizerInfo( WellKnownTypeNames.SYSTEM_TEXT_STRING_BUILDER, false, false, null, new String[] { \"Clear\" } )); sanitizerInfos = builder; } }", "answer": "static AnySanitizers() { var builder = PooledHashSet<SanitizerInfo>.GetInstance(); builder.AddSanitizerInfo( WellKnownTypeNames.SystemTextStringBuilder, isInterface: false, isConstructorSanitizing: false, sanitizingMethods: (string[]?)null, sanitizingInstanceMethods: new[] { \"Clear\", } ); }"}
{"question": "public final class AnySanitizers { public static final Set<SanitizerInfo> SANITIZER_INFOS; static { Set<SanitizerInfo> builder = new HashSet<>(); SANITIZER_INFOS = Collections.unmodifiableSet(builder); } private AnySanitizers() { } }", "answer": "namespace Analyzer.Utilities.FlowAnalysis.Analysis.TaintedDataAnalysis { internal static class AnySanitizers { public static ImmutableHashSet<SanitizerInfo> SanitizerInfos { get; }}"}
{"question": "public final class AbstractBuiltInCodeStyleDiagnosticAnalyzerTests { @Test public void verifyDiagnosticDescriptorOrderingMaintained() { List<String> ids = IntStream.range(10, 30) .mapToObj(i -> \"IDE_\" + i) .collect(Collectors.toList()); TestAnalyzer analyzer = new TestAnalyzer(ids); List<String> diagnosticIds = analyzer.getSupportedDiagnostics() .stream() .map(diagnostic -> diagnostic.getId()) .collect(Collectors.toList()); assertEquals(ids, diagnosticIds); } }", "answer": "public sealed class AbstractBuiltInCodeStyleDiagnosticAnalyzerTests { [Fact] public void VerifyDiagnosticDescriptorOrderingMaintained() { var ids = Enumerable.Range(10, 20).Select(item => \"IDE_\" + item); var analyzer = new TestAnalyzer(ids); Assert.Equal(analyzer.SupportedDiagnostics.Select(static diagnostic => diagnostic.Id), ids); }"}
{"question": "public class TestAnalyzer extends BaseAnalyzer { public TestAnalyzer(List<String> ids) { super(createSupportedDiagnosticsWithOptionsFromIds(ids)); } private static List<Diagnostic> createSupportedDiagnosticsWithOptionsFromIds(List<String> ids) { return List.of(); } }", "answer": "public TestAnalyzer(IEnumerable<string> ids) : base(CreateSupportedDiagnosticsWithOptionsFromIds(ids)) { }"}
{"question": "public class RefStructsTest { @Test public void testRefStructs() throws Exception { String beforeFix = \"\"\" package test; class S1 {} \"\"\"; String afterFix = \"\"\" package test; // internal ref struct S1 {} -> Java 没有 internal/ref struct class S1 {} \"\"\"; String fixedCode = applyCodeFix(beforeFix); assertEquals(afterFix.trim(), fixedCode.trim()); }", "answer": "public Task TestRefStructs() => VerifyCS.VerifyCodeFixAsync(\"\"\" namespace Test { ref struct [|S1|] { } } \"\"\", \"\"\" namespace Test { internal ref struct S1 { } } \"\"\");"}
{"question": "public class NestedTypeTest { @Test public void testNestedType4() { String[] args = {}; C c = new C(); String typeName = C.Outer.Inner.class.getName(); assertEquals(\"NestedTypeTest$C$Outer$Inner\", typeName); } static class C { void M(String[] args) { var v = Outer.Inner.class.getName(); } } static class Outer<T> { public static class Inner<T> {} } }", "answer": "using NUnit.Framework; public class NestedTypeTest { [Test] public void TestNestedType4() { string[] args = { }; C c = new C(); string typeName = typeof(C.Outer.Inner).FullName; Assert.AreEqual(\"NestedTypeTest+C+Outer+Inner\", typeName); } public class C { public void M(string[] args) { var v = typeof(Outer.Inner).FullName; } } public class Outer<T> { public class Inner<T> { } } }"}
{"question": "public class ZipSlipSources { public static final Set<SourceInfo> SourceInfos; static { Set<SourceInfo> sourceInfosBuilder = new HashSet<>(); sourceInfosBuilder.add(new SourceInfo( WellKnownTypeNames.SYSTEM_IO_COMPRESSION_ZIP_ARCHIVE_ENTRY, false, new String[] { \"FullName\" }, null )); SourceInfos = Collections.unmodifiableSet(sourceInfosBuilder); } }", "answer": "static ZipSlipSources() { var sourceInfosBuilder = PooledHashSet<SourceInfo>.GetInstance(); sourceInfosBuilder.AddSourceInfo( WellKnownTypeNames.SystemIOCompressionZipArchiveEntry, isInterface: false, taintedProperties: new string[] { \"FullName\", }, taintedMethods: null); SourceInfos = sourceInfosBuilder.ToImmutableAndFree(); }"}
{"question": "public class ZipSlipSinks { public static final Set<SinkInfo> SinkInfos; static { Set<SinkInfo> builder = new HashSet<>(); builder.add(new SinkInfo( WellKnownTypeNames.SYSTEM_IO_COMPRESSION_ZIP_FILE_EXTENSIONS, SinkKind.ZIP_SLIP, false, false, null, new MethodParameter[] { new MethodParameter(\"ExtractToFile\", new String[] { \"destinationFileName\" }) } )); SinkInfos = Collections.unmodifiableSet(builder); } }", "answer": "static ZipSlipSinks() { var builder = PooledHashSet<SinkInfo>.GetInstance(); builder.AddSinkInfo( WellKnownTypeNames.SystemIOCompressionZipFileExtensions, SinkKind.ZipSlip, isInterface: false, isAnyStringParameterInConstructorASink: false, sinkProperties: null, sinkMethodParameters: new[] { (\"ExtractToFile\", new[] { \"destinationFileName\" } ), });"}
{"question": "public class XmlTargets { public static final Set<SinkInfo> TargetData; static { Set<SinkInfo> collector = new HashSet<>(); collector.add(new SinkInfo( WellKnownTypeNames.SYSTEM_XML_XML_ATTRIBUTE, SinkKind.XML, false, false, new String[] { \"InnerXml\" }, null / )); TargetData = Collections.unmodifiableSet(collector); } }", "answer": "static XmlTargets() { var collector = PooledHashSet<SinkInfo>.GetInstance(); collector.AddTargetRecord( WellKnownTypeNames.SystemXmlXmlAttribute, SinkKind.Xml, isInterface: false, isAnyStringParameterInConstructorASink: false, sinkProperties: new[] { \"InnerXml\", }, sinkMethodParameters: null);"}
{"question": "static { PooledHashSet<SinkInfo> collector = PooledHashSet.getInstance(); collector.add(new SinkInfo( WellKnownTypeNames.SYSTEM_XML_XMLDOCUMENT, SinkKind.XML, false, false, new String[] { \"InnerXml\" }, null )); }", "answer": "static XmlTargets() { var collector = PooledHashSet<SinkInfo>.GetInstance(); collector.AddTargetRecord( WellKnownTypeNames.SystemXmlXmlDocument, SinkKind.Xml, isInterface: false, isAnyStringParameterInConstructorASink: false, sinkProperties: new[] { \"InnerXml\", }, sinkMethodParameters: null); }"}
{"question": "public final class XmlSanitizers { public static final Set<SanitizerInfo> SANITIZER_INFOS; static { Set<SanitizerInfo> builder = new HashSet<>(); builder.add(new SanitizerInfo( WellKnownTypeNames.MICROSOFT_SECURITY_APPLICATION_ANTIXSS, // 对应 MicrosoftSecurityApplicationAntiXss false, false, new String[] { \"XmlAttributeEncode\", \"XmlEncode\" } )); SANITIZER_INFOS = Collections.unmodifiableSet(builder); } private XmlSanitizers() {} }", "answer": "internal static class XmlSanitizers { public static ImmutableHashSet<SanitizerInfo> SanitizerInfos { get; } static XmlSanitizers() { var builder = PooledHashSet<SanitizerInfo>.GetInstance(); builder.AddSanitizerInfo( WellKnownTypeNames.MicrosoftSecurityApplicationAntiXss, isInterface: false, isConstructorSanitizing: false, sanitizingMethods: new[] { \"XmlAttributeEncode\", \"XmlEncode\", }); } }"}
{"question": "public final class XamlTargets { public static final Set<SinkInfo> TARGET_DATA; static { Set<SinkInfo> collector = new HashSet<>(); collector.add(new SinkInfo( WellKnownTypeNames.SYSTEM_WINDOWS_MARKUP_XAML_READER, SinkKind.XAML, false, false, null, new TargetMethodParam[] { new TargetMethodParam(\"Load\", new String[] { \"stream\", \"reader\", \"xaml\" }), new TargetMethodParam(\"LoadAsync\", new String[] { \"stream\", \"reader\" }), new TargetMethodParam(\"LoadWithInitialTemplateValidation\", new String[] { \"xaml\" }) } )); TARGET_DATA = Collections.unmodifiableSet(collector); }", "answer": "static XamlTargets() { var collector = PooledHashSet<SinkInfo>.GetInstance(); collector.AddTargetRecord( WellKnownTypeNames.SystemWindowsMarkupXamlReader, SinkKind.Xaml, isInterface: false, isAnyStringParameterInConstructorASink: false, sinkProperties: null, sinkMethodParameters: new[] { ( \"Load\", new[] { \"stream\", \"reader\", \"xaml\" }), ( \"LoadAsync\", [\"stream\", \"reader\"]), ( \"LoadWithInitialTemplateValidation\", [\"xaml\"]), }); TargetData = collector.ToImmutableAndFree(); }"}
{"question": "public final class XPathSinks { public static final Set<SinkInfo> SINK_INFOS; static { Set<SinkInfo> builder = new HashSet<>(); SINK_INFOS = Collections.unmodifiableSet(builder); } private XPathSinks() {} }", "answer": "namespace Analyzer.Utilities.FlowAnalysis.Analysis.TaintedDataAnalysis { internal static class XPathSinks { public static ImmutableHashSet<SinkInfo> SinkInfos { get; } } }"}
{"question": "public final class WebOutputSinks { public static final Set<SinkInfo> SINK_INFOS; static { Set<SinkInfo> builder = new HashSet<>(); SinkKind[] sinkKinds = new SinkKind[] { SinkKind.INFORMATION_DISCLOSURE, SinkKind.XSS }; builder.add(new SinkInfo( WellKnownTypeNames.SYSTEM_WEB_UI_ITEXT_CONTROL, sinkKinds, true, false, new String[] { \"Text\" }, null )); SINK_INFOS = Collections.unmodifiableSet(builder); } private WebOutputSinks() {} }", "answer": "static WebOutputSinks() { var builder = PooledHashSet<SinkInfo>.GetInstance(); SinkKind[] sinkKinds = new[] { SinkKind.InformationDisclosure, SinkKind.Xss }; builder.AddSinkInfo( WellKnownTypeNames.SystemWebUIITextControl, sinkKinds, isInterface: true, isAnyStringParameterInConstructorASink: false, sinkProperties: new[] { \"Text\" }, sinkMethodParameters: null ); }"}
{"question": "public final class TaintedTargetValue { public static final String RETURN = \".Return\"; public static final String THIS = \".This\"; private TaintedTargetValue() {} }", "answer": "namespace Analyzer.Utilities.FlowAnalysis.Analysis.TaintedDataAnalysis { internal static class TaintedTargetValue { public const string Return = \".Return\"; public const string This = \".This\"; } }"}
{"question": "public static boolean isSourceProperty( TaintedDataSymbolMap<SourceInfo> sourceSymbolMap, IPropertySymbol propertySymbol) { for (SourceInfo sourceInfo : sourceSymbolMap.getInfosForType(propertySymbol.getContainingType())) { if (sourceInfo.getTaintedProperties().contains(propertySymbol.getMetadataName())) { return true; } } return false; }", "answer": "public static bool IsSourceProperty( this TaintedDataSymbolMap<SourceInfo> sourceSymbolMap, IPropertySymbol propertySymbol) { foreach (SourceInfo sourceInfo in sourceSymbolMap.GetInfosForType(propertySymbol.ContainingType)) { if (sourceInfo.TaintedProperties.Contains(propertySymbol.MetadataName)) { return true; } } return false; }"}
{"question": "public static boolean isSourceTransferProperty( TaintedDataSymbolMap<SourceInfo> sourceSymbolMap, IPropertyReferenceOperation propertyReferenceOperation) { if (propertyReferenceOperation.getInstance() == null || !(propertyReferenceOperation.getInstance().getType() instanceof INamedTypeSymbol)) { return false; } INamedTypeSymbol namedType = (INamedTypeSymbol) propertyReferenceOperation.getInstance().getType(); String name = propertyReferenceOperation.getMember().getName(); if (!\"CSharp\".equals(propertyReferenceOperation.getMember().getLanguage()) && propertyReferenceOperation.getMember().isIndexer()) { name = TaintedDataProperties.INDEXER_NAME; } return false; }", "answer": "public static bool IsSourceTransferProperty( this TaintedDataSymbolMap<SourceInfo> sourceSymbolMap, IPropertyReferenceOperation propertyReferenceOperation) { if (propertyReferenceOperation.Instance?.Type is not INamedTypeSymbol namedType) { return false; } string name = propertyReferenceOperation.Member.Name; if (propertyReferenceOperation.Member.Language != LanguageNames.CSharp && propertyReferenceOperation.Member.IsIndexer()) { name = TaintedDataProperties.IndexerName; } return false; }"}
{"question": "public static boolean isSourceParameter( TaintedDataSymbolMap<SourceInfo> sourceSymbolMap, IParameterSymbol parameterSymbol, WellKnownTypeProvider wellKnownTypeProvider) { ISymbol containingSymbol = parameterSymbol.getContainingSymbol(); for (SourceInfo sourceInfo : sourceSymbolMap.getInfosForType(containingSymbol.getContainingType())) { if (sourceInfo.getTaintedArguments().stream() .anyMatch(match -> match.test(parameterSymbol, wellKnownTypeProvider))) { return true; } } return false; }", "answer": "public static bool IsSourceParameter( this TaintedDataSymbolMap<SourceInfo> sourceSymbolMap, IParameterSymbol parameterSymbol, WellKnownTypeProvider wellKnownTypeProvider) { ISymbol containingSymbol = parameterSymbol.ContainingSymbol; foreach (SourceInfo sourceInfo in sourceSymbolMap.GetInfosForType(containingSymbol.ContainingType)) { if (sourceInfo.TaintedArguments.Any(match => match(parameterSymbol, wellKnownTypeProvider))) { return true; } } return false; }"}
{"question": "private static <TInfo> boolean tryResolveDependencies(TInfo info, WellKnownTypeProvider wellKnownTypeProvider) { for (String dependency : info.getDependencyFullTypeNames()) { INamedTypeSymbol typeSymbol = wellKnownTypeProvider.tryGetOrCreateTypeByMetadataName(dependency); if (typeSymbol == null) { return false; } } return true; }", "answer": "private static bool TryResolveDependencies(TInfo info, WellKnownTypeProvider wellKnownTypeProvider) { foreach (string dependency in info.DependencyFullTypeNames) { if (!wellKnownTypeProvider.TryGetOrCreateTypeByMetadataName(dependency, out INamedTypeSymbol? _)) { return false; } } return true; }"}
{"question": "@Override public int hashCode() { RoslynHashCode hashCode = new RoslynHashCode(); HashUtilities.combine(this.getInterfaceInfos(), hashCode); HashUtilities.combine(this.getConcreteInfos(), hashCode); return hashCode.toHashCode(); }", "answer": "public override int GetHashCode() { var hashCode = new RoslynHashCode(); HashUtilities.Combine(this.InterfaceInfos, ref hashCode); HashUtilities.Combine(this.ConcreteInfos, ref hashCode); return hashCode.ToHashCode(); }"}
{"question": "public ContaminatedDataSourceTarget(SymbolAccess target, Set<SinkKind> targetTypes, Set<SymbolAccess> originSources) { if (target == null) { throw new IllegalArgumentException(\"target cannot be null\"); } this.target = target; this.targetTypes = targetTypes; this.originSources = originSources; }", "answer": "public ContaminatedDataSourceTarget( SymbolAccess target, ImmutableHashSet<SinkKind> targetTypes, ImmutableHashSet<SymbolAccess> originSources) { Target = target ?? throw new ArgumentNullException(nameof(target)); TargetTypes = targetTypes; OriginSources = originSources; }"}
{"question": "public class ContaminatedDataConfig { private final WellKnownTypeProvider knownTypeProvider; private final Map<SinkKind, Supplier<TaintedDataSymbolMap<SourceInfo>>> originSymbolMap; private final Map<SinkKind, Supplier<TaintedDataSymbolMap<SanitizerInfo>>> filterSymbolMap; private final Map<SinkKind, Supplier<TaintedDataSymbolMap<SinkInfo>>> targetSymbolMap; private ContaminatedDataConfig( WellKnownTypeProvider knownTypeProvider, Map<SinkKind, Supplier<TaintedDataSymbolMap<SourceInfo>>> originSymbolMap, Map<SinkKind, Supplier<TaintedDataSymbolMap<SanitizerInfo>>> filterSymbolMap, Map<SinkKind, Supplier<TaintedDataSymbolMap<SinkInfo>>> targetSymbolMap ) { this.knownTypeProvider = knownTypeProvider; this.originSymbolMap = originSymbolMap; this.filterSymbolMap = filterSymbolMap; this.targetSymbolMap = targetSymbolMap; }", "answer": "private ContaminatedDataConfig( WellKnownTypeProvider knownTypeProvider, ImmutableDictionary<SinkKind, Lazy<TaintedDataSymbolMap<SourceInfo>>> originSymbolMap, ImmutableDictionary<SinkKind, Lazy<TaintedDataSymbolMap<SanitizerInfo>>> filterSymbolMap, ImmutableDictionary<SinkKind, Lazy<TaintedDataSymbolMap<SinkInfo>>> targetSymbolMap) { WellKnownTypeProvider = knownTypeProvider; SourceSymbolMap = originSymbolMap; SanitizerSymbolMap = filterSymbolMap; SinkSymbolMap = targetSymbolMap; }"}
{"question": "public TaintedDataSymbolMap<SourceInfo> getSourceSymbolMap(SinkKind sinkKind) { return getFromMap(sinkKind, sourceSymbolMap); }", "answer": "public TaintedDataSymbolMap<SourceInfo> GetSourceSymbolMap(SinkKind sinkKind) { return this.GetFromMap<SourceInfo>(sinkKind, this.SourceSymbolMap); }"}
{"question": "public static boolean hasTaintArraySource(SinkKind sinkKind) { return SINK_KIND_HAS_TAINT_ARRAY_SOURCE.computeIfAbsent( sinkKind, key -> getSourceInfos(key).stream().anyMatch(o -> o.isTaintConstantArray()) ); }", "answer": "public static bool HasTaintArraySource(SinkKind sinkKind) { return ImmutableInterlocked.GetOrAdd( ref s_sinkKindHasTaintArraySource, sinkKind, static sinkKind => GetSourceInfos(sinkKind).Any(static o => o.TaintConstantArray) ); }"}
{"question": "class ContaminatedDataBlockAnalysisResult extends AbstractBlockAnalysisResult { private final Map<AnalysisEntity, TaintedDataAbstractValue> result; public ContaminatedDataBlockAnalysisResult( BasicBlock codeBlock, TaintedDataAnalysisData blockAnalysisInfo) { super(codeBlock); if (blockAnalysisInfo != null && blockAnalysisInfo.getCoreData() != null) { this.result = Collections.unmodifiableMap(blockAnalysisInfo.getCoreData()); } else { this.result = Collections.emptyMap(); } } public Map<AnalysisEntity, TaintedDataAbstractValue> getResult() { return result; } }", "answer": "internal class ContaminatedDataBlockAnalysisResult : AbstractBlockAnalysisResult { public ImmutableDictionary<AnalysisEntity, TaintedDataAbstractValue> Result { get; } public ContaminatedDataBlockAnalysisResult( BasicBlock codeBlock, TaintedDataAnalysisData blockAnalysisInfo ) : base(codeBlock) { Result = blockAnalysisInfo?.CoreData.ToImmutableDictionary() ?? ImmutableDictionary<AnalysisEntity, TaintedDataAbstractValue>.Empty; } }"}
{"question": "class TaintedDataBlockAnalysisResult extends AbstractBlockAnalysisResult { private final Map<AnalysisEntity, TaintedDataAbstractValue> data; public TaintedDataBlockAnalysisResult( BasicBlock basicBlock, TaintedDataAnalysisData blockAnalysisData) { super(basicBlock); if (blockAnalysisData != null && blockAnalysisData.getCoreAnalysisData() != null) { this.data = Collections.unmodifiableMap(blockAnalysisData.getCoreAnalysisData()); } else { this.data = Collections.emptyMap(); } } public Map<AnalysisEntity, TaintedDataAbstractValue> getData() { return data; } }", "answer": "internal class TaintedDataBlockAnalysisResult : AbstractBlockAnalysisResult { public ImmutableDictionary<AnalysisEntity, TaintedDataAbstractValue> Data { get; } public TaintedDataBlockAnalysisResult( BasicBlock basicBlock, TaintedDataAnalysisData blockAnalysisData ) : base(basicBlock) { Data = blockAnalysisData?.CoreAnalysisData.ToImmutableDictionary() ?? ImmutableDictionary<AnalysisEntity, TaintedDataAbstractValue>.Empty; } }"}
{"question": "public class TaintedDataAnalysisData extends BaseAnalysisData { public TaintedDataAnalysisData( TaintedDataAnalysisData fromData, TaintedDataAnalysisData data, MapAbstractDomain<AnalysisEntity, TaintedDataAbstractValue> coreDataAnalysisDomain) { super(fromData, data, coreDataAnalysisDomain); } }", "answer": "public TaintedDataAnalysisData( TaintedDataAnalysisData fromData, TaintedDataAnalysisData data, MapAbstractDomain<AnalysisEntity, TaintedDataAbstractValue> coreDataAnalysisDomain ) : base(fromData, data, coreDataAnalysisDomain) { }"}
{"question": "public void reset(TaintedDataAbstractValue resetValue) { super.reset((analysisEntity, currentValue) -> resetValue); }", "answer": "public void Reset(TaintedDataAbstractValue resetValue) { base.Reset((analysisEntity, currentValue) => resetValue); }"}
{"question": "@Override protected void computeHashCodePartsSpecific(RoslynHashCode hashCode) { hashCode.add(SourceInfos.hashCode()); hashCode.add(SanitizerInfos.hashCode()); hashCode.add(SinkInfos.hashCode()); }", "answer": "protected override void ComputeHashCodePartsSpecific(ref RoslynHashCode hashCode) { hashCode.Add(SourceInfos.GetHashCode()); hashCode.Add(SanitizerInfos.GetHashCode()); hashCode.Add(SinkInfos.GetHashCode()); }"}
{"question": "@Override protected boolean checkEqualityByHashCodeParts( AbstractDataFlowAnalysisContext<ContaminatedDataAnalysisData, ContaminatedDataAnalysisContext, TaintedDataAnalysisResult, TaintedDataAbstractValue> item) { ContaminatedDataAnalysisContext another = (ContaminatedDataAnalysisContext) item; return OriginData.hashCode() == another.OriginData.hashCode() && FilterData.hashCode() == another.FilterData.hashCode() && TargetData.hashCode() == another.TargetData.hashCode(); }", "answer": "protected override bool CheckEqualityByHashCodeParts( AbstractDataFlowAnalysisContext<ContaminatedDataAnalysisData, ContaminatedDataAnalysisContext, TaintedDataAnalysisResult, TaintedDataAbstractValue> item) { var another = (ContaminatedDataAnalysisContext)item; return OriginData.GetHashCode() == another.OriginData.GetHashCode() && FilterData.GetHashCode() == another.FilterData.GetHashCode() && TargetData.GetHashCode() == another.TargetData.GetHashCode(); }"}
{"question": "public class ContaminatedDataOperationVisitor extends SomeBaseClass { private ContaminatedDataAnalysisDomain contaminatedDataDomain; private List<?> contaminatedSourcesByTarget; public ContaminatedDataOperationVisitor( ContaminatedDataAnalysisDomain contaminatedDataDomain, ContaminatedDataAnalysisContext analysisFrame) { super(analysisFrame); this.contaminatedDataDomain = contaminatedDataDomain; this.contaminatedSourcesByTarget = new ArrayList<>(); } }", "answer": "public ContaminatedDataOperationVisitor( ContaminatedDataAnalysisDomain contaminatedDataDomain, ContaminatedDataAnalysisContext analysisFrame) : base(analysisFrame) { _contaminatedDataDomain = contaminatedDataDomain; this.ContaminatedSourcesByTarget = new List<>(); }"}
{"question": "private void trackTaintedDataEnteringSink( ISymbol sinkSymbol, Location sinkLocation, Iterable<SinkKind> sinkKinds, Iterable<SymbolAccess> sources) { SymbolAccess sink = new SymbolAccess(sinkSymbol, sinkLocation, this.owningSymbol); this.trackTaintedDataEnteringSink(sink, sinkKinds, sources); }", "answer": "private void TrackTaintedDataEnteringSink( ISymbol sinkSymbol, Location sinkLocation, IEnumerable<SinkKind> sinkKinds, IEnumerable<SymbolAccess> sources) { SymbolAccess sink = new SymbolAccess(sinkSymbol, sinkLocation, this.OwningSymbol); this.TrackTaintedDataEnteringSink(sink, sinkKinds, sources); }"}
{"question": "public TaintedDataAnalysisDomain( MapAbstractDomain<AnalysisEntity, TaintedDataAbstractValue> coreDataAnalysisDomain) { super(coreDataAnalysisDomain); }", "answer": "public TaintedDataAnalysisDomain( MapAbstractDomain<AnalysisEntity, TaintedDataAbstractValue> coreDataAnalysisDomain) : base(coreDataAnalysisDomain) { }"}
{"question": "private TaintedDataAbstractValue( TaintedDataAbstractValueKind kind, ImmutableSet<SymbolAccess> sourceOrigins) { this.kind = kind; this.sourceOrigins = sourceOrigins; }", "answer": "private TaintedDataAbstractValue( TaintedDataAbstractValueKind kind, ImmutableHashSet<SymbolAccess> sourceOrigins) { this.Kind = kind; this.SourceOrigins = sourceOrigins; }"}
{"question": "static TaintedDataAbstractValue mergeTainted( TaintedDataAbstractValue value1, TaintedDataAbstractValue value2) { assert value1.getKind() == TaintedDataAbstractValueKind.TAINTED; assert value2.getKind() == TaintedDataAbstractValueKind.TAINTED; ImmutableSet<SymbolAccess> mergedSources = ImmutableSet.<SymbolAccess>builder() .addAll(value1.getSourceOrigins()) .addAll(value2.getSourceOrigins()) .build(); return new TaintedDataAbstractValue( TaintedDataAbstractValueKind.TAINTED, mergedSources); }", "answer": "internal static TaintedDataAbstractValue MergeTainted( TaintedDataAbstractValue value1, TaintedDataAbstractValue value2) { Debug.Assert(value1.Kind == TaintedDataAbstractValueKind.Tainted); Debug.Assert(value2.Kind == TaintedDataAbstractValueKind.Tainted); return new TaintedDataAbstractValue( TaintedDataAbstractValueKind.Tainted, value1.SourceOrigins.Union(value2.SourceOrigins)); }"}
{"question": "public class SymbolAccess { private final ISymbol symbol; private final Location location; private final ISymbol accessingMethod; public SymbolAccess(ISymbol symbol, SyntaxNode syntaxNode, ISymbol accessingMethod) { if (symbol == null) { throw new IllegalArgumentException(\"symbol cannot be null\"); } if (syntaxNode == null) { throw new IllegalArgumentException(\"syntaxNode cannot be null\"); } if (accessingMethod == null) { throw new IllegalArgumentException(\"accessingMethod cannot be null\"); } this.symbol = symbol; this.location = syntaxNode.getLocation(); this.accessingMethod = accessingMethod; } public ISymbol getSymbol() { return symbol; } public Location getLocation() { return location; } public ISymbol getAccessingMethod() { return accessingMethod; } }", "answer": "public SymbolAccess(ISymbol symbol, SyntaxNode syntaxNode, ISymbol accessingMethod) { Symbol = symbol ?? throw new ArgumentNullException(nameof(symbol)); if (syntaxNode == null) { throw new ArgumentNullException(nameof(syntaxNode)); } Location = syntaxNode.GetLocation(); AccessingMethod = accessingMethod ?? throw new ArgumentNullException(nameof(accessingMethod)); }"}
{"question": "@Override public boolean equals(Object object) { if (this == object) return true; if (object == null || getClass() != object.getClass()) return false; SinkInfo another = (SinkInfo) object; return Objects.equals(this.completeTypeName, another.completeTypeName) && Objects.equals(this.targetTypes, another.targetTypes) && this.isInterface == another.isInterface && this.isAnyStringParamInConstructorATarget == another.isAnyStringParamInConstructorATarget && Objects.equals(this.targetProperties, another.targetProperties) && Objects.equals(this.targetMethodParameters, another.targetMethodParameters); }", "answer": "public bool Equals(SinkInfo another) { return another != null && this.CompleteTypeName == another.CompleteTypeName && this.TargetTypes == another.TargetTypes && this.IsInterface == another.IsInterface && this.IsAnyStringParamInConstructorATarget == another.IsAnyStringParamInConstructorATarget && this.TargetProperties == another.TargetProperties && this.TargetMethodParameters == another.TargetMethodParameters; }"}
{"question": "public static PropertySetAbstractValueKind flagIfNull(PointsToAbstractValue pointsToAbstractValue) { switch (pointsToAbstractValue.getNullState()) { case NULL: return PropertySetAbstractValueKind.FLAGGED; case NOT_NULL: return PropertySetAbstractValueKind.UNFLAGGED; case MAYBE_NULL: return PropertySetAbstractValueKind.MAYBE_FLAGGED; default: return PropertySetAbstractValueKind.UNKNOWN; } }", "answer": "public static PropertySetAbstractValueKind FlagIfNull(PointsToAbstractValue pointsToAbstractValue) { return pointsToAbstractValue.NullState switch { NullAbstractValue.Null => PropertySetAbstractValueKind.Flagged, NullAbstractValue.NotNull => PropertySetAbstractValueKind.Unflagged, NullAbstractValue.MaybeNull => PropertySetAbstractValueKind.MaybeFlagged, _ => PropertySetAbstractValueKind.Unknown, }; }"}
{"question": "public static HazardousUsageEvaluationResult hazardousIfAllFlaggedAndAtLeastOneKnown( IMethodSymbol methodSymbol, PropertySetAbstractValue propertySetAbstractValue) { return hazardousIfAllFlagged(propertySetAbstractValue, false); }", "answer": "public static HazardousUsageEvaluationResult HazardousIfAllFlaggedAndAtLeastOneKnown( IMethodSymbol methodSymbol, PropertySetAbstractValue propertySetAbstractValue) { return HazardousIfAllFlagged(propertySetAbstractValue, assumeAllUnknownInsecure: false); }"}
{"question": "public class PropertySetBlockAnalysisResult extends AbstractBlockAnalysisResult { private final Map<AbstractLocation, PropertySetAbstractValue> data; public PropertySetBlockAnalysisResult(BasicBlock basicBlock, PropertySetAnalysisData blockAnalysisData) { super(basicBlock); if (blockAnalysisData != null) { this.data = Collections.unmodifiableMap(blockAnalysisData.toMap()); } else { this.data = Collections.emptyMap(); } } public Map<AbstractLocation, PropertySetAbstractValue> getData() { return data; } }", "answer": "internal class PropertySetBlockAnalysisResult : AbstractBlockAnalysisResult { public PropertySetBlockAnalysisResult(BasicBlock basicBlock, PropertySetAnalysisData blockAnalysisData) : base(basicBlock) { Data = blockAnalysisData?.ToImmutableDictionary() ?? ImmutableDictionary<AbstractLocation, PropertySetAbstractValue>.Empty; } public ImmutableDictionary<AbstractLocation, PropertySetAbstractValue> Data { get; } }"}
{"question": "public class YourClass { private Map<AbstractLocation, Set<IAssignmentOperation>> abstractLocationsToAssignments; public Map<AbstractLocation, Set<IAssignmentOperation>> getAbstractLocationsToAssignments() { return abstractLocationsToAssignments; } private void setAbstractLocationsToAssignments(Map<AbstractLocation, Set<IAssignmentOperation>> value) { this.abstractLocationsToAssignments = value; } }", "answer": "public PooledDictionary<AbstractLocation, PooledHashSet<IAssignmentOperation>>? AbstractLocationsToAssignments { get; private set; }"}
{"question": "public class YourClass { private Set<IAssignmentOperation> assignmentsWithUnknownLocation; public void trackAssignmentWithUnknownLocation(IAssignmentOperation assignmentOperation) { if (assignmentsWithUnknownLocation == null) { assignmentsWithUnknownLocation = new HashSet<>(); } assignmentsWithUnknownLocation.add(assignmentOperation); } public Set<IAssignmentOperation> getAssignmentsWithUnknownLocation() { return assignmentsWithUnknownLocation; } }", "answer": "public void TrackAssignmentWithUnknownLocation(IAssignmentOperation assignmentOperation) { this.AssignmentsWithUnknownLocation ??= PooledHashSet<IAssignmentOperation>.GetInstance(); this.AssignmentsWithUnknownLocation.Add(assignmentOperation); }"}
{"question": "private static PropertySetAbstractValueKind mergeKind(PropertySetAbstractValueKind kind1, PropertySetAbstractValueKind kind2) { if (kind1 == kind2) { return kind1; } else { return PropertySetAbstractValueKind.MaybeFlagged; } }", "answer": "private static PropertySetAbstractValueKind MergeKind(PropertySetAbstractValueKind kind1, PropertySetAbstractValueKind kind2) { if (kind1 == kind2) { return kind1; } else { return PropertySetAbstractValueKind.MaybeFlagged; } }"}
{"question": "@Override public PropertySetAbstractValue merge(PropertySetAbstractValue value1, PropertySetAbstractValue value2) { int maxKnownCount = Math.max(value1.getKnownValuesCount(), value2.getKnownValuesCount()); ArrayList<PropertySetAbstractValueKind> builder = new ArrayList<>(maxKnownCount); for (int i = 0; i < maxKnownCount; i++) { builder.add(mergeKind(value1.get(i), value2.get(i))); } return PropertySetAbstractValue.getInstance(builder); }", "answer": "public override PropertySetAbstractValue Merge(PropertySetAbstractValue value1, PropertySetAbstractValue value2) { int maxKnownCount = Math.Max(value1.KnownValuesCount, value2.KnownValuesCount); using var _ = ArrayBuilder<PropertySetAbstractValueKind>.GetInstance(maxKnownCount, out var builder); for (int i = 0; i < maxKnownCount; i++) { builder.Add(MergeKind(value1[i], value2[i])); } return PropertySetAbstractValue.GetInstance(builder); }"}
{"question": "public static PropertySetAbstractValue getInstance(ArrayList<PropertySetAbstractValueKind> propertyAbstractValues) { PropertySetAbstractValue instance = tryGetPooledInstance(propertyAbstractValues); if (instance != null) { return instance; } else { return new PropertySetAbstractValue(new ArrayList<>(propertyAbstractValues)); } }", "answer": "public static PropertySetAbstractValue GetInstance(ArrayBuilder<PropertySetAbstractValueKind> propertyAbstractValues) { if (TryGetPooledInstance(propertyAbstractValues, out PropertySetAbstractValue? instance)) { return instance; } else { return new PropertySetAbstractValue(propertyAbstractValues.ToImmutable()); } }"}
{"question": "public PropertySetAbstractValue getInstance(PropertySetAbstractValueKind v1, PropertySetAbstractValueKind v2) { return twoDimensionalPool[v1.ordinal()][v2.ordinal()]; }", "answer": "public PropertySetAbstractValue GetInstance(PropertySetAbstractValueKind v1, PropertySetAbstractValueKind v2) { return this.TwoDimensionalPool[(int)v1, (int)v2]; }"}
{"question": "public class PropertyTransformer { private final String propertyId; private final ValueContentAbstractValueCallback transformFromValueContent; private final int propertyPosition; public PropertyTransformer(String propertyId, ValueContentAbstractValueCallback transformFromValueContentCallback, int propertyPosition) { if (propertyId == null) { throw new NullPointerException(\"propertyId cannot be null\"); } if (transformFromValueContentCallback == null) { throw new NullPointerException(\"transformFromValueContentCallback cannot be null\"); } if (propertyPosition < 0) { throw new IllegalArgumentException(\"propertyPosition must be non-negative\"); } this.propertyId = propertyId; this.transformFromValueContent = transformFromValueContentCallback; this.propertyPosition = propertyPosition; }", "answer": "public PropertyTransformer(string propertyId, ValueContentAbstractValueCallback transformFromValueContentCallback, int propertyPosition) { PropertyId = propertyId ?? throw new ArgumentNullException(nameof(propertyId)); TransformFromValueContent = transformFromValueContentCallback ?? throw new ArgumentNullException(nameof(transformFromValueContentCallback)); PropertyPosition = propertyPosition; if (propertyPosition < 0) { throw new ArgumentOutOfRangeException(nameof(propertyPosition), \"propertyPosition must be non-negative\"); } }"}
{"question": "@Override public int hashCode() { return java.util.Objects.hash( propertyName, mapFromValueContentAbstractValue, mapFromPointsToAbstractValue ); }", "answer": "public override int GetHashCode() { return RoslynHashCode.Combine( this.PropertyName.GetHashCodeOrDefault(), this.MapFromValueContentAbstractValue.GetHashCodeOrDefault(), this.MapFromPointsToAbstractValue.GetHashCodeOrDefault()); }"}
{"question": "@Override public boolean equals(Object obj) { if (this == obj) return true; if (!(obj instanceof PropertyMapper)) return false; return this.equals((PropertyMapper) obj); }", "answer": "public override bool Equals(object obj) { return this.Equals(obj as PropertyMapper); }"}
{"question": "public class HazardousUsageEvaluator { private final String methodName; private final InvocationEvaluationCallback invocationEvaluator; private final HazardousUsageEvaluatorKind kind; private final boolean derivedClass; public HazardousUsageEvaluator(String trackedTypeMethodName, InvocationEvaluationCallback evaluator, boolean derivedClass) { this.methodName = Objects.requireNonNull(trackedTypeMethodName, \"trackedTypeMethodName cannot be null\"); this.invocationEvaluator = Objects.requireNonNull(evaluator, \"evaluator cannot be null\"); this.kind = HazardousUsageEvaluatorKind.Invocation; this.derivedClass = derivedClass; } public HazardousUsageEvaluator(String trackedTypeMethodName, InvocationEvaluationCallback evaluator) { this(trackedTypeMethodName, evaluator, false); }", "answer": "public HazardousUsageEvaluator(string trackedTypeMethodName, InvocationEvaluationCallback evaluator, bool derivedClass = false) { MethodName = trackedTypeMethodName ?? throw new ArgumentNullException(nameof(trackedTypeMethodName)); InvocationEvaluator = evaluator ?? throw new ArgumentNullException(nameof(evaluator)); Kind = HazardousUsageEvaluatorKind.Invocation; DerivedClass = derivedClass; }"}
{"question": "public enum NullAbstractValue { INVALID, UNDEFINED, NULL, NOT_NULL, MAYBE_NULL; }", "answer": "public enum NullAbstractValue { Invalid, Undefined, Null, NotNull, MaybeNull }"}
{"question": "internal class PointerToAbstractValue { private final Set<IOperation> lValueCapturedActions; private PointerToAbstractValue(Set<IOperation> lValueCapturedActions) { this.lValueCapturedActions = lValueCapturedActions; } public static PointerToAbstractValue make(Set<IOperation> lValueCapturedActions) { if (lValueCapturedActions == null || lValueCapturedActions.isEmpty()) { throw new IllegalArgumentException(\"lValueCapturedActions cannot be null or empty\"); } return new PointerToAbstractValue(lValueCapturedActions); } }", "answer": "internal static PointerToAbstractValue Make(ImmutableHashSet<IOperation> lValueCapturedActions) { Debug.Assert(!lValueCapturedActions.IsEmpty); return new PointerAbstractValue(lValueCapturedActions); }"}
{"question": "public class YourClass { private Map<IOperation, Set<AbstractLocation>> escapedOperationLocationsBuilder; public Map<IOperation, Set<AbstractLocation>> getEscapedLocationsThroughOperationsMap() { return getEscapedAbstractLocationsMapAndFreeBuilder(escapedOperationLocationsBuilder); } private Map<IOperation, Set<AbstractLocation>> getEscapedAbstractLocationsMapAndFreeBuilder( Map<IOperation, Set<AbstractLocation>> builder) { Map<IOperation, Set<AbstractLocation>> result = Collections.unmodifiableMap(builder); builder.clear(); return result; } }", "answer": "public ImmutableDictionary<IOperation, ImmutableHashSet<AbstractLocation>> GetEscapedLocationsThroughOperationsMap() => GetEscapedAbstractLocationsMapAndFreeBuilder(_escapedOperationLocationsBuilder);"}
{"question": "@Override protected void setAbstractValueForTupleElementAssignment( AnalysisEntity tupleElementEntity, IOperation assignedValueOperation, PointsToAbstractValue assignedValue) { if (assignedValue == PointsToAbstractValue.UNDEFINED) { return; } super.setAbstractValueForTupleElementAssignment(tupleElementEntity, assignedValueOperation, assignedValue); }", "answer": "protected override void SetAbstractValueForTupleElementAssignment( AnalysisEntity tupleElementEntity, IOperation assignedValueOperation, PointsToAbstractValue assignedValue) { if (assignedValue == PointsToAbstractValue.Undefined) { return; } base.SetAbstractValueForTupleElementAssignment(tupleElementEntity, assignedValueOperation, assignedValue); }"}
{"question": "private static void resetAbstractValueIfTracked(AnalysisEntity analysisEntity, PointsToAnalysisData pointsToAnalysisData) { PointsToAbstractValue currentValue = pointsToAnalysisData.get(analysisEntity); if (currentValue != null) { pointsToAnalysisData.setAbstractValue(analysisEntity, getResetValue(analysisEntity, currentValue)); } }", "answer": "private static void ResetAbstractValueIfTracked(AnalysisEntity analysisEntity, PointsToAnalysisData pointsToAnalysisData) { if (pointsToAnalysisData.TryGetValue(analysisEntity, out var currentValue)) { pointsToAnalysisData.SetAbstractValue(analysisEntity, GetResetValue(analysisEntity, currentValue)); } }"}
{"question": "private static boolean isValidValueForPredicateAnalysis(NullAbstractValue value) { switch (value) { case NULL, NOT_NULL: return true; default: return false; } }", "answer": "private static bool IsValidValueForPredicateAnalysis(NullAbstractValue value) { return value switch { NullAbstractValue.Null or NullAbstractValue.NotNull => true, _ => false, }; }"}
{"question": "@Override protected void computeHashCodePartsSpecific(RoslynHashCode hashCode) { hashCode.add(Integer.valueOf(pointsToAnalysisKind.ordinal()).hashCode()); }", "answer": "protected override void ComputeHashCodePartsSpecific(ref RoslynHashCode hashCode) { hashCode.Add(((int)PointsToAnalysisKind).GetHashCode()); }"}
{"question": "@Override public void setAbstractValue(AnalysisEntity key, PointsToAbstractValue value) { assertValidPointsToAnalysisKeyValuePair(key, value, isDisposable); super.setAbstractValue(key, value); }", "answer": "public override void SetAbstractValue(AnalysisEntity key, PointsToAbstractValue value) { AssertValidPointsToAnalysisKeyValuePair(key, value, _isDisposable); base.SetAbstractValue(key, value); }"}
{"question": "public TrackedEntitiesBuilder(PointsToAnalysisKind pointsToAnalysisKind) { if (pointsToAnalysisKind == PointsToAnalysisKind.None) { throw new IllegalArgumentException(\"pointsToAnalysisKind cannot be None\"); } this.pointsToAnalysisKind = pointsToAnalysisKind; this.allEntities = PooledHashSet.getInstance(AnalysisEntity.class); this.pointsToValues = PooledHashSet.getInstance(PointsToAbstractValue.class); }", "answer": "public TrackedEntitiesBuilder(PointsToAnalysisKind pointsToAnalysisKind) { Debug.Assert(pointsToAnalysisKind != PointsToAnalysisKind.None); PointsToAnalysisKind = pointsToAnalysisKind; AllEntities = PooledHashSet<AnalysisEntity>.GetInstance(); PointsToValues = PooledHashSet<PointsToAbstractValue>.GetInstance(); }"}
{"question": "public void dispose() { if (allEntities != null) { allEntities.free(); } if (pointsToValues != null) { pointsToValues.free(); } }", "answer": "public void Dispose() { AllEntities.Free(); PointsToValues.Free(); }"}
{"question": "public void addEntityAndPointsToValue(AnalysisEntity analysisEntity, PointsToAbstractValue value) { if (!analysisEntity.shouldBeTrackedForPointsToAnalysis(pointsToAnalysisKind)) { throw new AssertionError(\"Entity should be tracked for points-to analysis\"); } allEntities.add(analysisEntity); addTrackedPointsToValue(value); }", "answer": "public void AddEntityAndPointsToValue(AnalysisEntity analysisEntity, PointsToAbstractValue value) { Debug.Assert(analysisEntity.ShouldBeTrackedForPointsToAnalysis(PointsToAnalysisKind)); AllEntities.Add(analysisEntity); AddTrackedPointsToValue(value); }"}
{"question": "public Map<IParameterSymbol, SyntaxNode> getRiskyParameterUsages() { if (_riskyParameterUsageBuilder == null) { throw new AssertionError(\"_riskyParameterUsageBuilder should not be null\"); } return Collections.unmodifiableMap(_riskyParameterUsageBuilder); }", "answer": "public ImmutableDictionary<IParameterSymbol, SyntaxNode> RiskyParameterUsages { get { RoslynDebug.Assert(_riskyParameterUsageBuilder != null); return _riskyParameterUsageBuilder.ToImmutable(); } }"}
{"question": "@Override protected void setAbstractValue(AbstractLocation location, ParameterValidationAbstractValue value) { if (isTrackedLocation(location)) { currentAnalysisData.put(location, value); } }", "answer": "protected override void SetAbstractValue(AbstractLocation location, ParameterValidationAbstractValue value) { if (IsTrackedLocation(location)) { CurrentAnalysisData[location] = value; } }"}
{"question": "@Override protected void setValueForParameterPointsToLocationOnEntry(IParameterSymbol parameter, PointsToAbstractValue pointsToAbstractValue) { if (pointsToAbstractValue.getKind() == PointsToAbstractValueKind.KNOWN_LOCATIONS) { ParameterValidationAbstractValue value = hasAnyNullValidationAttribute(parameter) ? ParameterValidationAbstractValue.VALIDATED : ParameterValidationAbstractValue.NOT_VALIDATED; setAbstractValue(pointsToAbstractValue.getLocations(), value); } }", "answer": "protected override void SetValueForParameterPointsToLocationOnEntry(IParameterSymbol parameter, PointsToAbstractValue pointsToAbstractValue) { if (pointsToAbstractValue.Kind == PointsToAbstractValueKind.KnownLocations) { var value = HasAnyNullValidationAttribute(parameter) ? ParameterValidationAbstractValue.Validated : ParameterValidationAbstractValue.NotValidated; SetAbstractValue(pointsToAbstractValue.Locations, value); } }"}
{"question": "@Override public ParameterValidationAbstractValue visitObjectCreation(IObjectCreationOperation operation, Object argument) { ParameterValidationAbstractValue value = super.visitObjectCreation(operation, argument); processRegularInvocationOrCreation(operation.getConstructor(), operation.getArguments(), operation); return value; }", "answer": "public override ParameterValidationAbstractValue VisitObjectCreation(IObjectCreationOperation operation, object? argument) { var value = base.VisitObjectCreation(operation, argument); ProcessRegularInvocationOrCreation(operation.Constructor, operation.Arguments, operation); return value; }"}
{"question": "public class ParameterValidationAnalysisOutcome extends DataFlowAnalysisResult<ParameterValidationBlockAnalysisResult, ParameterValidationAbstractValue> { private final Map<IParameterSymbol, SyntaxNode> riskyParameterUsages; public ParameterValidationAnalysisOutcome( DataFlowAnalysisResult<ParameterValidationBlockAnalysisResult, ParameterValidationAbstractValue> parameterCheckAnalysisResult, Map<IParameterSymbol, SyntaxNode> riskyParameterUsages) { super(parameterCheckAnalysisResult); this.riskyParameterUsages = riskyParameterUsages; } public Map<IParameterSymbol, SyntaxNode> getRiskyParameterUsages() { return riskyParameterUsages; } }", "answer": "public ParameterValidationAnalysisOutcome( DataFlowAnalysisResult<ParameterValidationBlockAnalysisResult, ParameterValidationAbstractValue> parameterCheckAnalysisResult, ImmutableDictionary<IParameterSymbol, SyntaxNode> riskyParameterUsages) : base(parameterCheckAnalysisResult) { RiskyParameterUsages = riskyParameterUsages; }"}
{"question": "public class ParameterValidationBlockAnalysisResult extends AbstractBlockAnalysisResult { private final Map<AbstractLocation, ParameterValidationAbstractValue> data; public ParameterValidationBlockAnalysisResult(BasicBlock basicBlock, ParameterValidationAnalysisData blockAnalysisData) { super(basicBlock); if (blockAnalysisData != null) { this.data = Collections.unmodifiableMap(blockAnalysisData.toImmutableMap()); } else { this.data = Collections.emptyMap(); } } public Map<AbstractLocation, ParameterValidationAbstractValue> getData() { return data; } }", "answer": "public ParameterValidationBlockAnalysisResult(BasicBlock basicBlock, ParameterValidationAnalysisData blockAnalysisData) : base(basicBlock) { Data = blockAnalysisData?.ToImmutableDictionary() ?? ImmutableDictionary<AbstractLocation, ParameterValidationAbstractValue>.Empty; }"}
{"question": "class CopyAbstractValue { private final Set<AnalysisEntity> entities; private final CopyAbstractValueKind kind; CopyAbstractValue(AnalysisEntity analysisEntity) { this.entities = Collections.singleton(analysisEntity); this.kind = analysisEntity.getType().isReferenceType() ? CopyAbstractValueKind.KNOWN_REFERENCE_COPY : CopyAbstractValueKind.KNOWN_VALUE_COPY; } }", "answer": "internal CopyAbstractValue(AnalysisEntity analysisEntity) : this(ImmutableHashSet.Create(analysisEntity), kind: analysisEntity.Type.IsReferenceType ? CopyAbstractValueKind.KnownReferenceCopy : CopyAbstractValueKind.KnownValueCopy) { }"}
{"question": "@Override protected void computeHashCodeParts(RoslynHashCode hashCode) { hashCode.add(HashUtilities.combine(analysisEntities)); hashCode.add(Integer.valueOf(kind.ordinal()).hashCode()); }", "answer": "protected override void ComputeHashCodeParts(ref RoslynHashCode hashCode) { hashCode.Add(HashUtilities.Combine(AnalysisEntities)); hashCode.Add(((int)Kind).GetHashCode()); }"}
{"question": "public class CopyDataFlowOperationVisitor extends BaseDataFlowOperationVisitor { private CopyAnalysisDomain analysisDomain; public CopyDataFlowOperationVisitor(CopyAnalysisContext analysisContext) { super(analysisContext); CoreCopyAnalysisDataDomain coreAnalysisDomain = new CoreCopyAnalysisDataDomain(CopyAbstractValueDomain.DEFAULT, this::getDefaultCopyValue); this.analysisDomain = new CopyAnalysisDomain(coreAnalysisDomain); if (analysisContext.getInterproceduralAnalysisData() != null && analysisContext.getInterproceduralAnalysisData().getInitialAnalysisData() != null) { analysisContext.getInterproceduralAnalysisData() .getInitialAnalysisData() .assertValidCopyAnalysisData(); } } }", "answer": "public CopyDataFlowOperationVisitor(CopyAnalysisContext analysisContext) : base(analysisContext) { var coreAnalysisDomain = new CoreCopyAnalysisDataDomain(CopyAbstractValueDomain.Default, GetDefaultCopyValue); AnalysisDomain = new CopyAnalysisDomain(coreAnalysisDomain); analysisContext.InterproceduralAnalysisData?.InitialAnalysisData?.AssertValidCopyAnalysisData(); }"}
{"question": "private static CopyAnalysisResult tryGetOrComputeResultForAnalysisContext(CopyAnalysisContext analysisContext) { CopyDataFlowOperationVisitor operationVisitor = new CopyDataFlowOperationVisitor(analysisContext); CopyAnalysis copyAnalysis = new CopyAnalysis(operationVisitor); return copyAnalysis.tryGetOrComputeResultCore(analysisContext, true); }", "answer": "private static CopyAnalysisResult? TryGetOrComputeResultForAnalysisContext(CopyAnalysisContext analysisContext) { var operationVisitor = new CopyDataFlowOperationVisitor(analysisContext); var copyAnalysis = new CopyAnalysis(operationVisitor); return copyAnalysis.TryGetOrComputeResultCore(analysisContext, cacheResult: true); }"}
{"question": "private CopyAnalysisData(CopyAnalysisData fromData) { super(fromData); assertValidCopyAnalysisData(); }", "answer": "private CopyAnalysisData(CopyAnalysisData fromData) : base(fromData) { AssertValidCopyAnalysisData(); }"}
{"question": "public final class CopyBlockAnalysisResult extends AbstractBlockAnalysisResult { private final Map<AnalysisEntity, CopyAbstractValue> data; private final boolean isReachable; CopyBlockAnalysisResult(BasicBlock basicBlock, CopyAnalysisData blockAnalysisData) { super(basicBlock); if (blockAnalysisData != null && blockAnalysisData.getCoreAnalysisData() != null) { this.data = Collections.unmodifiableMap(new HashMap<>(blockAnalysisData.getCoreAnalysisData())); } else { this.data = Collections.emptyMap(); } this.isReachable = blockAnalysisData != null ? blockAnalysisData.isReachableBlockData() : true; } public Map<AnalysisEntity, CopyAbstractValue> getData() { return data; } public boolean isReachable() { return isReachable; } }", "answer": "public sealed class CopyBlockAnalysisResult : AbstractBlockAnalysisResult { internal CopyBlockAnalysisResult(BasicBlock basicBlock, CopyAnalysisData blockAnalysisData) : base(basicBlock) { Data = blockAnalysisData?.CoreAnalysisData.ToImmutableDictionary() ?? ImmutableDictionary<AnalysisEntity, CopyAbstractValue>.Empty; IsReachable = blockAnalysisData?.IsReachableBlockData ?? true; } }"}
{"question": "public Map<IFieldSymbol, PointsToAbstractValue> getTrackedInstanceFieldPointsToMap() { if (_trackedInstanceFieldLocations == null) { throw new IllegalStateException(); } return Collections.unmodifiableMap(new HashMap<>(_trackedInstanceFieldLocations)); }", "answer": "public ImmutableDictionary<IFieldSymbol, PointsToAbstractValue> TrackedInstanceFieldPointsToMap { get { if (_trackedInstanceFieldLocations == null) { throw new InvalidOperationException(); } return _trackedInstanceFieldLocations.ToImmutableDictionary(); } }"}
{"question": "private void handlePossibleEscapingOperation(IOperation escapingOperation, Set<AbstractLocation> escapedLocations) { for (AbstractLocation escapedLocation : escapedLocations) { DisposeAbstractValue currentDisposeValue = CurrentAnalysisData.get(escapedLocation); if (currentDisposeValue != null && currentDisposeValue.getKind() != DisposeAbstractValueKind.UNKNOWN) { DisposeAbstractValue newDisposeValue = currentDisposeValue.withNewEscapingOperation(escapingOperation); setAbstractValue(escapedLocation, newDisposeValue); } } }", "answer": "private void HandlePossibleEscapingOperation(IOperation escapingOperation, ImmutableHashSet<AbstractLocation> escapedLocations) { foreach (AbstractLocation escapedLocation in escapedLocations) { if (CurrentAnalysisData.TryGetValue(escapedLocation, out var currentDisposeValue) && currentDisposeValue.Kind != DisposeAbstractValueKind.Unknown) { DisposeAbstractValue newDisposeValue = currentDisposeValue.WithNewEscapingOperation(escapingOperation); SetAbstractValue(escapedLocation, newDisposeValue); } } }"}
{"question": "private void ensureDisposableFieldsMap() { if (_lazyDisposableFieldsMap == null) { synchronized (this) { if (_lazyDisposableFieldsMap == null) { _lazyDisposableFieldsMap = new ConcurrentHashMap<INamedTypeSymbol, Set<IFieldSymbol>>(); } } } }", "answer": "private void EnsureDisposableFieldsMap() { if (_lazyDisposableFieldsMap == null) { Interlocked.CompareExchange(ref _lazyDisposableFieldsMap, new ConcurrentDictionary<INamedTypeSymbol, ImmutableHashSet<IFieldSymbol>>(), null); } }"}
{"question": "public static Predicate<ITypeSymbol> getIsDisposableDelegate(Compilation compilation) { DisposeAnalysisHelper disposeAnalysisHelper = tryGetOrCreate(compilation); if (disposeAnalysisHelper != null) { return disposeAnalysisHelper::isDisposable; } return type -> false; }", "answer": "public static Func<ITypeSymbol?, bool> GetIsDisposableDelegate(Compilation compilation) { if (TryGetOrCreate(compilation, out var disposeAnalysisHelper)) { return disposeAnalysisHelper.IsDisposable; } return _ => false; }"}
{"question": "private boolean hasDisposableOwnershipTransferForConstructorParameter(IMethodSymbol containingMethod) { return containingMethod.getMethodKind() == MethodKind.CONSTRUCTOR && containingMethod.getParameters().stream() .anyMatch(p -> disposeOwnershipTransferLikelyTypes.contains(p.getType())); }", "answer": "private bool HasDisposableOwnershipTransferForConstructorParameter(IMethodSymbol containingMethod) => containingMethod.MethodKind == MethodKind.Constructor && containingMethod.Parameters.Any(p => _disposeOwnershipTransferLikelyTypes.Contains(p.Type));"}
{"question": "public boolean containsAnyResourceCreationDescendant(ImmutableList<IOperation> operationGroups, IMethodSymbol enclosingMethod) { return hasAnyOperationDescendant(operationGroups, this::isResourceCreation) || hasResourceOwnershipChangeInConstructorParam(enclosingMethod); }", "answer": "public bool ContainsAnyResourceCreationDescendant(ImmutableArray<IOperation> operationGroups, IMethodSymbol enclosingMethod) { return operationGroups.HasAnyOperationDescendant(IsResourceCreation) || HasResourceOwnershipChangeInConstructorParam(enclosingMethod); }"}
{"question": "public boolean isResourceCreationOrResourceOwnershipChange(AbstractLocation location, IMethodSymbol enclosingMethod) { if (location.getCreation() == null) { return location.getSymbol() != null && location.getSymbol().getKind() == SymbolKind.PARAMETER && hasResourceOwnershipChangeInConstructorParam(enclosingMethod); } return isResourceCreation(location.getCreation()); }", "answer": "public bool IsResourceCreationOrResourceOwnershipChange(AbstractLocation location, IMethodSymbol enclosingMethod) { if (location.Creation == null) { return location.Symbol?.Kind == SymbolKind.Parameter && HasResourceOwnershipChangeInConstructorParam(enclosingMethod); } return IsResourceCreation(location.Creation); }"}
{"question": "static ControlFlowRegion getInnermostRegionStartedByBlock(BasicBlock basicBlock, ControlFlowRegionKind regionKind) { if (basicBlock.getEnclosingRegion() == null || basicBlock.getEnclosingRegion().getFirstBlockOrdinal() != basicBlock.getOrdinal()) { return null; }", "answer": "internal static ControlFlowRegion? GetInnermostRegionStartedByBlock(this BasicBlock basicBlock, ControlFlowRegionKind regionKind) { if (basicBlock.EnclosingRegion?.FirstBlockOrdinal != basicBlock.Ordinal) { return null; }"}
{"question": "static boolean dominatesPredecessors(BasicBlock basicBlock, ControlFlowGraph cfg) { if (basicBlock == null || basicBlock.getPredecessors().isEmpty()) { return false; }", "answer": "internal static bool DominatesPredecessors(this BasicBlock? basicBlock, ControlFlowGraph cfg) { if (basicBlock == null || basicBlock.Predecessors.IsEmpty) { return false; }"}
{"question": "public static boolean isBackEdge(ControlFlowBranch controlFlowBranch) { return controlFlowBranch != null && controlFlowBranch.getSource() != null && controlFlowBranch.getDestination() != null && controlFlowBranch.getSource().getOrdinal() >= controlFlowBranch.getDestination().getOrdinal(); }", "answer": "public static bool IsBackEdge(this ControlFlowBranch controlFlowBranch) => controlFlowBranch?.Source != null && controlFlowBranch.Destination != null && controlFlowBranch.Source.Ordinal >= controlFlowBranch.Destination.Ordinal;"}
{"question": "public static ControlFlowConditionKind negate(ControlFlowConditionKind controlFlowConditionKind) { switch (controlFlowConditionKind) { case WHEN_FALSE: return ControlFlowConditionKind.WHEN_TRUE; case WHEN_TRUE: return ControlFlowConditionKind.WHEN_FALSE; default: System.err.println(\"Unsupported conditional kind: \" + controlFlowConditionKind); return controlFlowConditionKind; } }", "answer": "public static ControlFlowConditionKind Negate(this ControlFlowConditionKind controlFlowConditionKind) { switch (controlFlowConditionKind) { case ControlFlowConditionKind.WhenFalse: return ControlFlowConditionKind.WhenTrue; case ControlFlowConditionKind.WhenTrue: return ControlFlowConditionKind.WhenFalse; default: Debug.Fail($\"Unsupported conditional kind: '{controlFlowConditionKind}'\"); return controlFlowConditionKind; } }"}
{"question": "public static List<IOperation> descendantOperations(ControlFlowRegion controlFlowRegion, ControlFlowGraph cfg) { List<IOperation> result = new ArrayList<>(); for (int i = controlFlowRegion.getFirstBlockOrdinal(); i <= controlFlowRegion.getLastBlockOrdinal(); i++) { BasicBlock block = cfg.getBlocks().get(i); result.addAll(block.descendantOperations()); } return result; }", "answer": "public static IEnumerable<IOperation> DescendantOperations(this ControlFlowRegion controlFlowRegion, ControlFlowGraph cfg) { for (var i = controlFlowRegion.FirstBlockOrdinal; i <= controlFlowRegion.LastBlockOrdinal; i++) { var block = cfg.Blocks[i]; foreach (var operation in block.DescendantOperations()) { yield return operation; } } }"}
{"question": "public static boolean isLValueFlowCaptureReference(IFlowCaptureReferenceOperation flowCaptureReference) { if (flowCaptureReference.getParent() instanceof IAssignmentOperation assignment) { return assignment.getTarget().equals(flowCaptureReference); } return false; }", "answer": "public static bool IsLValueFlowCaptureReference(this IFlowCaptureReferenceOperation flowCaptureReference) => flowCaptureReference.Parent is IAssignmentOperation assignment && assignment.Target == flowCaptureReference;"}
{"question": "public static ControlFlowGraph getControlFlowGraph(List<IOperation> operationBlocks) { for (IOperation operationRoot : operationBlocks) { ControlFlowGraph cfg = operationRoot.tryGetEnclosingControlFlowGraph(); if (cfg != null) { return cfg; } } return null; }", "answer": "public static ControlFlowGraph? GetControlFlowGraph(this ImmutableArray<IOperation> operationBlocks) { foreach (var operationRoot in operationBlocks) { if (operationRoot.TryGetEnclosingControlFlowGraph(out var cfg)) { return cfg; } } return null; }"}
{"question": "static AssemblyMetricData computeSynchronously(IAssemblySymbol assembly, CodeMetricsAnalysisContext context) { List<CodeAnalysisMetricData> children = computeSynchronously(getChildSymbols(assembly), context); return computeFromChildren(assembly, children, context); }", "answer": "internal static AssemblyMetricData ComputeSynchronously(IAssemblySymbol assembly, CodeMetricsAnalysisContext context) { ImmutableArray<CodeAnalysisMetricData> children = ComputeSynchronously(GetChildSymbols(assembly), context); return ComputeFromChildren(assembly, children, context); }"}
{"question": "void processNamespace(INamespaceSymbol namespaceSymbol) { for (INamespaceOrTypeSymbol child : namespaceSymbol.getMembers()) { if (child.getKind() == SymbolKind.NAMESPACE) { processNamespace((INamespaceSymbol) child); } else if (namespaceSymbol.isGlobalNamespace()) { includeGlobalNamespace = true; } else if (!child.isImplicitlyDeclared()) { namespacesWithTypeMember.add(namespaceSymbol); } } }", "answer": "void processNamespace(INamespaceSymbol @namespace) { foreach (INamespaceOrTypeSymbol child in @namespace.GetMembers()) { if (child.Kind == SymbolKind.Namespace) { processNamespace((INamespaceSymbol)child); } else if (@namespace.IsGlobalNamespace) { includeGlobalNamespace = true; } else if (!child.IsImplicitlyDeclared) { namespacesWithTypeMember.Add(@namespace); } } }"}
{"question": "private static List<IMethodSymbol> getAccessors(IEventSymbol eventSymbol) { List<IMethodSymbol> accessors = new ArrayList<>(); if (eventSymbol.getAddMethod() != null) { accessors.add(eventSymbol.getAddMethod()); } if (eventSymbol.getRemoveMethod() != null) { accessors.add(eventSymbol.getRemoveMethod()); } return accessors; }", "answer": "private static IEnumerable<IMethodSymbol> GetAccessors(IEventSymbol @event) { if (@event.AddMethod != null) { yield return @event.AddMethod; } if (@event.RemoveMethod != null) { yield return @event.RemoveMethod; } }"}
{"question": "static NamespaceMetricData computeSynchronously(INamespaceSymbol namespaceSymbol, CodeMetricsAnalysisContext context) { List<CodeAnalysisMetricData> children = computeSynchronously(getChildSymbols(namespaceSymbol), context); return computeFromChildren(namespaceSymbol, children, context); }", "answer": "internal static NamespaceMetricData ComputeSynchronously(INamespaceSymbol @namespace, CodeMetricsAnalysisContext context) { ImmutableArray<CodeAnalysisMetricData> children = ComputeSynchronously(GetChildSymbols(@namespace), context); return ComputeFromChildren(@namespace, children, context); }"}
{"question": "private static int calculateMaintainabilityIndex(ComputationalComplexityMetrics computationalComplexityMetrics, int cyclomaticComplexity) { double computationalComplexityVolume = Math.max(0.0, Math.log(computationalComplexityMetrics.getVolume())); // avoid Log(0) = -Infinity double logEffectiveLinesOfCode = Math.max(0.0, Math.log(computationalComplexityMetrics.getEffectiveLinesOfCode())); // avoid Log(0) = -Infinity double rawMI = 171 - 5.2 * computationalComplexityVolume - 0.23 * cyclomaticComplexity - 16.2 * logEffectiveLinesOfCode; return MetricsHelper.normalizeAndRoundMaintainabilityIndex(rawMI); }", "answer": "private static int CalculateMaintainabilityIndex(ComputationalComplexityMetrics computationalComplexityMetrics, int cyclomaticComplexity) { double computationalComplexityVolume = Math.Max(0.0, Math.Log(computationalComplexityMetrics.Volume)); //avoid Log(0) = -Infinity double logEffectiveLinesOfCode = Math.Max(0.0, Math.Log(computationalComplexityMetrics.EffectiveLinesOfCode)); //avoid Log(0) = -Infinity return MetricsHelper.NormalizeAndRoundMaintainabilityIndex( 171 - 5.2 * computationalComplexityVolume - 0.23 * cyclomaticComplexity - 16.2 * logEffectiveLinesOfCode ); }"}
{"question": "public static CompletableFuture<CodeAnalysisMetricData> computeAsync(Compilation compilation, CancellationToken cancellationToken) { if (compilation == null) { throw new IllegalArgumentException(\"compilation cannot be null\"); } CodeMetricsAnalysisContext context = new CodeMetricsAnalysisContext(compilation, cancellationToken); return computeAsync(compilation.getAssembly(), context); }", "answer": "public static Task<CodeAnalysisMetricData> ComputeAsync(Compilation compilation, CancellationToken cancellationToken) { if (compilation == null) { throw new ArgumentNullException(nameof(compilation)); } return ComputeAsync(compilation.Assembly, new CodeMetricsAnalysisContext(compilation, cancellationToken)); }"}
{"question": "private void countOperator(IOperation operation) { operatorUsageCounts++; if (distinctOperatorKindsBuilder == null) { distinctOperatorKindsBuilder = new HashSet<>(); } distinctOperatorKindsBuilder.add(operation.getKind()); }", "answer": "void countOperator(IOperation operation) { operatorUsageCounts++; distinctOperatorKindsBuilder ??= ImmutableHashSet.CreateBuilder<OperationKind>(); distinctOperatorKindsBuilder.Add(operation.Kind); }"}
{"question": "static void addAssociatedNamedTypes( Set<INamedTypeSymbol> builder, WellKnownTypeProvider knownTypeProvider, ITypeSymbol associatedType) { addAssociatedNamedTypesCore(builder, associatedType, knownTypeProvider); }", "answer": "internal static void AddAssociatedNamedTypes(ImmutableHashSet<INamedTypeSymbol>.Builder builder, WellKnownTypeProvider knownTypeProvider, ITypeSymbol associatedType) { AddAssociatedNamedTypesCore(builder, associatedType, knownTypeProvider); }"}
{"question": "static void removeContainingTypes(ISymbol symbol, Set<INamedTypeSymbol> coupledTypesBuilder) { INamedTypeSymbol namedType = (symbol instanceof INamedTypeSymbol) ? (INamedTypeSymbol) symbol : symbol.getContainingType(); while (namedType != null) { coupledTypesBuilder.remove(namedType); namedType = namedType.getContainingType(); } }", "answer": "internal static void RemoveContainingTypes(ISymbol symbol, ImmutableHashSet<INamedTypeSymbol>.Builder coupledTypesBuilder) { var namedType = symbol as INamedTypeSymbol ?? symbol.ContainingType; while (namedType != null) { coupledTypesBuilder.Remove(namedType); namedType = namedType.ContainingType; } }"}
{"question": "static List<IParameterSymbol> getParameters(ISymbol member) { switch (member.getKind()) { case METHOD: return ((IMethodSymbol) member).getParameters(); case PROPERTY: return ((IPropertySymbol) member).getParameters(); default: return Collections.emptyList(); } }", "answer": "internal static ImmutableArray<IParameterSymbol> GetParameters(this ISymbol member) { return member.Kind switch { SymbolKind.Method => ((IMethodSymbol)member).Parameters, SymbolKind.Property => ((IPropertySymbol)member).Parameters, _ => ImmutableArray<IParameterSymbol>.Empty, }; }"}
{"question": "public class SemanticModelProvider { private final Compilation compilation; private final ConcurrentHashMap<SyntaxTree, SemanticModel> semanticModelMap; public SemanticModelProvider(Compilation compilation) { this.compilation = Objects.requireNonNull(compilation, \"compilation must not be null\"); this.semanticModelMap = new ConcurrentHashMap<>(); } public Compilation getCompilation() { return compilation; } public ConcurrentHashMap<SyntaxTree, SemanticModel> getSemanticModelMap() { return semanticModelMap; } }", "answer": "public SemanticModelProvider(Compilation compilation) { Compilation = compilation; _semanticModelMap = new ConcurrentDictionary<SyntaxTree, SemanticModel>(); }"}
{"question": "public SemanticModel getSemanticModel(SyntaxNode node) { return semanticModelMap.computeIfAbsent( node.getSyntaxTree(), tree -> compilation.getSemanticModel(tree) ); }", "answer": "public SemanticModel GetSemanticModel(SyntaxNode node) => _semanticModelMap.GetOrAdd(node.SyntaxTree, tree => Compilation.GetSemanticModel(node.SyntaxTree));"}
{"question": "public static Diagnostic createDiagnostic( SyntaxNode node, DiagnosticDescriptor rule, Object... args) { return node.createDiagnostic(rule, null, args); }", "answer": "public static Diagnostic CreateDiagnostic( this SyntaxNode node, DiagnosticDescriptor rule, params object[] args) => node.CreateDiagnostic(rule, properties: null, args);"}
