{"question": "public class InputValidator { public static final Set<SanitizerInfo> sanitizerInfos; static { Set<SanitizerInfo> fabricator = new HashSet<>(); fabricator.add(new SanitizerInfo( WellKnownTypeNames.SYSTEM_TEXT_STRING_BUILDER, false, false, null, new String[] { \"Clear\" } )); sanitizerInfos = fabricator; } }", "answer": "static InputValidator() { var fabricator = PooledHashSet<SanitizerInfo>.GetInstance(); fabricator.ConfigureSanitizer( WellKnownTypeNames.SystemTextStringBuilder, isInterface: false, isConstructorSanitizing: false, sanitizingMethods: (string[]?)null, sanitizingInstanceMethods: new[] { \"Clear\", } ); }"}
{"question": "public final class AllCleaners { public static final Set<SanitizerInfo> CLEANER_DETAILS; static { Set<SanitizerInfo> maker = new HashSet<>(); CLEANER_DETAILS = Collections.unmodifiableSet(maker); } private AllCleaners() { } }", "answer": "namespace Analyzer.Utilities.FlowAnalysis.Analysis.TaintedDataAnalysis { internal static class AllCleaners { public static ImmutableHashSet<SanitizerInfo> CleanerDetails { get; } } }"}
{"question": "public final class GeneralCustomCodeFormatAnalyzerEvaluations { @Test public void checkRuleSequenceConsistencyPreserved() { List<String> rules = IntStream.range(10, 30) .mapToObj(index -> \"IDE_\" + index) .collect(Collectors.toList()); TestAnalyzer checker = new TestAnalyzer(rules); List<String> ruleIdentifiers = checker.getSupportedDiagnostics() .stream() .map(rule -> rule.getId()) .collect(Collectors.toList()); assertEquals(rules, ruleIdentifiers); } }", "answer": "public sealed class GeneralCustomCodeFormatAnalyzerEvaluations { [Fact] public void CheckRuleSequenceConsistencyPreserved() { var rules = Enumerable.Range(10, 20).Select(index => \"IDE_\" + index); var checker = new TestAnalyzer(rules); Assert.Equal(checker.SupportedDiagnostics.Select(static diagnostic => diagnostic.Id), rules); } }"}
{"question": "public class RuleChecker extends CoreValidator { public RuleChecker(List<String> rules) { super(generateIssueSettingsFromRuleIdentifiers(rules)); } private static List<Diagnostic> generateIssueSettingsFromRuleIdentifiers(List<String> rules) { return List.of(); } }", "answer": "public RuleChecker(IEnumerable<string> rules) : base(GenerateIssueSettingsFromRuleIdentifiers(rules)) { }"}
{"question": "public class ValueTypesCheckTest { @Test public void checkValueTypes() throws Exception { String originalCode = \"\"\" package test; class T1 {} \"\"\"; String expectedResult = \"\"\" package test; // internal ref struct T1 {} -> Java 没有 internal/ref struct class T1 {} \"\"\"; String actualResult = executeFixProcess(originalCode); assertEquals(expectedResult.trim(), actualResult.trim()); }", "answer": "public Task CheckValueTypes() => CheckCSharp.CheckFixProcessAsync(\"\"\" namespace Test { ref struct [|T1|] { } } \"\"\", \"\"\" namespace Test { internal ref struct T1 { } } \"\"\");"}
{"question": "public class ContainedClassCheck { @Test public void checkContainedClass4() { String[] params = {}; A obj = new A(); String className = A.External.Internal.class.getName(); assertEquals(\"ContainedClassCheck$A$External$Internal\", className); } static class A { void Process(String[] params) { var name = External.Internal.class.getName(); } } static class External<U> { public static class Internal<U> {} } }", "answer": "using NUnit.Framework; public class ContainedClassCheck { [Test] public void CheckContainedClass4() { string[] arguments = { }; A obj = new A(); string className = typeof(A.External.Internal).FullName; Assert.AreEqual(\"ContainedClassCheck+A+External+Internal\", className); } public class A { public void Process(string[] arguments) { var name = typeof(External.Internal).FullName; } } public class External<U> { public class Internal<U> { } } }"}
{"question": "public class PathTraversalOrigins { public static final Set<SourceInfo> OriginSources; static { Set<SourceInfo> originDataCollector = new HashSet<>(); originDataCollector.add(new SourceInfo( WellKnownTypeNames.SYSTEM_IO_COMPRESSION_ZIP_ARCHIVE_ENTRY, false, new String[] { \"FullName\" }, null )); OriginSources = Collections.unmodifiableSet(originDataCollector); } }", "answer": "static PathTraversalOrigins() { var originDataCollector = PooledHashSet<SourceInfo>.GetInstance(); originDataCollector.AddOriginRecord( WellKnownTypeNames.SystemIOCompressionZipArchiveEntry, isInterface: false, taintedProperties: new string[] { \"FullName\", }, taintedMethods: null); OriginSources = originDataCollector.ToFixedAndRelease(); }"}
{"question": "public class PathTraversalTargets { public static final Set<SinkInfo> TargetData; static { Set<SinkInfo> collector = new HashSet<>(); collector.add(new SinkInfo( WellKnownTypeNames.SYSTEM_IO_COMPRESSION_ZIP_FILE_EXTENSIONS, SinkKind.ZIP_SLIP, false, false, null, new MethodParameter[] { new MethodParameter(\"ExtractToFile\", new String[] { \"destinationFileName\" }) } )); TargetData = Collections.unmodifiableSet(collector); } }", "answer": "static PathTraversalTargets() { var collector = PooledHashSet<SinkInfo>.GetInstance(); collector.AddTargetRecord( WellKnownTypeNames.SystemIOCompressionZipFileExtensions, SinkKind.ZipSlip, isInterface: false, isAnyStringParameterInConstructorASink: false, sinkProperties: null, sinkMethodParameters: new[] { (\"ExtractToFile\", new[] { \"destinationFileName\" } ), });"}
{"question": "public class XmlTargets { public static final Set<SinkInfo> TargetData; static { Set<SinkInfo> collector = new HashSet<>(); collector.add(new SinkInfo( WellKnownTypeNames.SYSTEM_XML_XML_ATTRIBUTE, SinkKind.XML, false, false, new String[] { \"InnerXml\" }, null / )); TargetData = Collections.unmodifiableSet(collector); } }", "answer": "static XmlTargets() { var collector = PooledHashSet<SinkInfo>.GetInstance(); collector.AddTargetRecord( WellKnownTypeNames.SystemXmlXmlAttribute, SinkKind.Xml, isInterface: false, isAnyStringParameterInConstructorASink: false, sinkProperties: new[] { \"InnerXml\", }, sinkMethodParameters: null);"}
{"question": "static { PooledHashSet<SinkInfo> collector = PooledHashSet.getInstance(); collector.add(new SinkInfo( WellKnownTypeNames.SYSTEM_XML_XMLDOCUMENT, SinkKind.XML, false, false, new String[] { \"InnerXml\" }, null )); }", "answer": "static XmlTargets() { var collector = PooledHashSet<SinkInfo>.GetInstance(); collector.AddTargetRecord( WellKnownTypeNames.SystemXmlXmlDocument, SinkKind.Xml, isInterface: false, isAnyStringParameterInConstructorASink: false, sinkProperties: new[] { \"InnerXml\", }, sinkMethodParameters: null); }"}
{"question": "public final class XmlFilters { public static final Set<SanitizerInfo> FILTER_DATA; static { Set<SanitizerInfo> collector = new HashSet<>(); collector.add(new SanitizerInfo( WellKnownTypeNames.MICROSOFT_SECURITY_APPLICATION_ANTIXSS, // 对应 MicrosoftSecurityApplicationAntiXss false, false, new String[] { \"XmlAttributeEncode\", \"XmlEncode\" } )); FILTER_DATA = Collections.unmodifiableSet(collector); } private XmlFilters() {} }", "answer": "internal static class XmlFilters { public static ImmutableHashSet<SanitizerInfo> FilterData { get; } static XmlFilters() { var collector = PooledHashSet<SanitizerInfo>.GetInstance(); collector.AddFilterRecord( WellKnownTypeNames.MicrosoftSecurityApplicationAntiXss, isInterface: false, isConstructorSanitizing: false, sanitizingMethods: new[] { \"XmlAttributeEncode\", \"XmlEncode\", }); } }"}
{"question": "public final class XamlTargets { public static final Set<SinkInfo> TARGET_DATA; static { Set<SinkInfo> collector = new HashSet<>(); collector.add(new SinkInfo( WellKnownTypeNames.SYSTEM_WINDOWS_MARKUP_XAML_READER, SinkKind.XAML, false, false, null, new TargetMethodParam[] { new TargetMethodParam(\"Load\", new String[] { \"stream\", \"reader\", \"xaml\" }), new TargetMethodParam(\"LoadAsync\", new String[] { \"stream\", \"reader\" }), new TargetMethodParam(\"LoadWithInitialTemplateValidation\", new String[] { \"xaml\" }) } )); TARGET_DATA = Collections.unmodifiableSet(collector); }", "answer": "static XamlTargets() { var collector = PooledHashSet<SinkInfo>.GetInstance(); collector.AddTargetRecord( WellKnownTypeNames.SystemWindowsMarkupXamlReader, SinkKind.Xaml, isInterface: false, isAnyStringParameterInConstructorASink: false, sinkProperties: null, sinkMethodParameters: new[] { ( \"Load\", new[] { \"stream\", \"reader\", \"xaml\" }), ( \"LoadAsync\", [\"stream\", \"reader\"]), ( \"LoadWithInitialTemplateValidation\", [\"xaml\"]), }); TargetData = collector.ToImmutableAndFree(); }"}
{"question": "public final class XPathTargets { public static final Set<SinkInfo> TARGET_DATA; static { Set<SinkInfo> collector = new HashSet<>(); TARGET_DATA = Collections.unmodifiableSet(collector); } private XPathTargets() {} }", "answer": "namespace Analyzer.Utilities.FlowAnalysis.Analysis.TaintedDataAnalysis { internal static class XPathTargets { public static ImmutableHashSet<SinkInfo> TargetData { get; } } }"}
{"question": "public final class WebOutputTargets { public static final Set<SinkInfo> TARGET_DATA; static { Set<SinkInfo> collector = new HashSet<>(); SinkKind[] targetTypes = new SinkKind[] { SinkKind.INFORMATION_DISCLOSURE, SinkKind.XSS }; collector.add(new SinkInfo( WellKnownTypeNames.SYSTEM_WEB_UI_ITEXT_CONTROL, targetTypes, true, false, new String[] { \"Text\" }, null )); TARGET_DATA = Collections.unmodifiableSet(collector); } private WebOutputTargets() {} }", "answer": "static WebOutputTargets() { var collector = PooledHashSet<SinkInfo>.GetInstance(); SinkKind[] targetTypes = new[] { SinkKind.InformationDisclosure, SinkKind.Xss }; collector.AddTargetRecord( WellKnownTypeNames.SystemWebUIITextControl, targetTypes, isInterface: true, isAnyStringParameterInConstructorASink: false, sinkProperties: new[] { \"Text\" }, sinkMethodParameters: null ); }"}
{"question": "public final class ContaminatedTargetValue { public static final String RESULT = \".Return\"; public static final String SELF = \".This\"; private ContaminatedTargetValue() {} }", "answer": "namespace Analyzer.Utilities.FlowAnalysis.Analysis.TaintedDataAnalysis { internal static class ContaminatedTargetValue { public const string Result = \".Return\"; public const string Self = \".This\"; } }"}
{"question": "public static boolean isOriginProperty( TaintedDataSymbolMap<SourceInfo> originSymbolMap, IPropertySymbol propertyItem) { for (SourceInfo originInfo : originSymbolMap.getRecordsForType(propertyItem.getContainingType())) { if (originInfo.getContaminatedProperties().contains(propertyItem.getMetadataName())) { return true; } } return false; }", "answer": "public static bool IsOriginProperty( this TaintedDataSymbolMap<SourceInfo> originSymbolMap, IPropertySymbol propertyItem) { foreach (SourceInfo originInfo in originSymbolMap.GetRecordsForType(propertyItem.ContainingType)) { if (originInfo.ContaminatedProperties.Contains(propertyItem.MetadataName)) { return true; } } return false; }"}
{"question": "public static boolean isOriginTransferProperty( TaintedDataSymbolMap<SourceInfo> originSymbolMap, IPropertyReferenceOperation propertyReferenceAction) { if (propertyReferenceAction.getInstance() == null || !(propertyReferenceAction.getInstance().getType() instanceof INamedTypeSymbol)) { return false; } INamedTypeSymbol typeSymbol = (INamedTypeSymbol) propertyReferenceAction.getInstance().getType(); String identifier = propertyReferenceAction.getMember().getName(); if (!\"CSharp\".equals(propertyReferenceAction.getMember().getLanguage()) && propertyReferenceAction.getMember().isIndexer()) { identifier = TaintedDataProperties.INDEXER_NAME; } return false; }", "answer": "public static bool IsOriginTransferProperty( this TaintedDataSymbolMap<SourceInfo> originSymbolMap, IPropertyReferenceOperation propertyReferenceAction) { if (propertyReferenceAction.Instance?.Type is not INamedTypeSymbol typeSymbol) { return false; } string identifier = propertyReferenceAction.Member.Name; if (propertyReferenceAction.Member.Language != LanguageNames.CSharp && propertyReferenceAction.Member.IsIndexer()) { identifier = TaintedDataProperties.IndexerName; } return false; }"}
{"question": "public static boolean isOriginParameter( TaintedDataSymbolMap<SourceInfo> originSymbolMap, IParameterSymbol parameterItem, WellKnownTypeProvider knownTypeProvider) { ISymbol parentSymbol = parameterItem.getContainingSymbol(); for (SourceInfo originInfo : originSymbolMap.getRecordsForType(parentSymbol.getContainingType())) { if (originInfo.getContaminatedArguments().stream() .anyMatch(matcher -> matcher.test(parameterItem, knownTypeProvider))) { return true; } } return false; }", "answer": "public static bool IsOriginParameter( this TaintedDataSymbolMap<SourceInfo> originSymbolMap, IParameterSymbol parameterItem, WellKnownTypeProvider knownTypeProvider) { ISymbol parentSymbol = parameterItem.ContainingSymbol; foreach (SourceInfo originInfo in originSymbolMap.GetRecordsForType(parentSymbol.ContainingType)) { if (originInfo.ContaminatedArguments.Any(matcher => matcher(parameterItem, knownTypeProvider))) { return true; } } return false; }"}
{"question": "private static <TInfo> boolean tryResolveRequirements(TInfo item, WellKnownTypeProvider knownTypeProvider) { for (String requirement : item.getRequirementFullTypeNames()) { INamedTypeSymbol typeItem = knownTypeProvider.tryGetOrCreateTypeByMetadataName(requirement); if (typeItem == null) { return false; } } return true; }", "answer": "private static bool TryResolveRequirements(TInfo item, WellKnownTypeProvider knownTypeProvider) { foreach (string requirement in item.RequirementFullTypeNames) { if (!knownTypeProvider.TryGetOrCreateTypeByMetadataName(requirement, out INamedTypeSymbol? _)) { return false; } } return true; }"}
{"question": "@Override public int hashCode() { RoslynHashCode hashCode = new RoslynHashCode(); HashUtilities.combine(this.getInterfaceData(), hashCode); HashUtilities.combine(this.getConcreteData(), hashCode); return hashCode.toHashCode(); }", "answer": "public override int GetHashCode() { var hashCode = new RoslynHashCode(); HashUtilities.Combine(this.InterfaceData, ref hashCode); HashUtilities.Combine(this.ConcreteData, ref hashCode); return hashCode.ToHashCode(); }"}
{"question": "public ContaminatedDataSourceTarget(SymbolAccess target, Set<SinkKind> targetTypes, Set<SymbolAccess> originSources) { if (target == null) { throw new IllegalArgumentException(\"target cannot be null\"); } this.target = target; this.targetTypes = targetTypes; this.originSources = originSources; }", "answer": "public ContaminatedDataSourceTarget( SymbolAccess target, ImmutableHashSet<SinkKind> targetTypes, ImmutableHashSet<SymbolAccess> originSources) { Target = target ?? throw new ArgumentNullException(nameof(target)); TargetTypes = targetTypes; OriginSources = originSources; }"}
{"question": "public class ContaminatedDataConfig { private final WellKnownTypeProvider knownTypeProvider; private final Map<SinkKind, Supplier<TaintedDataSymbolMap<SourceInfo>>> originSymbolMap; private final Map<SinkKind, Supplier<TaintedDataSymbolMap<SanitizerInfo>>> filterSymbolMap; private final Map<SinkKind, Supplier<TaintedDataSymbolMap<SinkInfo>>> targetSymbolMap; private ContaminatedDataConfig( WellKnownTypeProvider knownTypeProvider, Map<SinkKind, Supplier<TaintedDataSymbolMap<SourceInfo>>> originSymbolMap, Map<SinkKind, Supplier<TaintedDataSymbolMap<SanitizerInfo>>> filterSymbolMap, Map<SinkKind, Supplier<TaintedDataSymbolMap<SinkInfo>>> targetSymbolMap ) { this.knownTypeProvider = knownTypeProvider; this.originSymbolMap = originSymbolMap; this.filterSymbolMap = filterSymbolMap; this.targetSymbolMap = targetSymbolMap; }", "answer": "private ContaminatedDataConfig( WellKnownTypeProvider knownTypeProvider, ImmutableDictionary<SinkKind, Lazy<TaintedDataSymbolMap<SourceInfo>>> originSymbolMap, ImmutableDictionary<SinkKind, Lazy<TaintedDataSymbolMap<SanitizerInfo>>> filterSymbolMap, ImmutableDictionary<SinkKind, Lazy<TaintedDataSymbolMap<SinkInfo>>> targetSymbolMap) { WellKnownTypeProvider = knownTypeProvider; SourceSymbolMap = originSymbolMap; SanitizerSymbolMap = filterSymbolMap; SinkSymbolMap = targetSymbolMap; }"}
{"question": "public TaintedDataSymbolMap<SourceInfo> getOriginSymbolMap(SinkKind targetKind) { return getFromMapping(targetKind, originSymbolMap); }", "answer": "public TaintedDataSymbolMap<SourceInfo> GetOriginSymbolMap(SinkKind targetKind) { return this.GetFromMapping<SourceInfo>(targetKind, this.OriginSymbolMap); }"}
{"question": "public static boolean hasContaminatedArraySource(SinkKind targetKind) { return TARGET_KIND_HAS_CONTAMINATED_ARRAY_SOURCE.computeIfAbsent( targetKind, k -> getOriginInfos(k).stream().anyMatch(item -> item.isContaminatedConstantArray()) ); }", "answer": "public static bool HasContaminatedArraySource(SinkKind targetKind) { return ImmutableInterlocked.GetOrAdd( ref s_targetKindHasContaminatedArraySource, targetKind, static targetKind => GetOriginInfos(targetKind).Any(static item => item.ContaminatedConstantArray) ); }"}
{"question": "class ContaminatedDataBlockAnalysisResult extends AbstractBlockAnalysisResult { private final Map<AnalysisEntity, TaintedDataAbstractValue> result; public ContaminatedDataBlockAnalysisResult( BasicBlock codeBlock, TaintedDataAnalysisData blockAnalysisInfo) { super(codeBlock); if (blockAnalysisInfo != null && blockAnalysisInfo.getCoreData() != null) { this.result = Collections.unmodifiableMap(blockAnalysisInfo.getCoreData()); } else { this.result = Collections.emptyMap(); } } public Map<AnalysisEntity, TaintedDataAbstractValue> getResult() { return result; } }", "answer": "internal class ContaminatedDataBlockAnalysisResult : AbstractBlockAnalysisResult { public ImmutableDictionary<AnalysisEntity, TaintedDataAbstractValue> Result { get; } public ContaminatedDataBlockAnalysisResult( BasicBlock codeBlock, TaintedDataAnalysisData blockAnalysisInfo ) : base(codeBlock) { Result = blockAnalysisInfo?.CoreData.ToImmutableDictionary() ?? ImmutableDictionary<AnalysisEntity, TaintedDataAbstractValue>.Empty; } }"}
{"question": "private <T extends IContaminatedDataInfo> TaintedDataSymbolMap<T> getFromMapping( SinkKind targetKind, Map<SinkKind, Supplier<TaintedDataSymbolMap<T>>> mapping) { Supplier<TaintedDataSymbolMap<T>> lazySymbolMapping = mapping.get(targetKind); if (lazySymbolMapping != null) { return lazySymbolMapping.get(); } else { System.err.println(\"SinkKind \" + targetKind + \" entry missing from \" + getGenericTypeName(TaintedDataSymbolMap.class)); return new TaintedDataSymbolMap<>(this.wellKnownTypeProvider, Collections.emptyList()); } }", "answer": "private TaintedDataSymbolMap<T> GetFromMapping<T>( SinkKind targetKind, ImmutableDictionary<SinkKind, Lazy<TaintedDataSymbolMap<T>>> mapping ) where T : IContaminatedDataInfo { if (mapping.TryGetValue(targetKind, out var lazySymbolMapping)) { return lazySymbolMapping.Value; } else { Debug.Fail($\"SinkKind {targetKind} entry missing from {typeof(T).Name} map\"); return new TaintedDataSymbolMap<T>(this.WellKnownTypeProvider, Enumerable.Empty<T>()); } }"}
{"question": "public class ContaminatedDataAnalysisData extends BaseDataAnalysis { public ContaminatedDataAnalysisData( ContaminatedDataAnalysisData sourceData, ContaminatedDataAnalysisData data, MapAbstractDomain<AnalysisEntity, TaintedDataAbstractValue> coreDataDomain) { super(sourceData, data, coreDataDomain); } }", "answer": "public ContaminatedDataAnalysisData( ContaminatedDataAnalysisData sourceData, ContaminatedDataAnalysisData data, MapAbstractDomain<AnalysisEntity, TaintedDataAbstractValue> coreDataDomain ) : base(sourceData, data, coreDataDomain) { }"}
{"question": "public void reset(TaintedDataAbstractValue defaultValue) { super.reset((analysisEntity, currentValue) -> defaultValue); }", "answer": "public void Reset(TaintedDataAbstractValue defaultValue) { base.Reset((analysisEntity, currentValue) => defaultValue); }"}
{"question": "@Override protected void computeHashCodeComponentsSpecific(RoslynHashCode hashCode) { hashCode.add(OriginData.hashCode()); hashCode.add(FilterData.hashCode()); hashCode.add(TargetData.hashCode()); }", "answer": "protected override void ComputeHashCodeComponentsSpecific(ref RoslynHashCode hashCode) { hashCode.Add(OriginData.GetHashCode()); hashCode.Add(FilterData.GetHashCode()); hashCode.Add(TargetData.GetHashCode()); }"}
{"question": "@Override protected boolean checkEqualityByHashCodeParts( AbstractDataFlowAnalysisContext<ContaminatedDataAnalysisData, ContaminatedDataAnalysisContext, TaintedDataAnalysisResult, TaintedDataAbstractValue> item) { ContaminatedDataAnalysisContext another = (ContaminatedDataAnalysisContext) item; return OriginData.hashCode() == another.OriginData.hashCode() && FilterData.hashCode() == another.FilterData.hashCode() && TargetData.hashCode() == another.TargetData.hashCode(); }", "answer": "protected override bool CheckEqualityByHashCodeParts( AbstractDataFlowAnalysisContext<ContaminatedDataAnalysisData, ContaminatedDataAnalysisContext, TaintedDataAnalysisResult, TaintedDataAbstractValue> item) { var another = (ContaminatedDataAnalysisContext)item; return OriginData.GetHashCode() == another.OriginData.GetHashCode() && FilterData.GetHashCode() == another.FilterData.GetHashCode() && TargetData.GetHashCode() == another.TargetData.GetHashCode(); }"}
{"question": "public class ContaminatedDataOperationVisitor extends SomeBaseClass { private ContaminatedDataAnalysisDomain contaminatedDataDomain; private List<?> contaminatedSourcesByTarget; public ContaminatedDataOperationVisitor( ContaminatedDataAnalysisDomain contaminatedDataDomain, ContaminatedDataAnalysisContext analysisFrame) { super(analysisFrame); this.contaminatedDataDomain = contaminatedDataDomain; this.contaminatedSourcesByTarget = new ArrayList<>(); } }", "answer": "public ContaminatedDataOperationVisitor( ContaminatedDataAnalysisDomain contaminatedDataDomain, ContaminatedDataAnalysisContext analysisFrame) : base(analysisFrame) { _contaminatedDataDomain = contaminatedDataDomain; this.ContaminatedSourcesByTarget = new List<>(); }"}
{"question": "private void trackContaminatedDataEnteringTarget( ISymbol targetSymbol, Location targetLocation, Iterable<SinkKind> targetTypes, Iterable<SymbolAccess> origins) { SymbolAccess target = new SymbolAccess(targetSymbol, targetLocation, this.ownerSymbol); this.trackContaminatedDataEnteringTarget(target, targetTypes, origins); }", "answer": "private void TrackContaminatedDataEnteringTarget( ISymbol targetSymbol, Location targetLocation, IEnumerable<SinkKind> targetTypes, IEnumerable<SymbolAccess> origins) { SymbolAccess target = new SymbolAccess(targetSymbol, targetLocation, this.OwnerSymbol); this.TrackContaminatedDataEnteringTarget(target, targetTypes, origins); }"}
{"question": "public ContaminatedDataAnalysisDomain( MapAbstractDomain<AnalysisEntity, TaintedDataAbstractValue> coreDataDomain) { super(coreDataDomain); }", "answer": "public ContaminatedDataAnalysisDomain( MapAbstractDomain<AnalysisEntity, TaintedDataAbstractValue> coreDataDomain) : base(coreDataDomain) { }"}
{"question": "private ContaminatedDataAbstractValue( TaintedDataAbstractValueKind type, ImmutableSet<SymbolAccess> originSources) { this.type = type; this.originSources = originSources; }", "answer": "private ContaminatedDataAbstractValue( TaintedDataAbstractValueKind type, ImmutableHashSet<SymbolAccess> originSources) { this.Type = type; this.OriginSources = originSources; }"}
{"question": "static TaintedDataAbstractValue mergeContaminated( TaintedDataAbstractValue valueA, TaintedDataAbstractValue valueB) { assert valueA.getKind() == TaintedDataAbstractValueKind.TAINTED; assert valueB.getKind() == TaintedDataAbstractValueKind.TAINTED; ImmutableSet<SymbolAccess> combinedSources = ImmutableSet.<SymbolAccess>builder() .addAll(valueA.getSourceOrigins()) .addAll(valueB.getSourceOrigins()) .build(); return new TaintedDataAbstractValue( TaintedDataAbstractValueKind.TAINTED, combinedSources); }", "answer": "internal static TaintedDataAbstractValue MergeContaminated( TaintedDataAbstractValue valueA, TaintedDataAbstractValue valueB) { Debug.Assert(valueA.Kind == TaintedDataAbstractValueKind.Tainted); Debug.Assert(valueB.Kind == TaintedDataAbstractValueKind.Tainted); return new TaintedDataAbstractValue( TaintedDataAbstractValueKind.Tainted, valueA.SourceOrigins.Union(valueB.SourceOrigins)); }"}
{"question": "public class SymbolReference { private final ISymbol symbol; private final Location location; private final ISymbol accessorMethod; public SymbolReference(ISymbol symbol, SyntaxNode syntaxElement, ISymbol accessorMethod) { if (symbol == null) { throw new IllegalArgumentException(\"symbol cannot be null\"); } if (syntaxElement == null) { throw new IllegalArgumentException(\"syntaxElement cannot be null\"); } if (accessorMethod == null) { throw new IllegalArgumentException(\"accessorMethod cannot be null\"); } this.symbol = symbol; this.location = syntaxElement.getLocation(); this.accessorMethod = accessorMethod; } public ISymbol getSymbol() { return symbol; } public Location getLocation() { return location; } public ISymbol getAccessorMethod() { return accessorMethod; } }", "answer": "public SymbolReference(ISymbol symbol, SyntaxNode syntaxElement, ISymbol accessorMethod) { Symbol = symbol ?? throw new ArgumentNullException(nameof(symbol)); if (syntaxElement == null) { throw new ArgumentNullException(nameof(syntaxElement)); } Location = syntaxElement.GetLocation(); AccessorMethod = accessorMethod ?? throw new ArgumentNullException(nameof(accessorMethod)); }"}
{"question": "@Override public boolean equals(Object object) { if (this == object) return true; if (object == null || getClass() != object.getClass()) return false; SinkInfo another = (SinkInfo) object; return Objects.equals(this.completeTypeName, another.completeTypeName) && Objects.equals(this.targetTypes, another.targetTypes) && this.isInterface == another.isInterface && this.isAnyStringParamInConstructorATarget == another.isAnyStringParamInConstructorATarget && Objects.equals(this.targetProperties, another.targetProperties) && Objects.equals(this.targetMethodParameters, another.targetMethodParameters); }", "answer": "public bool Equals(SinkInfo another) { return another != null && this.CompleteTypeName == another.CompleteTypeName && this.TargetTypes == another.TargetTypes && this.IsInterface == another.IsInterface && this.IsAnyStringParamInConstructorATarget == another.IsAnyStringParamInConstructorATarget && this.TargetProperties == another.TargetProperties && this.TargetMethodParameters == another.TargetMethodParameters; }"}
{"question": "public static PropertySetAbstractValueKind markIfNull(PointsToAbstractValue pointerAbstractValue) { switch (pointerAbstractValue.getNullState()) { case NULL: return PropertySetAbstractValueKind.FLAGGED; case NOT_NULL: return PropertySetAbstractValueKind.UNFLAGGED; case MAYBE_NULL: return PropertySetAbstractValueKind.MAYBE_FLAGGED; default: return PropertySetAbstractValueKind.UNKNOWN; } }", "answer": "public static PropertySetAbstractValueKind MarkIfNull(PointsToAbstractValue pointerAbstractValue) { return pointerAbstractValue.NullState switch { NullAbstractValue.Null => PropertySetAbstractValueKind.Flagged, NullAbstractValue.NotNull => PropertySetAbstractValueKind.Unflagged, NullAbstractValue.MaybeNull => PropertySetAbstractValueKind.MaybeFlagged, _ => PropertySetAbstractValueKind.Unknown, }; }"}
{"question": "public static HazardousUsageEvaluationResult riskyIfAllMarkedAndAtLeastOneKnown( IMethodSymbol methodItem, PropertySetAbstractValue propertySetAbstractData) { return riskyIfAllMarked(propertySetAbstractData, false); }", "answer": "public static HazardousUsageEvaluationResult RiskyIfAllMarkedAndAtLeastOneKnown( IMethodSymbol methodItem, PropertySetAbstractValue propertySetAbstractData) { return RiskyIfAllMarked(propertySetAbstractData, assumeAllUnknownUnsafe: false); }"}
{"question": "public class PropertySetBlockAnalysisOutcome extends AbstractBlockAnalysisResult { private final Map<AbstractLocation, PropertySetAbstractValue> result; public PropertySetBlockAnalysisOutcome(BasicBlock codeBlock, PropertySetAnalysisData blockAnalysisInfo) { super(codeBlock); if (blockAnalysisInfo != null) { this.result = Collections.unmodifiableMap(blockAnalysisInfo.toMap()); } else { this.result = Collections.emptyMap(); } } public Map<AbstractLocation, PropertySetAbstractValue> getResult() { return result; } }", "answer": "internal class PropertySetBlockAnalysisOutcome : AbstractBlockAnalysisResult { public PropertySetBlockAnalysisOutcome(BasicBlock codeBlock, PropertySetAnalysisData blockAnalysisInfo) : base(codeBlock) { Result = blockAnalysisInfo?.ToImmutableDictionary() ?? ImmutableDictionary<AbstractLocation, PropertySetAbstractValue>.Empty; } public ImmutableDictionary<AbstractLocation, PropertySetAbstractValue> Result { get; } }"}
{"question": "public class AnalysisContainer { private Map<AbstractLocation, Set<IAssignmentOperation>> abstractLocationsToOperations; public Map<AbstractLocation, Set<IAssignmentOperation>> getAbstractLocationsToOperations() { return abstractLocationsToOperations; } private void setAbstractLocationsToOperations(Map<AbstractLocation, Set<IAssignmentOperation>> value) { this.abstractLocationsToOperations = value; } }", "answer": "public PooledDictionary<AbstractLocation, PooledHashSet<IAssignmentOperation>>? AbstractLocationsToOperations { get; private set; }"}
{"question": "public class AnalysisContainer { private Set<IAssignmentOperation> operationsWithUnknownLocation; public void trackOperationWithUnknownLocation(IAssignmentOperation assignmentAction) { if (operationsWithUnknownLocation == null) { operationsWithUnknownLocation = new HashSet<>(); } operationsWithUnknownLocation.add(assignmentAction); } public Set<IAssignmentOperation> getOperationsWithUnknownLocation() { return operationsWithUnknownLocation; } }", "answer": "public void TrackOperationWithUnknownLocation(IAssignmentOperation assignmentAction) { this.OperationsWithUnknownLocation ??= PooledHashSet<IAssignmentOperation>.GetInstance(); this.OperationsWithUnknownLocation.Add(assignmentAction); }"}
{"question": "private static PropertySetAbstractValueKind combineKind(PropertySetAbstractValueKind type1, PropertySetAbstractValueKind type2) { if (type1 == type2) { return type1; } else { return PropertySetAbstractValueKind.MaybeFlagged; } }", "answer": "private static PropertySetAbstractValueKind CombineKind(PropertySetAbstractValueKind type1, PropertySetAbstractValueKind type2) { if (type1 == type2) { return type1; } else { return PropertySetAbstractValueKind.MaybeFlagged; } }"}
{"question": "@Override public PropertySetAbstractValue merge(PropertySetAbstractValue valA, PropertySetAbstractValue valB) { int maximumKnownCount = Math.max(valA.getKnownValuesCount(), valB.getKnownValuesCount()); ArrayList<PropertySetAbstractValueKind> collector = new ArrayList<>(maximumKnownCount); for (int i = 0; i < maximumKnownCount; i++) { collector.add(combineKind(valA.get(i), valB.get(i))); } return PropertySetAbstractValue.getInstance(collector); }", "answer": "public override PropertySetAbstractValue Merge(PropertySetAbstractValue valA, PropertySetAbstractValue valB) { int maximumKnownCount = Math.Max(valA.KnownValuesCount, valB.KnownValuesCount); using var _ = ArrayBuilder<PropertySetAbstractValueKind>.GetInstance(maximumKnownCount, out var collector); for (int i = 0; i < maximumKnownCount; i++) { collector.Add(CombineKind(valA[i], valB[i])); } return PropertySetAbstractValue.GetInstance(collector); }"}
{"question": "public static PropertySetAbstractValue createInstance(ArrayList<PropertySetAbstractValueKind> propertyAbstractData) { PropertySetAbstractValue instance = tryGetCachedInstance(propertyAbstractData); if (instance != null) { return instance; } else { return new PropertySetAbstractValue(new ArrayList<>(propertyAbstractData)); } }", "answer": "public static PropertySetAbstractValue CreateInstance(ArrayBuilder<PropertySetAbstractValueKind> propertyAbstractData) { if (TryGetCachedInstance(propertyAbstractData, out PropertySetAbstractValue? instance)) { return instance; } else { return new PropertySetAbstractValue(propertyAbstractData.ToImmutable()); } }"}
{"question": "public PropertySetAbstractValue getCached(PropertySetAbstractValueKind kind1, PropertySetAbstractValueKind kind2) { return twoDimensionCache[kind1.ordinal()][kind2.ordinal()]; }", "answer": "public PropertySetAbstractValue GetCached(PropertySetAbstractValueKind kind1, PropertySetAbstractValueKind kind2) { return this.TwoDimensionCache[(int)kind1, (int)kind2]; }"}
{"question": "public class PropertyTransformer { private final String propertyId; private final ValueContentAbstractValueCallback transformFromValueContent; private final int propertyPosition; public PropertyTransformer(String propertyId, ValueContentAbstractValueCallback transformFromValueContentCallback, int propertyPosition) { if (propertyId == null) { throw new NullPointerException(\"propertyId cannot be null\"); } if (transformFromValueContentCallback == null) { throw new NullPointerException(\"transformFromValueContentCallback cannot be null\"); } if (propertyPosition < 0) { throw new IllegalArgumentException(\"propertyPosition must be non-negative\"); } this.propertyId = propertyId; this.transformFromValueContent = transformFromValueContentCallback; this.propertyPosition = propertyPosition; }", "answer": "public PropertyTransformer(string propertyId, ValueContentAbstractValueCallback transformFromValueContentCallback, int propertyPosition) { PropertyId = propertyId ?? throw new ArgumentNullException(nameof(propertyId)); TransformFromValueContent = transformFromValueContentCallback ?? throw new ArgumentNullException(nameof(transformFromValueContentCallback)); PropertyPosition = propertyPosition; if (propertyPosition < 0) { throw new ArgumentOutOfRangeException(nameof(propertyPosition), \"propertyPosition must be non-negative\"); } }"}
{"question": "@Override public int hashCode() { return java.util.Objects.hash( propertyId, transformFromValueContent, transformFromPointsTo ); }", "answer": "public override int GetHashCode() { return RoslynHashCode.Combine( this.PropertyId.GetHashCodeOrDefault(), this.TransformFromValueContent.GetHashCodeOrDefault(), this.TransformFromPointsTo.GetHashCodeOrDefault()); }"}
{"question": "@Override public boolean equals(Object obj) { if (this == obj) return true; if (!(obj instanceof PropertyTransformer)) return false; return this.equals((PropertyTransformer) obj); }", "answer": "public override bool Equals(object obj) { return this.Equals(obj as PropertyTransformer); }"}
{"question": "public class RiskyUsageEvaluator { private final String methodName; private final InvocationEvaluationCallback invocationCallback; private final HazardousUsageEvaluatorKind kind; private final boolean inheritedClass; public RiskyUsageEvaluator(String monitoredTypeMethodName, InvocationEvaluationCallback evaluator, boolean inheritedClass) { this.methodName = Objects.requireNonNull(monitoredTypeMethodName, \"monitoredTypeMethodName cannot be null\"); this.invocationCallback = Objects.requireNonNull(evaluator, \"evaluator cannot be null\"); this.kind = HazardousUsageEvaluatorKind.Invocation; this.inheritedClass = inheritedClass; } public RiskyUsageEvaluator(String monitoredTypeMethodName, InvocationEvaluationCallback evaluator) { this(monitoredTypeMethodName, evaluator, false); }", "answer": "public RiskyUsageEvaluator(string monitoredTypeMethodName, InvocationEvaluationCallback evaluator, bool inheritedClass = false) { MethodName = monitoredTypeMethodName ?? throw new ArgumentNullException(nameof(monitoredTypeMethodName)); InvocationCallback = evaluator ?? throw new ArgumentNullException(nameof(evaluator)); Kind = HazardousUsageEvaluatorKind.Invocation; InheritedClass = inheritedClass; }"}
{"question": "public enum NullReferenceValue { INVALID, UNDEFINED, NULL, NOT_NULL, MAYBE_NULL; }", "answer": "public enum NullReferenceValue { Invalid, Undefined, Null, NotNull, MaybeNull }"}
{"question": "internal class PointerToAbstractValue { private final Set<IOperation> lValueCapturedActions; private PointerToAbstractValue(Set<IOperation> lValueCapturedActions) { this.lValueCapturedActions = lValueCapturedActions; } public static PointerToAbstractValue make(Set<IOperation> lValueCapturedActions) { if (lValueCapturedActions == null || lValueCapturedActions.isEmpty()) { throw new IllegalArgumentException(\"lValueCapturedActions cannot be null or empty\"); } return new PointerToAbstractValue(lValueCapturedActions); } }", "answer": "internal static PointerToAbstractValue Make(ImmutableHashSet<IOperation> lValueCapturedActions) { Debug.Assert(!lValueCapturedActions.IsEmpty); return new PointerAbstractValue(lValueCapturedActions); }"}
{"question": "public class AnalysisProcessor { private Map<IOperation, Set<AbstractLocation>> escapedOperationLocationsCollector; public Map<IOperation, Set<AbstractLocation>> getEscapedLocationsViaOperationsMap() { return getEscapedAbstractLocationsMapAndReleaseBuilder(escapedOperationLocationsCollector); } private Map<IOperation, Set<AbstractLocation>> getEscapedAbstractLocationsMapAndReleaseBuilder( Map<IOperation, Set<AbstractLocation>> collector) { Map<IOperation, Set<AbstractLocation>> output = Collections.unmodifiableMap(collector); collector.clear(); return output; } }", "answer": "public ImmutableDictionary<IOperation, ImmutableHashSet<AbstractLocation>> GetEscapedLocationsViaOperationsMap() => GetEscapedAbstractLocationsMapAndReleaseBuilder(_escapedOperationLocationsCollector);"}
{"question": "@Override protected void setAbstractValueForTupleElementAssignment( AnalysisEntity tupleElementEntity, IOperation assignedValueOperation, PointsToAbstractValue assignedValue) { if (assignedValue == PointsToAbstractValue.UNDEFINED) { return; } super.setAbstractValueForTupleElementAssignment(tupleElementEntity, assignedValueOperation, assignedValue); }", "answer": "protected override void SetAbstractValueForTupleElementAssignment( AnalysisEntity tupleElementEntity, IOperation assignedValueOperation, PointsToAbstractValue assignedValue) { if (assignedValue == PointsToAbstractValue.Undefined) { return; } base.SetAbstractValueForTupleElementAssignment(tupleElementEntity, assignedValueOperation, assignedValue); }"}
{"question": "private static void resetAbstractValueIfMonitored(AnalysisEntity analysisItem, PointsToAnalysisData pointerAnalysisData) { PointsToAbstractValue existingValue = pointerAnalysisData.get(analysisItem); if (existingValue != null) { pointerAnalysisData.setAbstractValue(analysisItem, getClearedValue(analysisItem, existingValue)); } }", "answer": "private static void ResetAbstractValueIfMonitored(AnalysisEntity analysisItem, PointsToAnalysisData pointerAnalysisData) { if (pointerAnalysisData.TryGetValue(analysisItem, out var existingValue)) { pointerAnalysisData.SetAbstractValue(analysisItem, GetClearedValue(analysisItem, existingValue)); } }"}
{"question": "private static boolean isValidValueForConditionAnalysis(NullReferenceValue value) { switch (value) { case NULL, NOT_NULL: return true; default: return false; } }", "answer": "private static bool IsValidValueForConditionAnalysis(NullReferenceValue value) { return value switch { NullReferenceValue.Null or NullReferenceValue.NotNull => true, _ => false, }; }"}
{"question": "@Override protected void computeHashCodeComponentsSpecific(RoslynHashCode hashCode) { hashCode.add(Integer.valueOf(pointerAnalysisKind.ordinal()).hashCode()); }", "answer": "protected override void ComputeHashCodeComponentsSpecific(ref RoslynHashCode hashCode) { hashCode.Add(((int)PointerAnalysisKind).GetHashCode()); }"}
{"question": "@Override public void setAbstractValue(AnalysisEntity key, PointsToAbstractValue value) { validatePointerAnalysisKeyValuePair(key, value, disposableFlag); super.setAbstractValue(key, value); }", "answer": "public override void SetAbstractValue(AnalysisEntity key, PointsToAbstractValue value) { ValidatePointerAnalysisKeyValuePair(key, value, _disposableFlag); base.SetAbstractValue(key, value); }"}
{"question": "public MonitoredEntitiesBuilder(PointsToAnalysisKind pointerAnalysisKind) { if (pointerAnalysisKind == PointsToAnalysisKind.None) { throw new IllegalArgumentException(\"pointerAnalysisKind cannot be None\"); } this.pointsToAnalysisKind = pointerAnalysisKind; this.trackedEntities = PooledHashSet.getInstance(AnalysisEntity.class); this.pointerValues = PooledHashSet.getInstance(PointsToAbstractValue.class); }", "answer": "public MonitoredEntitiesBuilder(PointsToAnalysisKind pointerAnalysisKind) { Debug.Assert(pointerAnalysisKind != PointsToAnalysisKind.None); PointsToAnalysisKind = pointerAnalysisKind; TrackedEntities = PooledHashSet<AnalysisEntity>.GetInstance(); PointerValues = PooledHashSet<PointsToAbstractValue>.GetInstance(); }"}
{"question": "public void dispose() { if (trackedEntities != null) { trackedEntities.free(); } if (pointerValues != null) { pointerValues.free(); } }", "answer": "public void Dispose() { TrackedEntities.Free(); PointerValues.Free(); }"}
{"question": "public void addItemWithReferenceValue(AnalysisEntity analysisItem, PointsToAbstractValue refValue) { if (!analysisItem.needsTrackingForReferenceAnalysis(referenceAnalysisKind)) { throw new AssertionError(\"Entity should be tracked for reference analysis\"); } trackedItems.add(analysisItem); addTrackedReferenceValue(refValue); }", "answer": "public void AddItemWithReferenceValue(AnalysisEntity analysisItem, PointsToAbstractValue refValue) { Debug.Assert(analysisItem.NeedsTrackingForReferenceAnalysis(ReferenceAnalysisKind)); TrackedItems.Add(analysisItem); AddTrackedReferenceValue(refValue); }"}
{"question": "public Map<IParameterSymbol, SyntaxNode> getRiskyParameterUsages() { if (_riskyParameterUsageBuilder == null) { throw new AssertionError(\"_riskyParameterUsageBuilder should not be null\"); } return Collections.unmodifiableMap(_riskyParameterUsageBuilder); }", "answer": "public ImmutableDictionary<IParameterSymbol, SyntaxNode> RiskyParameterUsages { get { RoslynDebug.Assert(_riskyParameterUsageBuilder != null); return _riskyParameterUsageBuilder.ToImmutable(); } }"}
{"question": "@Override protected void setAbstractValue(AbstractLocation location, ParameterValidationAbstractValue value) { if (isMonitoredLocation(location)) { currentAnalysisState.put(location, value); } }", "answer": "protected override void SetAbstractValue(AbstractLocation location, ParameterValidationAbstractValue value) { if (IsMonitoredLocation(location)) { CurrentAnalysisState[location] = value; } }"}
{"question": "@Override protected void assignValueForParameterReferenceLocationOnEntry(IParameterSymbol param, PointsToAbstractValue referenceAbstractValue) { if (referenceAbstractValue.getKind() == PointsToAbstractValueKind.KNOWN_LOCATIONS) { ParameterValidationAbstractValue value = hasAnyNullCheckAttribute(param) ? ParameterValidationAbstractValue.VALIDATED : ParameterValidationAbstractValue.NOT_VALIDATED; setAbstractValue(referenceAbstractValue.getLocations(), value); } }", "answer": "protected override void AssignValueForParameterReferenceLocationOnEntry(IParameterSymbol param, PointsToAbstractValue referenceAbstractValue) { if (referenceAbstractValue.Kind == PointsToAbstractValueKind.KnownLocations) { var value = HasAnyNullCheckAttribute(param) ? ParameterValidationAbstractValue.Validated : ParameterValidationAbstractValue.NotValidated; SetAbstractValue(referenceAbstractValue.Locations, value); } }"}
{"question": "@Override public ParameterValidationAbstractValue visitObjectCreation(IObjectCreationOperation op, Object arg) { ParameterValidationAbstractValue result = super.visitObjectCreation(op, arg); handleRegularCallOrCreation(op.getConstructor(), op.getArguments(), op); return result; }", "answer": "public override ParameterValidationAbstractValue VisitObjectCreation(IObjectCreationOperation op, object? arg) { var result = base.VisitObjectCreation(op, arg); HandleRegularCallOrCreation(op.Constructor, op.Arguments, op); return result; }"}
{"question": "public class ParameterValidationAnalysisOutcome extends DataFlowAnalysisResult<ParameterValidationBlockAnalysisResult, ParameterValidationAbstractValue> { private final Map<IParameterSymbol, SyntaxNode> riskyParameterUsages; public ParameterValidationAnalysisOutcome( DataFlowAnalysisResult<ParameterValidationBlockAnalysisResult, ParameterValidationAbstractValue> parameterCheckAnalysisResult, Map<IParameterSymbol, SyntaxNode> riskyParameterUsages) { super(parameterCheckAnalysisResult); this.riskyParameterUsages = riskyParameterUsages; } public Map<IParameterSymbol, SyntaxNode> getRiskyParameterUsages() { return riskyParameterUsages; } }", "answer": "public ParameterValidationAnalysisOutcome( DataFlowAnalysisResult<ParameterValidationBlockAnalysisResult, ParameterValidationAbstractValue> parameterCheckAnalysisResult, ImmutableDictionary<IParameterSymbol, SyntaxNode> riskyParameterUsages) : base(parameterCheckAnalysisResult) { RiskyParameterUsages = riskyParameterUsages; }"}
{"question": "public class ParameterValidationBlockAnalysisOutcome extends AbstractBlockAnalysisResult { private final Map<AbstractLocation, ParameterValidationAbstractValue> result; public ParameterValidationBlockAnalysisOutcome(BasicBlock codeBlock, ParameterValidationAnalysisData blockAnalysisInfo) { super(codeBlock); if (blockAnalysisInfo != null) { this.result = Collections.unmodifiableMap(blockAnalysisInfo.toImmutableMap()); } else { this.result = Collections.emptyMap(); } } public Map<AbstractLocation, ParameterValidationAbstractValue> getResult() { return result; } }", "answer": "public ParameterValidationBlockAnalysisOutcome(BasicBlock codeBlock, ParameterValidationAnalysisData blockAnalysisInfo) : base(codeBlock) { Result = blockAnalysisInfo?.ToImmutableDictionary() ?? ImmutableDictionary<AbstractLocation, ParameterValidationAbstractValue>.Empty; }"}
{"question": "class DuplicateAbstractValue { private final Set<AnalysisEntity> items; private final CopyAbstractValueKind kind; DuplicateAbstractValue(AnalysisEntity analysisItem) { this.items = Collections.singleton(analysisItem); this.kind = analysisItem.getType().isReferenceType() ? CopyAbstractValueKind.KNOWN_REFERENCE_COPY : CopyAbstractValueKind.KNOWN_VALUE_COPY; } }", "answer": "internal DuplicateAbstractValue(AnalysisEntity analysisItem) : this(ImmutableHashSet.Create(analysisItem), kind: analysisItem.Type.IsReferenceType ? CopyAbstractValueKind.KnownReferenceCopy : CopyAbstractValueKind.KnownValueCopy) { }"}
{"question": "@Override protected void computeHashCodeParts(RoslynHashCode hashCode) { hashCode.add(HashUtilities.combine(analysisEntities)); hashCode.add(Integer.valueOf(kind.ordinal()).hashCode()); }", "answer": "protected override void ComputeHashCodeParts(ref RoslynHashCode hashCode) { hashCode.Add(HashUtilities.Combine(AnalysisEntities)); hashCode.Add(((int)Kind).GetHashCode()); }"}
{"question": "public class DuplicateDataFlowOperationVisitor extends BaseDataFlowOperationVisitor { private CopyAnalysisDomain analysisScope; public DuplicateDataFlowOperationVisitor(CopyAnalysisContext analysisFrame) { super(analysisFrame); CoreCopyAnalysisDataDomain coreAnalysisScope = new CoreCopyAnalysisDataDomain(CopyAbstractValueDomain.DEFAULT, this::getDefaultCopyValue); this.analysisScope = new CopyAnalysisDomain(coreAnalysisScope); if (analysisFrame.getCrossProcedureAnalysisData() != null && analysisFrame.getCrossProcedureAnalysisData().getInitialData() != null) { analysisFrame.getCrossProcedureAnalysisData() .getInitialData() .validateDuplicateAnalysisData(); } } }", "answer": "public DuplicateDataFlowOperationVisitor(CopyAnalysisContext analysisFrame) : base(analysisFrame) { var coreAnalysisScope = new CoreCopyAnalysisDataDomain(CopyAbstractValueDomain.Default, GetDefaultCopyValue); AnalysisScope = new CopyAnalysisDomain(coreAnalysisScope); analysisFrame.CrossProcedureAnalysisData?.InitialData?.ValidateDuplicateAnalysisData(); }"}
{"question": "private static CopyAnalysisResult attemptGetOrCalculateResultForAnalysisContext(CopyAnalysisContext analysisFrame) { DuplicateDataFlowOperationVisitor operationProcessor = new DuplicateDataFlowOperationVisitor(analysisFrame); CopyAnalysis duplicateAnalysis = new CopyAnalysis(operationProcessor); return duplicateAnalysis.attemptGetOrCalculateResultCore(analysisFrame, true); }", "answer": "private static CopyAnalysisResult? AttemptGetOrCalculateResultForAnalysisContext(CopyAnalysisContext analysisFrame) { var operationProcessor = new DuplicateDataFlowOperationVisitor(analysisFrame); var duplicateAnalysis = new CopyAnalysis(operationProcessor); return duplicateAnalysis.AttemptGetOrCalculateResultCore(analysisFrame, cacheResult: true); }"}
{"question": "private DuplicateAnalysisData(DuplicateAnalysisData sourceData) { super(sourceData); validateDuplicateAnalysisData(); }", "answer": "private DuplicateAnalysisData(DuplicateAnalysisData sourceData) : base(sourceData) { ValidateDuplicateAnalysisData(); }"}
{"question": "public final class DuplicateBlockAnalysisResult extends AbstractBlockAnalysisResult { private final Map<AnalysisEntity, CopyAbstractValue> result; private final boolean isAccessible; DuplicateBlockAnalysisResult(BasicBlock codeBlock, DuplicateAnalysisData blockAnalysisInfo) { super(codeBlock); if (blockAnalysisInfo != null && blockAnalysisInfo.getCoreData() != null) { this.result = Collections.unmodifiableMap(new HashMap<>(blockAnalysisInfo.getCoreData())); } else { this.result = Collections.emptyMap(); } this.isAccessible = blockAnalysisInfo != null ? blockAnalysisInfo.isAccessibleBlockData() : true; } public Map<AnalysisEntity, CopyAbstractValue> getResult() { return result; } public boolean isAccessible() { return isAccessible; } }", "answer": "public sealed class DuplicateBlockAnalysisResult : AbstractBlockAnalysisResult { internal DuplicateBlockAnalysisResult(BasicBlock codeBlock, DuplicateAnalysisData blockAnalysisInfo) : base(codeBlock) { Result = blockAnalysisInfo?.CoreData.ToImmutableDictionary() ?? ImmutableDictionary<AnalysisEntity, CopyAbstractValue>.Empty; IsAccessible = blockAnalysisInfo?.IsAccessibleBlockData ?? true; } }"}
{"question": "public Map<IFieldSymbol, PointsToAbstractValue> getMonitoredInstanceFieldReferenceMap() { if (_monitoredInstanceFieldReferences == null) { throw new IllegalStateException(); } return Collections.unmodifiableMap(new HashMap<>(_monitoredInstanceFieldReferences)); }", "answer": "public ImmutableDictionary<IFieldSymbol, PointsToAbstractValue> MonitoredInstanceFieldReferenceMap { get { if (_monitoredInstanceFieldReferences == null) { throw new InvalidOperationException(); } return _monitoredInstanceFieldReferences.ToImmutableDictionary(); } }"}
{"question": "private void processPotentialEscapeOperation(IOperation escapeOperation, Set<AbstractLocation> escapedTargets) { for (AbstractLocation escapedTarget : escapedTargets) { DisposeAbstractValue currentDisposeData = CurrentAnalysisState.get(escapedTarget); if (currentDisposeData != null && currentDisposeData.getKind() != DisposeAbstractValueKind.UNKNOWN) { DisposeAbstractValue updatedDisposeData = currentDisposeData.withNewEscapeOperation(escapeOperation); setAbstractValue(escapedTarget, updatedDisposeData); } } }", "answer": "private void ProcessPotentialEscapeOperation(IOperation escapeOperation, ImmutableHashSet<AbstractLocation> escapedTargets) { foreach (AbstractLocation escapedTarget in escapedTargets) { if (CurrentAnalysisState.TryGetValue(escapedTarget, out var currentDisposeData) && currentDisposeData.Kind != DisposeAbstractValueKind.Unknown) { DisposeAbstractValue updatedDisposeData = currentDisposeData.WithNewEscapeOperation(escapeOperation); SetAbstractValue(escapedTarget, updatedDisposeData); } } }"}
{"question": "private void initializeDisposableFieldsMap() { if (_lazyDisposableFieldsCache == null) { synchronized (this) { if (_lazyDisposableFieldsCache == null) { _lazyDisposableFieldsCache = new ConcurrentHashMap<INamedTypeSymbol, Set<IFieldSymbol>>(); } } } }", "answer": "private void InitializeDisposableFieldsMap() { if (_lazyDisposableFieldsCache == null) { Interlocked.CompareExchange(ref _lazyDisposableFieldsCache, new ConcurrentDictionary<INamedTypeSymbol, ImmutableHashSet<IFieldSymbol>>(), null); } }"}
{"question": "public static Predicate<ITypeSymbol> getDisposableCheckDelegate(Compilation compilation) { DisposeAnalysisHelper disposeCheckHelper = attemptGetOrCreate(compilation); if (disposeCheckHelper != null) { return disposeCheckHelper::isDisposable; } return item -> false; }", "answer": "public static Func<ITypeSymbol?, bool> GetDisposableCheckDelegate(Compilation compilation) { if (AttemptGetOrCreate(compilation, out var disposeCheckHelper)) { return disposeCheckHelper.IsDisposable; } return t => false; }"}
{"question": "private boolean hasResourceOwnershipChangeInConstructorParam(IMethodSymbol enclosingMethod) { return enclosingMethod.getMethodKind() == MethodKind.CONSTRUCTOR && enclosingMethod.getParameters().stream() .anyMatch(parameter -> resourceOwnershipTransferCandidateTypes.contains(parameter.getType())); }", "answer": "private bool HasResourceOwnershipChangeInConstructorParam(IMethodSymbol enclosingMethod) => enclosingMethod.MethodKind == MethodKind.Constructor && enclosingMethod.Parameters.Any(parameter => _resourceOwnershipTransferCandidateTypes.Contains(parameter.Type));"}
{"question": "public boolean containsAnyResourceCreationDescendant(ImmutableList<IOperation> operationGroups, IMethodSymbol enclosingMethod) { return hasAnyOperationDescendant(operationGroups, this::isResourceCreation) || hasResourceOwnershipChangeInConstructorParam(enclosingMethod); }", "answer": "public bool ContainsAnyResourceCreationDescendant(ImmutableArray<IOperation> operationGroups, IMethodSymbol enclosingMethod) { return operationGroups.HasAnyOperationDescendant(IsResourceCreation) || HasResourceOwnershipChangeInConstructorParam(enclosingMethod); }"}
{"question": "public boolean isResourceCreationOrResourceOwnershipChange(AbstractLocation location, IMethodSymbol enclosingMethod) { if (location.getCreation() == null) { return location.getSymbol() != null && location.getSymbol().getKind() == SymbolKind.PARAMETER && hasResourceOwnershipChangeInConstructorParam(enclosingMethod); } return isResourceCreation(location.getCreation()); }", "answer": "public bool IsResourceCreationOrResourceOwnershipChange(AbstractLocation location, IMethodSymbol enclosingMethod) { if (location.Creation == null) { return location.Symbol?.Kind == SymbolKind.Parameter && HasResourceOwnershipChangeInConstructorParam(enclosingMethod); } return IsResourceCreation(location.Creation); }"}
{"question": "static ControlFlowRegion getDeepestRegionInitiatedByBlock(BasicBlock codeBlock, ControlFlowRegionKind regionType) { if (codeBlock.getEnclosingRegion() == null || codeBlock.getEnclosingRegion().getFirstBlockOrdinal() != codeBlock.getOrdinal()) { return null; }", "answer": "internal static ControlFlowRegion? GetDeepestRegionInitiatedByBlock(this BasicBlock codeBlock, ControlFlowRegionKind regionType) { if (codeBlock.EnclosingRegion?.FirstBlockOrdinal != codeBlock.Ordinal) { return null; }"}
{"question": "static boolean controlsPredecessors(BasicBlock codeBlock, ControlFlowGraph cfg) { if (codeBlock == null || codeBlock.getPredecessors().isEmpty()) { return false; }", "answer": "internal static bool ControlsPredecessors(this BasicBlock? codeBlock, ControlFlowGraph cfg) { if (codeBlock == null || codeBlock.Predecessors.IsEmpty) { return false; }"}
{"question": "public static boolean isReverseEdge(ControlFlowBranch controlFlowEdge) { return controlFlowEdge != null && controlFlowEdge.getSource() != null && controlFlowEdge.getDestination() != null && controlFlowEdge.getSource().getOrdinal() >= controlFlowEdge.getDestination().getOrdinal(); }", "answer": "public static bool IsReverseEdge(this ControlFlowBranch controlFlowEdge) => controlFlowEdge?.Source != null && controlFlowEdge.Destination != null && controlFlowEdge.Source.Ordinal >= controlFlowEdge.Destination.Ordinal;"}
{"question": "public static ControlFlowConditionKind invert(ControlFlowConditionKind flowConditionType) { switch (flowConditionType) { case WHEN_FALSE: return ControlFlowConditionKind.WHEN_TRUE; case WHEN_TRUE: return ControlFlowConditionKind.WHEN_FALSE; default: System.err.println(\"Unsupported conditional kind: \" + flowConditionType); return flowConditionType; } }", "answer": "public static ControlFlowConditionKind Invert(this ControlFlowConditionKind flowConditionType) { switch (flowConditionType) { case ControlFlowConditionKind.WhenFalse: return ControlFlowConditionKind.WhenTrue; case ControlFlowConditionKind.WhenTrue: return ControlFlowConditionKind.WhenFalse; default: Debug.Fail($\"Unsupported conditional kind: '{flowConditionType}'\"); return flowConditionType; } }"}
{"question": "public static List<IOperation> childOperations(ControlFlowRegion controlFlowArea, ControlFlowGraph cfg) { List<IOperation> output = new ArrayList<>(); for (int index = controlFlowArea.getFirstBlockOrdinal(); index <= controlFlowArea.getLastBlockOrdinal(); index++) { BasicBlock block = cfg.getBlocks().get(index); output.addAll(block.descendantOperations()); } return output; }", "answer": "public static IEnumerable<IOperation> ChildOperations(this ControlFlowRegion controlFlowArea, ControlFlowGraph cfg) { for (var index = controlFlowArea.FirstBlockOrdinal; index <= controlFlowArea.LastBlockOrdinal; index++) { var block = cfg.Blocks[index]; foreach (var op in block.DescendantOperations()) { yield return op; } } }"}
{"question": "public static boolean isLeftValueFlowCaptureRef(IFlowCaptureReferenceOperation flowCaptureReferenceOp) { if (flowCaptureReferenceOp.getParent() instanceof IAssignmentOperation assignment) { return assignment.getTarget().equals(flowCaptureReferenceOp); } return false; }", "answer": "public static bool IsLeftValueFlowCaptureRef(this IFlowCaptureReferenceOperation flowCaptureReferenceOp) => flowCaptureReferenceOp.Parent is IAssignmentOperation assignment && assignment.Target == flowCaptureReferenceOp;"}
{"question": "public static ControlFlowGraph getFlowControlGraph(List<IOperation> operationGroups) { for (IOperation operationBase : operationGroups) { ControlFlowGraph cfg = operationBase.tryGetEnclosingControlFlowGraph(); if (cfg != null) { return cfg; } } return null; }", "answer": "public static ControlFlowGraph? GetFlowControlGraph(this ImmutableArray<IOperation> operationGroups) { foreach (var operationBase in operationGroups) { if (operationBase.TryGetEnclosingControlFlowGraph(out var cfg)) { return cfg; } } return null; }"}
{"question": "static AssemblyMetricData calculateSynchronously(IAssemblySymbol assembly, CodeMetricsAnalysisContext context) { List<CodeAnalysisMetricData> children = calculateSynchronously(getChildElements(assembly), context); return calculateFromChildren(assembly, children, context); }", "answer": "internal static AssemblyMetricData CalculateSynchronously(IAssemblySymbol assembly, CodeMetricsAnalysisContext context) { ImmutableArray<CodeAnalysisMetricData> children = CalculateSynchronously(GetChildElements(assembly), context); return CalculateFromChildren(assembly, children, context); }"}
{"question": "void handleNamespace(INamespaceSymbol namespaceItem) { for (INamespaceOrTypeSymbol member : namespaceItem.getMembers()) { if (member.getKind() == SymbolKind.NAMESPACE) { handleNamespace((INamespaceSymbol) member); } else if (namespaceItem.isGlobalNamespace()) { includeRootNamespace = true; } else if (!member.isImplicitlyDeclared()) { namespacesWithTypeElements.add(namespaceItem); } } }", "answer": "void handleNamespace(INamespaceSymbol ns) { foreach (INamespaceOrTypeSymbol member in ns.GetMembers()) { if (member.Kind == SymbolKind.Namespace) { handleNamespace((INamespaceSymbol)member); } else if (ns.IsGlobalNamespace) { includeRootNamespace = true; } else if (!member.IsImplicitlyDeclared) { namespacesWithTypeElements.Add(ns); } } }"}
{"question": "private static List<IMethodSymbol> getMethods(IEventSymbol eventItem) { List<IMethodSymbol> accessors = new ArrayList<>(); if (eventItem.getAddMethod() != null) { accessors.add(eventItem.getAddMethod()); } if (eventItem.getRemoveMethod() != null) { accessors.add(eventItem.getRemoveMethod()); } return accessors; }", "answer": "private static IEnumerable<IMethodSymbol> GetMethods(IEventSymbol eventItem) { if (eventItem.AddMethod != null) { yield return eventItem.AddMethod; } if (eventItem.RemoveMethod != null) { yield return eventItem.RemoveMethod; } }"}
{"question": "static NamespaceMetricData calculateSynchronously(INamespaceSymbol namespaceItem, CodeMetricsAnalysisContext context) { List<CodeAnalysisMetricData> children = calculateSynchronously(getChildElements(namespaceItem), context); return calculateFromChildren(namespaceItem, children, context); }", "answer": "internal static NamespaceMetricData CalculateSynchronously(INamespaceSymbol ns, CodeMetricsAnalysisContext context) { ImmutableArray<CodeAnalysisMetricData> children = CalculateSynchronously(GetChildElements(ns), context); return CalculateFromChildren(ns, children, context); }"}
{"question": "private static int computeMaintainabilityScore(ComputationalComplexityMetrics computationComplexityMetrics, int cycleComplexity) { double computationalComplexityVolume = Math.max(0.0, Math.log(computationComplexityMetrics.getVolume())); // avoid Log(0) = -Infinity double logEffectiveLinesOfCode = Math.max(0.0, Math.log(computationComplexityMetrics.getEffectiveLinesOfCode())); // avoid Log(0) = -Infinity double rawMI = 171 - 5.2 * computationalComplexityVolume - 0.23 * cycleComplexity - 16.2 * logEffectiveLinesOfCode; return MetricsHelper.normalizeAndRoundMaintainabilityIndex(rawMI); }", "answer": "private static int ComputeMaintainabilityScore(ComputationalComplexityMetrics computationComplexityMetrics, int cycleComplexity) { double computationalComplexityVolume = Math.Max(0.0, Math.Log(computationComplexityMetrics.Volume)); //avoid Log(0) = -Infinity double logEffectiveLinesOfCode = Math.Max(0.0, Math.Log(computationComplexityMetrics.EffectiveLinesOfCode)); //avoid Log(0) = -Infinity return MetricsHelper.NormalizeAndRoundMaintainabilityIndex( 171 - 5.2 * computationalComplexityVolume - 0.23 * cycleComplexity - 16.2 * logEffectiveLinesOfCode ); }"}
{"question": "public static CompletableFuture<CodeAnalysisMetricData> calculateAsync(Compilation compilation, CancellationToken cancelToken) { if (compilation == null) { throw new IllegalArgumentException(\"compilation cannot be null\"); } CodeMetricsAnalysisContext context = new CodeMetricsAnalysisContext(compilation, cancelToken); return calculateAsync(compilation.getAssembly(), context); }", "answer": "public static Task<CodeAnalysisMetricData> CalculateAsync(Compilation compilation, CancellationToken cancelToken) { if (compilation == null) { throw new ArgumentNullException(nameof(compilation)); } return CalculateAsync(compilation.Assembly, new CodeMetricsAnalysisContext(compilation, cancelToken)); }"}
{"question": "private void trackOperator(IOperation op) { operatorUsageTotal++; if (distinctOperatorKindsBuilder == null) { distinctOperatorKindsBuilder = new HashSet<>(); } distinctOperatorKindsBuilder.add(op.getKind()); }", "answer": "void trackOperator(IOperation op) { operatorUsageTotal++; distinctOperatorKindsBuilder ??= ImmutableHashSet.CreateBuilder<OperationKind>(); distinctOperatorKindsBuilder.Add(op.Kind); }"}
{"question": "static void addAssociatedNamedTypes( Set<INamedTypeSymbol> builder, WellKnownTypeProvider knownTypeProvider, ITypeSymbol associatedType) { addAssociatedNamedTypesCore(builder, associatedType, knownTypeProvider); }", "answer": "internal static void AddAssociatedNamedTypes(ImmutableHashSet<INamedTypeSymbol>.Builder builder, WellKnownTypeProvider knownTypeProvider, ITypeSymbol associatedType) { AddAssociatedNamedTypesCore(builder, associatedType, knownTypeProvider); }"}
{"question": "static void excludeContainingTypes(ISymbol symbol, Set<INamedTypeSymbol> associatedTypesBuilder) { INamedTypeSymbol typeSymbol = (symbol instanceof INamedTypeSymbol) ? (INamedTypeSymbol) symbol : symbol.getContainingType(); while (typeSymbol != null) { associatedTypesBuilder.remove(typeSymbol); typeSymbol = typeSymbol.getContainingType(); } }", "answer": "internal static void ExcludeContainingTypes(ISymbol symbol, ImmutableHashSet<INamedTypeSymbol>.Builder associatedTypesBuilder) { var typeSymbol = symbol as INamedTypeSymbol ?? symbol.ContainingType; while (typeSymbol != null) { associatedTypesBuilder.Remove(typeSymbol); typeSymbol = typeSymbol.ContainingType; } }"}
{"question": "static List<IParameterSymbol> obtainParameters(ISymbol member) { switch (member.getKind()) { case METHOD: return ((IMethodSymbol) member).getParameters(); case PROPERTY: return ((IPropertySymbol) member).getParameters(); default: return Collections.emptyList(); } }", "answer": "internal static ImmutableArray<IParameterSymbol> ObtainParameters(this ISymbol member) { return member.Kind switch { SymbolKind.Method => ((IMethodSymbol)member).Parameters, SymbolKind.Property => ((IPropertySymbol)member).Parameters, _ => ImmutableArray<IParameterSymbol>.Empty, }; }"}
{"question": "public class SemanticModelCache { private final Compilation compilation; private final ConcurrentHashMap<SyntaxTree, SemanticModel> semanticModelCache; public SemanticModelCache(Compilation compilation) { this.compilation = Objects.requireNonNull(compilation, \"compilation must not be null\"); this.semanticModelCache = new ConcurrentHashMap<>(); } public Compilation getCompilation() { return compilation; } public ConcurrentHashMap<SyntaxTree, SemanticModel> getSemanticModelCache() { return semanticModelCache; } }", "answer": "public SemanticModelCache(Compilation compilation) { Compilation = compilation; _semanticModelCache = new ConcurrentDictionary<SyntaxTree, SemanticModel>(); }"}
{"question": "public SemanticModel getSemanticModel(SyntaxNode node) { return semanticModelMap.computeIfAbsent( node.getSyntaxTree(), tree -> compilation.getSemanticModel(tree) ); }", "answer": "public SemanticModel GetSemanticModel(SyntaxNode node) => _semanticModelMap.GetOrAdd(node.SyntaxTree, tree => Compilation.GetSemanticModel(node.SyntaxTree));"}
{"question": "public static Diagnostic GenerateDiagnostic( this SyntaxNode node, DiagnosticDescriptor rule, params object[] arguments) => node.CreateDiagnostic(rule, properties: null, arguments);", "answer": "public static Diagnostic GenerateDiagnostic( this SyntaxNode node, DiagnosticDescriptor rule, params object[] arguments) => node.CreateDiagnostic(rule, properties: null, arguments);"}
