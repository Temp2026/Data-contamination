{"question": "public Array2DRowRealMatrix getData() { return (Array2DRowRealMatrix)data.copy(); }", "answer": "This function Return a copy of the data"}
{"question": "public double[] getColumn(String header) { return getColumn(getColumnIdx(header)); }", "answer": "This function Return a copy of the column corresponding to the header"}
{"question": "public Array2DRowRealMatrix getDataRef() { return data; }", "answer": "This function Return a reference to the data"}
{"question": "public double getEntry(int row, int col) { return this.data.getEntry(row, col); }", "answer": "This function Get the entry at the given row/col indices"}
{"question": "public double setEntry(int row, int col, double newValue) { double d = getEntry(row, col); this.data.setEntry(row, col, newValue); return d; }", "answer": "This function Set the indices of row/col to the new value and return the old value"}
{"question": "public void stdOut() { System.out.println(this.toString()); }", "answer": "This function View the dataset in the console"}
{"question": "public void toFlatFile(boolean header, final File file) throws IOException { toFlatFile(header, file, ','); }", "answer": "This function Write the dataset to a CSV"}
{"question": "public static PublicKey generatePublicKey(String encodedPublicKey) { try { byte[] decodedKey = Base64.decode(encodedPublicKey, Base64.DEFAULT); KeyFactory keyFactory = KeyFactory.getInstance(KEY_FACTORY_ALGORITHM); return keyFactory.generatePublic(new X509EncodedKeySpec(decodedKey)); } catch (NoSuchAlgorithmException e) { throw new RuntimeException(e); } catch (InvalidKeySpecException e) { Log.e(TAG, \"Invalid key specification.\"); throw new IllegalArgumentException(e); } catch (IllegalArgumentException e) { Log.e(TAG, \"Base64 decoding failed.\"); throw e; } }", "answer": "This function Generates a PublicKey instance from a string containing the Base64-encoded public key."}
{"question": "public AbstractPair (Object component1, Object component2) { this.component1 = component1; this.component2 = component2; }", "answer": "This function Constructs a new pair, with <code>component1</code> as its first and <code>component2</code> as its second component."}
{"question": "public boolean equals (Object o) { return (o.getClass().equals(this.getClass()) && (((((AbstractPair)o).component1 == null) && (this.component1 == null)) || ((this.component1 != null) && ((AbstractPair)o).component1.equals(this.component1))) && (((((AbstractPair)o).component2 == null) && (this.component2 == null)) || ((this.component2 != null) && ((AbstractPair)o).component2.equals(this.component2)))); }", "answer": "This function Compares the specified object with this <code>AbstractPair</code> for equality."}
{"question": "public int hashCode () { return (component1 == null ? 0 : component1.hashCode()) + (component2 == null ? 1 : component2.hashCode()); }", "answer": "This function Returns a hash code value of this pair."}
{"question": "public String toString () { return beginChar + component1 + separatorChar + component2 + endChar; }", "answer": "This function Returns a string representation of this pair."}
{"question": "public boolean isCached(URL url) { return cache.containsKey(url); }", "answer": "This function Returns whether a response from a request with the given URL exists in the in-memory cache."}
{"question": "public String fetchFromWeb(URL url) { Log.d(TAG, \"Fetching from web: \" + url.toString()); try { HttpURLConnection conn = (HttpURLConnection) url.openConnection(); conn.setUseCaches(false); conn.setReadTimeout(30000); // 30 seconds. conn.setDoInput(true); conn.connect(); InputStream is = conn.getInputStream(); return readStringFromStream(is); } catch (IOException e) { e.printStackTrace(); } return null; }", "answer": "This function Fetches the given URL from the web."}
{"question": "public List<java.lang.Object> getAny() { if (any == null) { any = new ArrayList<java.lang.Object>(); } return this.any; }", "answer": "This function Gets the value of the any property."}
{"question": "public Map<QName, String> getOtherAttributes() { return otherAttributes; }", "answer": "This function Gets a map that contains attributes that aren't bound to any typed property on this class."}
{"question": "public <T> LambdaMap<K, T> convertValues(Converter<V, T> converter) { return new LambdaMap<K, T>(convertMap(innerMap, converter)); }", "answer": "This function Converts all the values in this map using the given {@link Converter}."}
{"question": "public <T> LambdaMap<K, T> convertValues(T argument) { return new LambdaMap<K, T>(convertMap(innerMap, argument)); }", "answer": "This function Converts all the values in this map extracting the property defined by the given argument."}
{"question": "public LambdaMap<K, V> retainKeys(Matcher<?> matcher) { return retain(matcher, true); }", "answer": "This function Retains only the entries in this map having a key that matches the given matcher"}
{"question": "public LambdaMap<K, V> removeKeys(Matcher<?> matcher) { return retainKeys(not(matcher)); }", "answer": "This function Remove the entries in this map having a key that matches the given matcher"}
{"question": "@Override public LambdaMap<K, V> clone() { return clone(new HashMap<K, V>()); }", "answer": "This function Returns a shallow copy of this LambdaMap instance."}
{"question": "private function conPropertyChanged(event:PropertyChangeEvent):void { //make sure the ack is for a subscribe operation if(event.property == \"subscribed\" && con.subscribed) { //test that the subscribe operation was for the channel we are currently testing Assert.assertTrue(\"Wrong channel: \" + con.channelSet.currentChannel.id, con.channelSet.currentChannel.id == currentTest); //send the message var msg:IMessage = new AsyncMessage(); msg.body = \"hello \" + currentTest; pro.send(msg); } }", "answer": "This function Listen for property change events on the consumer so we can tell when the consumer has subscribed."}
{"question": "public List<StatusType> getName() { if (name == null) { name = new ArrayList<StatusType>(); } return this.name; }", "answer": "This function Gets the value of the name property."}
{"question": "public void modifyingRequest( final String requestId ) { if ( _log.isDebugEnabled() ) { _log.debug( \"Registering modifying request: \" + requestId ); } incrementOrPut( _blacklist, requestId ); _readOnlyRequests.remove( requestId ); }", "answer": "This function Registers the given requestURI as a modifying request, which can be seen as a blacklist for readonly requests."}
{"question": "public boolean isReadOnlyRequest( final String requestId ) { if ( _log.isDebugEnabled() ) { _log.debug( \"Asked for readonly request: \" + requestId + \" (\"+ _readOnlyRequests.containsKey( requestId ) +\")\" ); } // TODO: add some threshold return _readOnlyRequests.containsKey( requestId ); }", "answer": "This function Determines, if the given requestURI is a readOnly request and not blacklisted as a modifying request."}
{"question": "public static TradeList of(List<Trade> trades) { return new TradeList(trades); }", "answer": "This function Obtains an instance from a list of trades."}
{"question": "public MicroPipelineResource(final MicroPipelineManager microPipelineManager) throws RequiredInputMissingException { if(microPipelineManager == null) throw new RequiredInputMissingException(\"Missing required micro pipeline manager instance\"); this.microPipelineManager = microPipelineManager; }", "answer": "This function Initializes the micro pipeline resource using the provided input"}
{"question": "public static _Fields findByThriftId(int fieldId) { switch(fieldId) { case 1: // FIELDS return FIELDS; default: return null; } }", "answer": "This function Find the _Fields constant that matches fieldId, or null if its not found."}
{"question": "public boolean is_set_fields() { return this.fields != null; }", "answer": "This function Returns true if field fields is set (has been asigned a value) and false otherwise"}
{"question": "@Override public Map<String, Object> getKafkaConfig() { Map<String, Object> config = getConfig(); if (parent == null) { return config; } if (_mergedConfig == null) { // lazy init _mergedConfig = merge(parent.getKafkaConfig(), config); } return _mergedConfig; }", "answer": "This function Get the merged config of this object and its parent."}
{"question": "protected ReportFormatter(FormatSettings<Object> defaultSettings) { this.defaultSettings = defaultSettings; }", "answer": "This function Creates a new formatter with a set of default format settings."}
{"question": "public int getCachedSize() { if (cachedSize < 0) { // getSerializedSize sets cachedSize getSerializedSize(); } return cachedSize; }", "answer": "This function Get the number of bytes required to encode this message."}
{"question": "public int getSerializedSize() { int size = computeSerializedSize(); cachedSize = size; return size; }", "answer": "This function Computes the number of bytes required to encode this message."}
{"question": "public static final void toByteArray(MessageNano msg, byte[] data, int offset, int length) { try { final CodedOutputByteBufferNano output = CodedOutputByteBufferNano.newInstance(data, offset, length); msg.writeTo(output); output.checkNoSpaceLeft(); } catch (IOException e) { throw new RuntimeException(\"Serializing to a byte array threw an IOException \" + \"(should never happen).\", e); } }", "answer": "This function Serialize to a byte array starting at offset through length."}
{"question": "public static final <T extends MessageNano> T mergeFrom(T msg, final byte[] data, final int off, final int len) throws InvalidProtocolBufferNanoException { try { final CodedInputByteBufferNano input = CodedInputByteBufferNano.newInstance(data, off, len); msg.mergeFrom(input); input.checkLastTagWas(0); return msg; } catch (InvalidProtocolBufferNanoException e) { throw e; } catch (IOException e) { throw new RuntimeException(\"Reading from a byte array threw an IOException (should \" + \"never happen).\"); } }", "answer": "This function Parse {@code data} as a message of this type and merge it with the message being built."}
{"question": "@Override public String toString() { return MessageNanoPrinter.print(this); }", "answer": "This function Returns a string that is (mostly) compatible with ProtoBuffer's TextFormat."}
{"question": "public static String composeAbsoluteContext(final String base, final String context) { // Precondition checks assertSpecified(base); assertSpecified(context); // Compose final String relative = PathUtil.adjustToAbsoluteDirectoryContext(base); final String reformedContext = PathUtil.optionallyRemovePrecedingSlash(context); final String actual = relative + reformedContext; // Return return actual; }", "answer": "This function Composes an absolute context from a given base and actual context relative to the base, returning the result."}
{"question": "public static String adjustToRelativeDirectoryContext(final String path) { // Return nulls if (path == null) { return path; } // Strip absolute form final String removedPrefix = optionallyRemovePrecedingSlash(path); // Add end of context slash final String addedPostfix = optionallyAppendSlash(removedPrefix); // Return return addedPostfix; }", "answer": "This function Adjusts the specified path to relative form: 1) Removes, if present, a preceding slash 2) Adds, if not present, a trailing slash Null arguments are returned as-is"}
{"question": "private static boolean isFirstCharSlash(final String path) { assertSpecified(path); if (path.length() == 0) { return false; } return path.charAt(0) == ArchivePath.SEPARATOR; }", "answer": "This function Returns whether or not the first character in the specified String is a slash"}
{"question": "public int findFirstVisibleItemPosition() { return findOneVisibleChild(0, getChildCount(), false); }", "answer": "This function Returns the adapter position of the first visible view."}
{"question": "@SuppressWarnings(\"deprecation\") public static void addFileToClassPath(String file, Configuration conf) throws IOException { Path pathInHDFS = shipToHDFS(conf, file); org.apache.hadoop.filecache.DistributedCache.addFileToClassPath(pathInHDFS, conf, FileSystem.get(conf)); }", "answer": "This function Add a hdfs file to classpath of one container."}
{"question": "public static void dispose() { disposeColors(); disposeImages(); disposeFonts(); disposeCursors(); }", "answer": "This function Dispose of cached objects and their underlying OS resources."}
{"question": "private DynamicMessage(Descriptor type, FieldSet<FieldDescriptor> fields, UnknownFieldSet unknownFields) { this.type = type; this.fields = fields; this.unknownFields = unknownFields; }", "answer": "This function Construct a {@code DynamicMessage} using the given {@code FieldSet}."}
{"question": "public static DynamicMessage getDefaultInstance(Descriptor type) { return new DynamicMessage(type, FieldSet.<FieldDescriptor>emptySet(), UnknownFieldSet.getDefaultInstance()); }", "answer": "This function Get a {@code DynamicMessage} representing the default instance of the given type."}
{"question": "public static DynamicMessage parseFrom(Descriptor type, CodedInputStream input) throws IOException { return newBuilder(type).mergeFrom(input).buildParsed(); }", "answer": "This function Parse a message of the given type from the given input stream."}
{"question": "private void verifyContainingType(FieldDescriptor field) { if (field.getContainingType() != type) { throw new IllegalArgumentException( \"FieldDescriptor does not match message type.\"); } }", "answer": "This function Verifies that the field is a field of this message."}
{"question": "public void scan(InputStream in, IOBJScannerHandler handler) throws WFException, IOException;", "answer": "This function Scans the file specified through the {@link InputStream} and passes any events to the {@link IOBJScannerHandler} instance."}
{"question": "protected void assertOnlyOneWrapped(Iterable<TokenRange> ranges) { TokenRange wrappedRange = null; for (TokenRange range : ranges) { if (range.isWrappedAround()) { assertThat(wrappedRange) .as(\"Found a wrapped around TokenRange (%s) when one already exists (%s).\", range, wrappedRange) .isNull(); wrappedRange = range; assertThat(range).isWrappedAround(); // this also checks the unwrapped ranges } else { assertThat(range).isNotWrappedAround(); } } }", "answer": "This function Asserts that given the input {@link TokenRange}s that at most one of them wraps the token ring."}
{"question": "@Override public void write(byte buffer[], int offset, int length) throws IOException { synchronized (__client) { while (length-- > 0) { write(buffer[offset++]); } } }", "answer": "This function Writes a number of bytes from a byte array to the stream starting from a given offset."}
{"question": "public Wander<T> setWanderRadius (float wanderRadius) { this.wanderRadius = wanderRadius; return this; }", "answer": "This function Sets the radius of the wander circle."}
{"question": "public float getWanderRate () { return wanderRate; }", "answer": "This function Returns the rate, expressed in radian per second, at which the wander orientation can change."}
{"question": "public float getWanderOrientation () { return wanderOrientation; }", "answer": "This function Returns the current orientation of the wander target."}
{"question": "public Wander<T> setWanderOrientation (float wanderOrientation) { this.wanderOrientation = wanderOrientation; return this; }", "answer": "This function Sets the current orientation of the wander target."}
{"question": "public static void dropTable(SQLiteDatabase db, boolean ifExists) { String sql = \"DROP TABLE \" + (ifExists ? \"IF EXISTS \" : \"\") + \"'SCENE'\"; db.execSQL(sql); }", "answer": "This function Drops the underlying database table."}
{"question": "public void setDictionary(Dictionary dictionary) { throw new UnsupportedOperationException(getClass().getName()); }", "answer": "This function Set the dictionary to use if the data was encoded using dictionary encoding and the converter hasDictionarySupport()."}
{"question": "public void setDictionary(Dictionary dictionary) { throw new UnsupportedOperationException(getClass().getName()); }", "answer": "This function Set the dictionary to use if the data was encoded using dictionary encoding and the converter hasDictionarySupport()."}
{"question": "public void addUpdateListener(AnimatorUpdateListener listener) { if (mUpdateListeners == null) { mUpdateListeners = new ArrayList<AnimatorUpdateListener>(); } mUpdateListeners.add(listener); }", "answer": "This function Adds a listener to the set of listeners that are sent update events through the life of an animation."}
{"question": "public void removeAllUpdateListeners() { if (mUpdateListeners == null) { return; } mUpdateListeners.clear(); mUpdateListeners = null; }", "answer": "This function Removes all listeners from the set listening to frame updates for this animation."}
{"question": "public void removeAllUpdateListeners() { if (mUpdateListeners == null) { return; } mUpdateListeners.clear(); mUpdateListeners = null; }", "answer": "This function Removes all listeners from the set listening to frame updates for this animation."}
{"question": "public void setFixedAspectRatio(boolean fixAspectRatio) { mFixAspectRatio = fixAspectRatio; if (initializedCropWindow) { initCropWindow(mBitmapRect); invalidate(); } }", "answer": "This function Sets whether the aspect ratio is fixed or not; true fixes the aspect ratio, while false allows it to be changed."}
{"question": "public static List<Path> findFilesInPath(Path rootPath, PathMatcher scanFilter, PathMatcher fileFilter) throws IOException { final ImmutableList.Builder<Path> resultBuilder = ImmutableList.builder(); Files.walkFileTree(rootPath, new FileScanning.FilteredFileVisitor(scanFilter, fileFilter) { @Override protected void onMatch(Path file) { resultBuilder.add(file); } }); return resultBuilder.build(); }", "answer": "This function Scans a path, recursing all paths matching the scanFilter and returning all files matching the fileFilter"}
{"question": "public static ImmutableScenarioMarketData of( int scenarioCount, LocalDate valuationDate, Map<? extends MarketDataId<?>, MarketDataBox<?>> values, Map<? extends ObservableId, LocalDateDoubleTimeSeries> timeSeries) { return of(scenarioCount, MarketDataBox.ofSingleValue(valuationDate), values, timeSeries); }", "answer": "This function Obtains an instance from a valuation date, map of values and time-series."}
{"question": "private void setChildSize(View v) { MondrianLayout.LayoutParams params = (LayoutParams) v.getLayoutParams(); int left = params.x * cellWidth + (params.x + 1) * thickness; int top = params.y * cellHeight + (params.y + 1) * thickness; int right = left + params.width * cellWidth + (params.width - 1) * thickness; int bottom = top + params.height * cellHeight + (params.height - 1) * thickness; v.layout(left, top, right, bottom); }", "answer": "This function Tells to a children the space it can ocuppy based on its {@link .LayoutParams}"}
{"question": "@Override public Statement apply(Statement base, Description description) { return stagingLocation.apply(base, description); }", "answer": "This function Uses a TemporaryFolder rule to process a given statement."}
{"question": "@Override public void runScript(HiveContext hqlContext) { String[] expressions = ScriptSplitter.splitScriptIntoExpressions(script); for (String expression : expressions) { hqlContext.sql(expression); } }", "answer": "This function Splits the bundled hql script into multiple expressions using ScriptSlitter utility class."}
{"question": "private void populateReplicaListPerDatacenter(List<ReplicaId> replicaIds) { for (ReplicaId replicaId : replicaIds) { if (!replicaId.isDown()) { String dataCenterName = replicaId.getDataNodeId().getDatacenterName(); if (!replicaListPerDatacenter.containsKey(dataCenterName)) { replicaListPerDatacenter.put(dataCenterName, new ArrayList<ReplicaId>()); } replicaListPerDatacenter.get(dataCenterName).add(replicaId); } } }", "answer": "This function Adds replicas to replicasPerDatacenter (Map of datacenter to List of replicas)"}
{"question": "private int getReplicasInFlightCount() { int replicasInFlight = 0; for (List<ReplicaId> replicaIdList : replicasInFlightPerDatacenter.values()) { replicasInFlight += replicaIdList.size(); } return replicasInFlight; }", "answer": "This function Fetches the replicas in flight count (either local or remote)"}
{"question": "static SSLContextSelector aggregate(SSLContextSelector selector1, SSLContextSelector selector2) { return information -> { SSLContext sslContext = null; if (selector1 != null) sslContext = selector1.selectContext(information); if (sslContext == null && selector2 != null) sslContext = selector2.selectContext(information); return sslContext; }; }", "answer": "This function Create an aggregate selector which executes each given selector in order until a match is found."}
{"question": "private boolean checkCSVAndRequestedTableColumns(String[] columnNames, String csvFilePath, String delimiter) { return GraphExecutionUtil.checkCSVAndRequestedTableColumns(csvFilePath, columnNames, delimiter); }", "answer": "This function This Method checks whether csv file provided and the column name in schema are same or not"}
{"question": "private boolean checkAllColumnsPresent(String[] columnNames, String dimFilePath, String delimiter) { return GraphExecutionUtil.checkCSVAndRequestedTableColumns(dimFilePath, columnNames, delimiter); }", "answer": "This function Check All the columns are present in the CSV File"}
{"question": "public void interruptGraphExecution() { LOGGER.error(\"Graph Execution is interrupted\"); if (null != trans) { trans.killAll(); LOGGER.info(\"Graph execution steps are killed.\"); } }", "answer": "This function Interrupts all child threads run by kettle to execute the graph"}
{"question": "public static void write(JsonElement element, JsonWriter writer) throws IOException { TypeAdapters.JSON_ELEMENT.write(writer, element); }", "answer": "This function Writes the JSON element to the writer, recursively."}
{"question": "private Map<String, SemanticType> buildGenericBinding(SemanticType[] from, SemanticType[] to) { Map<String, SemanticType> binding = new HashMap(); for (int i = 0; i < to.length; i++) { SemanticType.Var var = (SemanticType.Var) from[i]; binding.put(var.name(), to[i]); } return binding; }", "answer": "This function Builds up a generic binding map that can be used to instantiate generics in function or macro definitions."}
{"question": "public void waitForLayoutNotification(String layoutId) { synchronized (mLock) { while (!Objects.equal(getCurrentLayoutId(), layoutId)) { LOG.info(\"Waiting for layout notification with ID {}, current layout ID is {}.\", layoutId, mCurrentLayoutId); try { mLock.wait(); } catch (InterruptedException ie) { throw new RuntimeInterruptedException(ie); } } } }", "answer": "This function Waits for the current table layout to switch to the specified layout ID."}
{"question": "public HBaseTableLayoutUpdater( final HBaseKiji kiji, final KijiURI tableURI, final Function<KijiTableLayout, TableLayoutDesc> layoutUpdate) throws IOException, KeeperException { mKiji = kiji; mKiji.retain(); mTableURI = tableURI; mZKClient = mKiji.getZKClient(); mLayoutUpdate = layoutUpdate; }", "answer": "This function Initializes a new layout updater for the specified table and with the specified layout update."}
{"question": "private void hideNotification(boolean stopPlayback) { stopForeground(true); if(stopPlayback) stopSelf(); }", "answer": "This function Hides the VLC notification and stops the service."}
{"question": "public ObjectLookupContainer<KType> keys() { return map.keys(); }", "answer": "This function Returns a specialized view of the keys of this associated container."}
{"question": "public static CommonTermsQueryBuilder commonTerms(String name, Object text) { return new CommonTermsQueryBuilder(name, text); }", "answer": "This function Creates a common query for the provided field name and text."}
{"question": "public static IdsQueryBuilder idsQuery(@Nullable String... types) { return new IdsQueryBuilder(types); }", "answer": "This function Constructs a query that will match only specific ids within types."}
{"question": "public static InetAddress getFirstAddress(NetworkInterface intf, StackType ipVersion) throws SocketException { if (intf == null) throw new IllegalArgumentException(\"Network interface pointer is null\"); for (Enumeration addresses = intf.getInetAddresses(); addresses.hasMoreElements(); ) { InetAddress address = (InetAddress) addresses.nextElement(); if ((address instanceof Inet4Address && ipVersion == StackType.IPv4) || (address instanceof Inet6Address && ipVersion == StackType.IPv6)) return address; } return null; }", "answer": "This function Returns the first address with the proper ipVersion on the given interface on the current host."}
{"question": "public static List<NetworkInterface> getAllAvailableInterfaces() throws SocketException { List<NetworkInterface> allInterfaces = new ArrayList<NetworkInterface>(); for (Enumeration<NetworkInterface> interfaces = NetworkInterface.getNetworkInterfaces(); interfaces.hasMoreElements(); ) { NetworkInterface intf = interfaces.nextElement(); allInterfaces.add(intf); Enumeration<NetworkInterface> subInterfaces = intf.getSubInterfaces(); if (subInterfaces != null && subInterfaces.hasMoreElements()) { while (subInterfaces.hasMoreElements()) { allInterfaces.add(subInterfaces.nextElement()); } } } return allInterfaces; }", "answer": "This function Returns all the available interfaces, including first level sub interfaces."}
{"question": "public CreateIndexRequest mapping(String type, String source) { mappings.put(type, source); return this; }", "answer": "This function Adds mapping that will be added when the index gets created."}
{"question": "@Override public String toString() { StringBuilder sb = new StringBuilder(); sb.append(\"{\"); if (jobType != null) sb.append(\"JobType: \" + jobType + \", \"); if (manifest != null) sb.append(\"Manifest: \" + manifest + \", \"); if (manifestAddendum != null) sb.append(\"ManifestAddendum: \" + manifestAddendum + \", \"); if (validateOnly != null) sb.append(\"ValidateOnly: \" + validateOnly + \", \"); sb.append(\"}\"); return sb.toString(); }", "answer": "This function Returns a string representation of this object; useful for testing and debugging."}
{"question": "public java.util.List<Filter> getFilters() { if (filters == null) { filters = new java.util.ArrayList<Filter>(); } return filters; }", "answer": "This function A list of filters used to match properties for Subnets."}
{"question": "public java.util.List<Filter> getFilters() { if (filters == null) { filters = new java.util.ArrayList<Filter>(); } return filters; }", "answer": "This function A list of filters used to match properties for Subnets."}
{"question": "public void download(final String vaultName, final String archiveId, final File file) throws AmazonServiceException, AmazonClientException { download(null, vaultName, archiveId, file); }", "answer": "This function Downloads an archive from Amazon Glacier in the specified vault for the current user's account, and saves it to the specified file."}
{"question": "public UploadResult upload(final String accountId, final String vaultName, final String archiveDescription, final File file) throws AmazonServiceException, AmazonClientException, FileNotFoundException { if (file.length() > MULTIPART_UPLOAD_SIZE_THRESHOLD) { return uploadInMultipleParts(accountId, vaultName, archiveDescription, file); } else { return uploadInSinglePart(accountId, vaultName, archiveDescription, file); } }", "answer": "This function Uploads the specified file to Amazon Glacier for archival storage in the specified vault in the specified user's account."}
{"question": "@Override public String toString() { StringBuilder sb = new StringBuilder(); sb.append(\"{\"); if (cloudFrontOriginAccessIdentityConfig != null) sb.append(\"CloudFrontOriginAccessIdentityConfig: \" + cloudFrontOriginAccessIdentityConfig + \", \"); if (eTag != null) sb.append(\"ETag: \" + eTag + \", \"); sb.append(\"}\"); return sb.toString(); }", "answer": "This function Returns a string representation of this object; useful for testing and debugging."}
{"question": "public ArnCondition(ArnComparisonType type, String key, String value) { super.type = type.toString(); super.conditionKey = key; super.values = Arrays.asList(new String[] {value}); }", "answer": "This function Constructs a new access control policy condition that compares ARNs (Amazon Resource Names)."}
{"question": "public TooManyDistributionCNAMEsException(String message) { super(message); }", "answer": "This function Constructs a new TooManyDistributionCNAMEsException with the specified error message."}
{"question": "public LongBuffer put(long[] src, int off, int len) { int length = src.length; if (off < 0 || len < 0 || (long) len + (long) off > length) { throw new IndexOutOfBoundsException(); } if (len > remaining()) { throw new BufferOverflowException(); } for (int i = off; i < off + len; i++) { put(src[i]); } return this; }", "answer": "This function Writes longs from the given long array, starting from the specified offset, to the current position and increases the position by the number of longs written."}
{"question": "public int alloc() { final int index = mStackSize; mStackSize++; mStack[index] = 0; return index; }", "answer": "This function Pushes a new value, and returns the index you can use to increment and read that value later."}
{"question": "static String quoteIfNeeded(String source) { String trimmed = source.trim(); if (isObject(trimmed) || isArray(trimmed) || isString(trimmed) || isBoolean(trimmed) || isNull(trimmed) || isNumber(trimmed)) { return source; } else { return \"\\\"\" + source + \"\\\"\"; } }", "answer": "This function Add quotes around the object iff it's not a JSON object."}
{"question": "public void testFillDataPoint_time() { // By time chartFragment.setChartByDistance(false); MyTracksLocation myTracksLocation1 = TrackStubUtils.createMyTracksLocation(); double[] point = fillDataPointTestHelper(myTracksLocation1); assertEquals(0.0, point[0]); long timeSpan = 222; MyTracksLocation myTracksLocation2 = TrackStubUtils.createMyTracksLocation(); myTracksLocation2.setTime(myTracksLocation1.getTime() + timeSpan); point = fillDataPointTestHelper(myTracksLocation2); assertEquals((double) timeSpan, point[0]); }", "answer": "This function Tests the logic to get the values of time in {@link ChartFragment#fillDataPoint(Location, double[])}."}
{"question": "private void tryStartingKbMode(int keyCode) { if (keyCode == -1 || addKeyIfLegal(keyCode)) { mInKbMode = true; onValidationChanged(false); updateDisplay(false); mRadialTimePickerView.setInputEnabled(false); } }", "answer": "This function Try to start keyboard mode with the specified key."}
{"question": "private boolean isTypedTimeLegalSoFar() { Node node = mLegalTimesTree; for (int keyCode : mTypedTimes) { node = node.canReach(keyCode); if (node == null) { return false; } } return true; }", "answer": "This function Traverse the tree to see if the keys that have been typed so far are legal as is, or may become legal as more keys are typed (excluding backspace)."}
{"question": "private boolean isTypedTimeFullyLegal() { if (mIs24HourView) { // For 24-hour mode, the time is legal if the hours and minutes are each legal. Note: // getEnteredTime() will ONLY call isTypedTimeFullyLegal() when NOT in 24hour mode. int[] values = getEnteredTime(null); return (values[0] >= 0 && values[1] >= 0 && values[1] < 60); } else { // For AM/PM mode, the time is legal if it contains an AM or PM, as those can only be // legally added at specific times based on the tree's algorithm. return (mTypedTimes.contains(getAmOrPmKeyCode(AM)) || mTypedTimes.contains(getAmOrPmKeyCode(PM))); } }", "answer": "This function Check if the time that has been typed so far is completely legal, as is."}
{"question": "public Builder lag(Period lag) { JodaBeanUtils.notNull(lag, \"lag\"); this.lag = lag; return this; }", "answer": "This function Sets the positive period between the price index and the accrual date, typically a number of months."}
{"question": "static HttpServer startServer() throws IOException { // create a new server listening at port 9091 HttpServer server = HttpServer.create(new InetSocketAddress(getBaseURI().getPort()), 0); // create a handler wrapping the JAX-RS application HttpHandler handler = RuntimeDelegate.getInstance().createEndpoint(new JaxRsApplication(), HttpHandler.class); // map JAX-RS handler to the server root server.createContext(getBaseURI().getPath(), handler); // start the server server.start(); return server; }", "answer": "This function Starts the lightweight HTTP server serving the JAX-RS application."}
{"question": "default <T> ActionContext<T> schedule(final Action<T> action, final T actor) { if (isStopped()) { return Actions.emptyActionContext(); // Case of post cancel scheduling } final SchedulableActionContext<T> context = newContext(action); context.setActor(actor); context.schedule(); return unschedulableActionContext(context); // Don't allow for mutation (it's running) }", "answer": "This function Schedules an action referencing an actor for immediate execution."}
