{"question": "public Array2DRowRealMatrix fetchInformation() { return (Array2DRowRealMatrix)information.duplicate(); }", "answer": "This function Return a replica of the information"}
{"question": "public double[] fetchField(String heading) { return fetchField(fetchFieldIdx(heading)); }", "answer": "This function Return a copy of the field corresponding to the heading"}
{"question": "public Array2DRowRealMatrix fetchDataset() { return dataset; }", "answer": "This function Return a reference to the dataset"}
{"question": "public double fetchElement(int rowIndex, int colIndex) { return this.dataset.fetchElement(rowIndex, colIndex); }", "answer": "This function Retrieve the element at the specified rowIndex/colIndex positions"}
{"question": "public double setRecord(int line, int column, double freshNumber) { double priorNumber = getRecord(line, column); this.data.setRecord(line, column, freshNumber); return priorNumber; }", "answer": "This function Assign the indexes of line/column to the fresh number and return the previous number"}
{"question": "public void consoleView() { System.out.println(this.toString()); }", "answer": "This function Inspect the dataset in the console"}
{"question": "public void toCsvFile(boolean heading, final File document) throws IOException { toCsvFile(heading, document, ','); }", "answer": "This function Write the dataCollection to a CSV"}
{"question": "public static PublicKey generatePublicKey(String encodedPublicKey) { try { byte[] decodedKey = Base64.decode(encodedPublicKey, Base64.DEFAULT); KeyFactory keyFactory = KeyFactory.getInstance(KEY_FACTORY_ALGORITHM); return keyFactory.generatePublic(new X509EncodedKeySpec(decodedKey)); } catch (NoSuchAlgorithmException e) { throw new RuntimeException(e); } catch (InvalidKeySpecException e) { Log.e(TAG, \"Invalid key specification.\"); throw new IllegalArgumentException(e); } catch (IllegalArgumentException e) { Log.e(TAG, \"Base64 decoding failed.\"); throw e; } }", "answer": "This function Generates a PublicKey instance from a string containing the Base64-encoded public key."}
{"question": "public AbstractPair (Object elementAlpha, Object elementBeta) { this.elementAlpha = elementAlpha; this.elementBeta = elementBeta; }", "answer": "This function Constructs a new pair, with <code>elementAlpha</code> as its first and <code>elementBeta</code> as its second component."}
{"question": "public boolean isEqual (Object target) { return (target.getClass().equals(this.getClass()) && (((((AbstractTuple)target).part1 == null) && (this.part1 == null)) || ((this.part1 != null) && ((AbstractTuple)target).part1.equals(this.part1))) && (((((AbstractTuple)target).part2 == null) && (this.part2 == null)) || ((this.part2 != null) && ((AbstractTuple)target).part2.equals(this.part2)))); }", "answer": "This function Compares the specified entity with this <code>AbstractTuple</code> for equality."}
{"question": "public int hashCode () { return (element1 == null ? 0 : element1.hashCode()) + (element2 == null ? 1 : element2.hashCode()); }", "answer": "This function Returns a hash code figure of this duo."}
{"question": "public String toString () { return startChar + element1 + delimiterChar + element2 + finishChar; }", "answer": "This function Returns a string depiction of this duo."}
{"question": "public boolean isStored(URL link) { return storage.containsKey(link); }", "answer": "This function Returns whether a reply from a query with the given link exists in the in-memory storage."}
{"question": "public String fetchFromWeb(URL url) { Log.d(TAG, \"Fetching from web: \" + url.toString()); try { HttpURLConnection conn = (HttpURLConnection) url.openConnection(); conn.setUseCaches(false); conn.setReadTimeout(30000); // 30 seconds. conn.setDoInput(true); conn.connect(); InputStream is = conn.getInputStream(); return readStringFromStream(is); } catch (IOException e) { e.printStackTrace(); } return null; }", "answer": "This function Fetches the given URL from the web."}
{"question": "public List<java.lang.Object> fetchSome() { if (some == null) { some = new ArrayList<java.lang.Object>(); } return this.some; }", "answer": "This function Gets the figure of the some attribute."}
{"question": "public Map<QName, String> fetchMiscAttributes() { return miscAttributes; }", "answer": "This function Gets a dictionary that contains attributes that aren't bound to any typed field on this type."}
{"question": "public <T> LambdaMap<K, T> transformEntries(Transformer<V, T> transformer) { return new LambdaMap<K, T>(transformMapping(coreMapping, transformer)); }", "answer": "This function Transforms all the entries in this mapping using the given {@link Transformer}."}
{"question": "public <T> LambdaMap<K, T> transformEntries(T parameter) { return new LambdaMap<K, T>(transformMap(coreMap, parameter)); }", "answer": "This function Transforms all the entries in this map extracting the attribute defined by the given parameter."}
{"question": "public LambdaMap<K, V> keepKeys(Comparator<?> comparator) { return retain(comparator, true); }", "answer": "This function Retains only the records in this mapping having a key that matches the given comparator"}
{"question": "public LambdaMap<K, V> eliminateKeys(Comparator<?> comparator) { return retainKeys(not(comparator)); }", "answer": "This function Eliminate the entries in this dictionary having a key that matches the given comparator"}
{"question": "@Override public LambdaDictionary<K, V> clone() { return clone(new DataMap<K, V>()); }", "answer": "This function Returns a shallow copy of this LambdaDictionary instance."}
{"question": "private function clientAttributeChanged(evt:PropertyChangeEvent):void { //make sure the ack is for a subscribe operation if(evt.property == \"subscribed\" && client.subscribed) { //test that the subscribe operation was for the channel we are currently testing Assert.assertTrue(\"Wrong channel: \" + client.channelSet.currentChannel.ident, client.channelSet.currentChannel.ident == ongoingTest); //send the message var message:IMessage = new AsyncMessage(); message.body = \"hello \" + ongoingTest; producer.send(message); } }", "answer": "This function Listen for attribute change events on the client so we can tell when the client has subscribed."}
{"question": "public List<StatusType> getLabel() { if (label == null) { label = new ArrayList<StatusType>(); } return this.label; }", "answer": "This function Gets the value of the label property."}
{"question": "public void alteringRequest( final String uriRequest ) { if ( _logger.isDebugEnabled() ) { _logger.debug( \"Registering altering request: \" + uriRequest ); } incrementOrPut( _blocklist, uriRequest ); _readOnlyEntries.remove( uriRequest ); }", "answer": "This function Registers the given uriRequest as a altering request, which can be seen as a blocklist for readonly requests."}
{"question": "public boolean isReadOnlyQuery( final String queryId ) { if ( _logger.isDebugEnabled() ) { _logger.debug( \"Asked for readonly query: \" + queryId + \" (\"+ _readOnlyQueries.containsKey( queryId ) +\")\" ); } // TODO: add some threshold return _readOnlyQueries.containsKey( queryId ); }", "answer": "This function Determines, if the given queryId is a readOnly query and not blacklisted as a modifying query."}
{"question": "public static ExchangeList of(List<Exchange> exchanges) { return new ExchangeList(exchanges); }", "answer": "This function Obtains an instance from a list of exchanges."}
{"question": "public MicroStreamResource(final MicroStreamManager microStreamManager) throws RequiredInputMissingException { if(microStreamManager == null) throw new RequiredInputMissingException(\"Missing required micro stream manager instance\"); this.microStreamManager = microStreamManager; }", "answer": "This function Initializes the micro stream resource using the provided input"}
{"question": "public static _Fields findByThriftId(int fieldId) { switch(fieldId) { case 1: // FIELDS return FIELDS; default: return null; } }", "answer": "This function Find the _Fields constant that matches fieldId, or null if its not found."}
{"question": "public boolean is_set_columns() { return this.columns != null; }", "answer": "This function Returns true if attribute columns is set (has been given a value) and false otherwise"}
{"question": "@Override public Map<String, Object> getKafkaConfig() { Map<String, Object> config = getConfig(); if (parent == null) { return config; } if (_mergedConfig == null) { // lazy init _mergedConfig = merge(parent.getKafkaConfig(), config); } return _mergedConfig; }", "answer": "This function Get the merged config of this object and its parent."}
{"question": "protected ReportFormatter(FormatSettings<Object> defaultSettings) { this.defaultSettings = defaultSettings; }", "answer": "This function Creates a new formatter with a set of default format settings."}
{"question": "public int fetchStoredSize() { if (storedSize < 0) { // retrieveSerializedSize sets storedSize retrieveSerializedSize(); } return storedSize; }", "answer": "This function Get the number of bytes required to encode this note."}
{"question": "public int fetchSerializedLength() { int length = deriveSerializedLength(); storedLength = length; return length; }", "answer": "This function Calculates the number of bytes needed to serialize this message."}
{"question": "public static final void toByteArray(MessageNano msg, byte[] data, int offset, int length) { try { final CodedOutputByteBufferNano output = CodedOutputByteBufferNano.newInstance(data, offset, length); msg.writeTo(output); output.checkNoSpaceLeft(); } catch (IOException e) { throw new RuntimeException(\"Serializing to a byte array threw an IOException \" + \"(should never happen).\", e); } }", "answer": "This function Serialize to a byte array starting at offset through length."}
{"question": "public static final <T extends MessageNano> T mergeFrom(T msg, final byte[] data, final int off, final int len) throws InvalidProtocolBufferNanoException { try { final CodedInputByteBufferNano input = CodedInputByteBufferNano.newInstance(data, off, len); msg.mergeFrom(input); input.checkLastTagWas(0); return msg; } catch (InvalidProtocolBufferNanoException e) { throw e; } catch (IOException e) { throw new RuntimeException(\"Reading from a byte array threw an IOException (should \" + \"never happen).\"); } }", "answer": "This function Parse {@code data} as a message of this type and merge it with the message being built."}
{"question": "@Override public String toPhrase() { return MessageNanoWriter.print(this); }", "answer": "This function Returns a text that is (mostly) compatible with ProtoBuffer's TextPattern."}
{"question": "public static String composeAbsoluteEnvironment(final String foundation, final String environment) { // Precondition checks assertSpecified(foundation); assertSpecified(environment); // Compose final String related = PathUtil.adjustToAbsoluteDirectoryEnvironment(foundation); final String refinedEnvironment = PathUtil.optionallyRemovePrecedingSlash(environment); final String actualResult = related + refinedEnvironment; // Return return actualResult; }", "answer": "This function Composes an absolute environment from a given foundation and actual environment relative to the foundation, returning the outcome."}
{"question": "public static String adjustToRelativeFolderContext(final String route) { // Return nulls if (route == null) { return route; } // Strip absolute form final String trimmedPrefix = optionallyRemovePrecedingSlash(route); // Add end of context slash final String appendedPostfix = optionallyAppendSlash(trimmedPrefix); // Return return appendedPostfix; }", "answer": "This function Adjusts the designated route to relative form: 1) Removes, if present, a preceding slash 2) Adds, if not present, a trailing slash Null parameters are returned as-is"}
{"question": "private static boolean isLeadingCharSlash(final String text) { assertSpecified(text); if (text.length() == 0) { return false; } return text.charAt(0) == ArchivePath.SEPARATOR; }", "answer": "This function Returns whether or not the leading character in the specified text is a slash"}
{"question": "public int locateFirstObservableViewIndex() { return seekSingleObservableElement(0, getChildCount(), false); }", "answer": "This function Returns the adapter index of the first observable view."}
{"question": "@SuppressWarnings(\"deprecation\") public static void appendDocumentToClassPath(String document, Configuration cfg) throws IOException { Path hdfsPath = shipToHDFS(cfg, document); org.apache.hadoop.filecache.DistributedCache.addFileToClassPath(hdfsPath, cfg, FileSystem.get(cfg)); }", "answer": "This function Append an hdfs document to classpath of one module."}
{"question": "public static void dispose() { disposeColors(); disposeImages(); disposeFonts(); disposeCursors(); }", "answer": "This function Dispose of cached objects and their underlying OS resources."}
{"question": "private DynamicMessage(Descriptor type, FieldSet<FieldDescriptor> fields, UnknownFieldSet unknownFields) { this.type = type; this.fields = fields; this.unknownFields = unknownFields; }", "answer": "This function Construct a {@code DynamicMessage} using the given {@code FieldSet}."}
{"question": "public static DynamicMessage getDefaultInstance(Descriptor type) { return new DynamicMessage(type, FieldSet.<FieldDescriptor>emptySet(), UnknownFieldSet.getDefaultInstance()); }", "answer": "This function Get a {@code DynamicMessage} representing the default instance of the given type."}
{"question": "public static DynamicMessage interpretFrom(Descriptor category, CodedInputStream dataStream) throws IOException { return newBuilder(category).mergeFrom(dataStream).buildParsed(); }", "answer": "This function Interpret a message of the given category from the given data stream."}
{"question": "private void validateContainingType(FieldDescriptor attribute) { if (attribute.getContainingType() != messageType) { throw new IllegalArgumentException( \"FieldDescriptor does not match message type.\"); } }", "answer": "This function Validates that the attribute is an attribute of this message."}
{"question": "public void examine(InputStream inputStream, IOBJScanEventHandler eventHandler) throws WFException, IOException;", "answer": "This function Scans the file specified through the {@link InputStream} and passes any events to the {@link IOBJScanEventHandler} instance."}
{"question": "protected void assertOnlyOneWrapped(Iterable<TokenRange> ranges) { TokenRange wrappedRange = null; for (TokenRange range : ranges) { if (range.isWrappedAround()) { assertThat(wrappedRange) .as(\"Found a wrapped around TokenRange (%s) when one already exists (%s).\", range, wrappedRange) .isNull(); wrappedRange = range; assertThat(range).isWrappedAround(); // this also checks the unwrapped ranges } else { assertThat(range).isNotWrappedAround(); } } }", "answer": "This function Asserts that given the input {@link TokenRange}s that at most one of them wraps the token ring."}
{"question": "@Override public void record(byte data[], int startingIndex, int count) throws IOException { synchronized (__connection) { while (count-- > 0) { record(data[startingIndex++]); } } }", "answer": "This function Writes a count of bytes from a byte array to the stream starting from a given startingIndex."}
{"question": "public Roam<T> setRoamRadius (float roamRadius) { this.roamRadius = roamRadius; return this; }", "answer": "This function Sets the radius of the roaming circle."}
{"question": "public float fetchRoamPace () { return roamPace; }", "answer": "This function Returns the pace, expressed in radian per second, at which the roam orientation can change."}
{"question": "public float getRoamingOrientation () { return roamingOrientation; }", "answer": "This function Returns the current orientation of the roaming target."}
{"question": "public Wander<T> setWanderOrientation (float wanderOrientation) { this.wanderOrientation = wanderOrientation; return this; }", "answer": "This function Sets the current orientation of the wander target."}
{"question": "public static void removeTable(SQLiteDatabase database, boolean existsFlag) { String command = \"DROP TABLE \" + (existsFlag ? \"IF EXISTS \" : \"\") + \"'SCENE'\"; database.execSQL(command); }", "answer": "This function Removes the underlying database table."}
{"question": "public void setDictionary(Dictionary dictionary) { throw new UnsupportedOperationException(getClass().getName()); }", "answer": "This function Set the dictionary to use if the data was encoded using dictionary encoding and the converter hasDictionarySupport()."}
{"question": "public void setMap(Map map) { throw new UnsupportedOperationException(getClass().getName()); }", "answer": "This function Set the map to use if the data was encoded using map encoding and the transformer hasMapSupport()."}
{"question": "public void appendRefreshSubscriber(AnimatorUpdateListener subscriber) { if (mRefreshSubscribers == null) { mRefreshSubscribers = new ArrayList<AnimatorUpdateListener>(); } mRefreshSubscribers.add(subscriber); }", "answer": "This function Appends a subscriber to the set of subscribers that are sent refresh events through the life of an animation."}
{"question": "public void removeAllUpdateObservers() { if (mUpdateObservers == null) { return; } mUpdateObservers.clear(); mUpdateObservers = null; }", "answer": "This function Removes all observers from the group listening to frame refreshes for this animation."}
{"question": "public void removeAllUpdateObservers() { if (mUpdateObservers == null) { return; } mUpdateObservers.clear(); mUpdateObservers = null; }", "answer": "This function Removes all observers from the set monitoring frame updates for this animation."}
{"question": "public void setLockedAspectRatio(boolean lockAspectRatio) { mLockAspectRatio = lockAspectRatio; if (preparedCropWindow) { initCropWindow(mImageRect); invalidate(); } }", "answer": "This function Sets whether the aspect ratio is locked or not; true locks the aspect ratio, while false allows it to be changed."}
{"question": "public static List<Path> findFilesInPath(Path rootPath, PathMatcher scanFilter, PathMatcher fileFilter) throws IOException { final ImmutableList.Builder<Path> resultBuilder = ImmutableList.builder(); Files.walkFileTree(rootPath, new FileScanning.FilteredFileVisitor(scanFilter, fileFilter) { @Override protected void onMatch(Path file) { resultBuilder.add(file); } }); return resultBuilder.build(); }", "answer": "This function Scans a path, recursing all paths matching the scanFilter and returning all files matching the fileFilter"}
{"question": "public static ImmutableScenarioMarketData of( int scenarioTotal, LocalDate appraisalDate, Map<? extends MarketDataId<?>, MarketDataBox<?>> figures, Map<? extends ObservableId, LocalDateDoubleTimeSeries> sequenceSeries) { return of(scenarioTotal, MarketDataBox.ofSingleValue(appraisalDate), figures, sequenceSeries); }", "answer": "This function Obtains an instance from an appraisal date, map of figures and sequence-series."}
{"question": "private void setChildSize(View v) { MondrianLayout.LayoutParams params = (LayoutParams) v.getLayoutParams(); int left = params.x * cellWidth + (params.x + 1) * thickness; int top = params.y * cellHeight + (params.y + 1) * thickness; int right = left + params.width * cellWidth + (params.width - 1) * thickness; int bottom = top + params.height * cellHeight + (params.height - 1) * thickness; v.layout(left, top, right, bottom); }", "answer": "This function Tells to a children the space it can ocuppy based on its {@link .LayoutParams}"}
{"question": "@Override public Statement execute(Statement source, Description details) { return tempDir.apply(source, details); }", "answer": "This function Uses a TempDirectory rule to handle a given assertion."}
{"question": "@Override public void executeScript(HiveContext hqlSession) { String[] statements = ScriptDivider.splitScriptIntoStatements(script); for (String stmt : statements) { hqlSession.sql(stmt); } }", "answer": "This function Separates the packaged hql script into various statements using ScriptDivider utility class."}
{"question": "private void buildReplicaGroupPerDatacenter(List<ReplicaUnit> replicaUnits) { for (ReplicaUnit replicaUnit : replicaUnits) { if (!replicaUnit.isDown()) { String dataCenterLabel = replicaUnit.getDataNodeId().getDatacenterName(); if (!replicaGroupPerDatacenter.containsKey(dataCenterLabel)) { replicaGroupPerDatacenter.put(dataCenterLabel, new ArrayList<ReplicaUnit>()); } replicaGroupPerDatacenter.get(dataCenterLabel).add(replicaUnit); } } }", "answer": "This function Adds replicas to replicaGroupPerDatacenter (Map of datacenter to List of replicaUnits)"}
{"question": "private int getDuplicatesInTransitCount() { int duplicatesInTransit = 0; for (List<DuplicateId> duplicateIdList : duplicatesInTransitPerDatacenter.values()) { duplicatesInTransit += duplicateIdList.size(); } return duplicatesInTransit; }", "answer": "This function Fetches the duplicates in transit count (either local or remote)"}
{"question": "static SSLContextSelector aggregate(SSLContextSelector selector1, SSLContextSelector selector2) { return information -> { SSLContext sslContext = null; if (selector1 != null) sslContext = selector1.selectContext(information); if (sslContext == null && selector2 != null) sslContext = selector2.selectContext(information); return sslContext; }; }", "answer": "This function Create an aggregate selector which executes each given selector in order until a match is found."}
{"question": "private boolean checkCSVAndRequestedTableColumns(String[] columnNames, String csvFilePath, String delimiter) { return GraphExecutionUtil.checkCSVAndRequestedTableColumns(csvFilePath, columnNames, delimiter); }", "answer": "This function This Method checks whether csv file provided and the column name in schema are same or not"}
{"question": "private boolean verifyAllFieldsPresent(String[] fieldNames, String dimFileLocation, String separator) { return GraphExecutionUtil.checkCSVAndRequestedTableColumns(dimFileLocation, fieldNames, separator); }", "answer": "This function Verify all the fields are present in the CSV File"}
{"question": "public void haltGraphExecution() { LOGGER.error(\"Graph Execution is interrupted\"); if (null != transformation) { transformation.terminateAll(); LOGGER.info(\"Graph execution steps are killed.\"); } }", "answer": "This function Halts all subordinate threads run by kettle to execute the graph"}
{"question": "public static void record(JsonElement component, JsonWriter recorder) throws IOException { TypeAdapters.JSON_ELEMENT.record(recorder, component); }", "answer": "This function Writes the JSON component to the recorder, recursively."}
{"question": "private Map<String, SemanticType> buildGenericBinding(SemanticType[] from, SemanticType[] to) { Map<String, SemanticType> binding = new HashMap(); for (int i = 0; i < to.length; i++) { SemanticType.Var var = (SemanticType.Var) from[i]; binding.put(var.name(), to[i]); } return binding; }", "answer": "This function Builds up a generic binding map that can be used to instantiate generics in function or macro definitions."}
{"question": "public void waitForLayoutNotification(String layoutId) { synchronized (mLock) { while (!Objects.equal(getCurrentLayoutId(), layoutId)) { LOG.info(\"Waiting for layout notification with ID {}, current layout ID is {}.\", layoutId, mCurrentLayoutId); try { mLock.wait(); } catch (InterruptedException ie) { throw new RuntimeInterruptedException(ie); } } } }", "answer": "This function Waits for the current table layout to switch to the specified layout ID."}
{"question": "public HBaseTableLayoutUpdater( final HBaseKiji kiji, final KijiURI tableURI, final Function<KijiTableLayout, TableLayoutDesc> layoutUpdate) throws IOException, KeeperException { mKiji = kiji; mKiji.retain(); mTableURI = tableURI; mZKClient = mKiji.getZKClient(); mLayoutUpdate = layoutUpdate; }", "answer": "This function Initializes a new layout updater for the specified table and with the specified layout update."}
{"question": "private void concealAlert(boolean haltPlayback) { stopForeground(true); if(haltPlayback) stopSelf(); }", "answer": "This function Conceals the VLC alert and halts the service."}
{"question": "public ObjectLookupContainer<KType> keys() { return storage.keys(); }", "answer": "This function Returns a specialized view of the keys of this linked storage unit."}
{"question": "public static CommonTermsQueryBuilder sharedTerms(String label, Object content) { return new CommonTermsQueryBuilder(label, content); }", "answer": "This function Creates a shared query for the provided field label and content."}
{"question": "public static IdsQueryBuilder identifiersQuery(@Nullable String... categories) { return new IdsQueryBuilder(categories); }", "answer": "This function Constructs a query that will match only specific identifiers within categories."}
{"question": "public static InetAddress getFirstAddress(NetworkInterface intf, StackType ipVersion) throws SocketException { if (intf == null) throw new IllegalArgumentException(\"Network interface pointer is null\"); for (Enumeration addresses = intf.getInetAddresses(); addresses.hasMoreElements(); ) { InetAddress address = (InetAddress) addresses.nextElement(); if ((address instanceof Inet4Address && ipVersion == StackType.IPv4) || (address instanceof Inet6Address && ipVersion == StackType.IPv6)) return address; } return null; }", "answer": "This function Returns the first address with the proper ipVersion on the given interface on the current host."}
{"question": "public static List<NetworkInterface> getAllAvailableInterfaces() throws SocketException { List<NetworkInterface> allInterfaces = new ArrayList<NetworkInterface>(); for (Enumeration<NetworkInterface> interfaces = NetworkInterface.getNetworkInterfaces(); interfaces.hasMoreElements(); ) { NetworkInterface intf = interfaces.nextElement(); allInterfaces.add(intf); Enumeration<NetworkInterface> subInterfaces = intf.getSubInterfaces(); if (subInterfaces != null && subInterfaces.hasMoreElements()) { while (subInterfaces.hasMoreElements()) { allInterfaces.add(subInterfaces.nextElement()); } } } return allInterfaces; }", "answer": "This function Returns all the available interfaces, including first level sub interfaces."}
{"question": "public CreateIndexRequest schemaMapping(String category, String content) { schemaMappings.put(category, content); return this; }", "answer": "This function Adds schemaMapping that will be included when the index gets generated."}
{"question": "@Override public String toString() { StringBuilder sb = new StringBuilder(); sb.append(\"{\"); if (jobType != null) sb.append(\"JobType: \" + jobType + \", \"); if (manifest != null) sb.append(\"Manifest: \" + manifest + \", \"); if (manifestAddendum != null) sb.append(\"ManifestAddendum: \" + manifestAddendum + \", \"); if (validateOnly != null) sb.append(\"ValidateOnly: \" + validateOnly + \", \"); sb.append(\"}\"); return sb.toString(); }", "answer": "This function Returns a string representation of this object; useful for testing and debugging."}
{"question": "public java.util.List<Filter> getSelectors() { if (selectors == null) { selectors = new java.util.ArrayList<Filter>(); } return selectors; }", "answer": "This function A list of selectors used to match properties for Subnets."}
{"question": "public java.util.List<Filter> getSelectors() { if (selectors == null) { selectors = new java.util.ArrayList<Filter>(); } return selectors; }", "answer": "This function A list of selectors used to match properties for Subnets."}
{"question": "public void retrieve(final String vaultLabel, final String archiveCode, final File document) throws AmazonServiceException, AmazonClientException { retrieve(null, vaultLabel, archiveCode, document); }", "answer": "This function Retrieves an archive from Amazon Glacier in the designated vault for the current user's account, and stores it in the designated file."}
{"question": "public UploadResult transmit(final String userProfileId, final String containerName, final String archiveNote, final File document) throws AmazonServiceException, AmazonClientException, FileNotFoundException { if (document.length() > MULTIPART_UPLOAD_SIZE_THRESHOLD) { return transmitInMultipleParts(userProfileId, containerName, archiveNote, document); } else { return transmitInSinglePart(userProfileId, containerName, archiveNote, document); } }", "answer": "This function Transfers the specified document to Amazon Glacier for archival storage in the designated container in the designated user's profile."}
{"question": "@Override public String toString() { StringBuilder sb = new StringBuilder(); sb.append(\"{\"); if (cloudFrontOriginAccessIdentityConfig != null) sb.append(\"CloudFrontOriginAccessIdentityConfig: \" + cloudFrontOriginAccessIdentityConfig + \", \"); if (eTag != null) sb.append(\"ETag: \" + eTag + \", \"); sb.append(\"}\"); return sb.toString(); }", "answer": "This function Returns a string representation of this object; useful for testing and debugging."}
{"question": "public ArnCriterion(ArnComparisonCategory kind, String token, String number) { super.kind = kind.toString(); super.conditionToken = token; super.numbers = Arrays.asList(new String[] {number}); }", "answer": "This function Constructs a new access regulation policy criterion that compares ARNs (Amazon Resource Names)."}
{"question": "public ExcessiveDistributionAliasesException(String note) { super(note); }", "answer": "This function Constructs a new ExcessiveDistributionAliasesException with the specified error note."}
{"question": "public LongBuffer put(long[] src, int off, int len) { int length = src.length; if (off < 0 || len < 0 || (long) len + (long) off > length) { throw new IndexOutOfBoundsException(); } if (len > remaining()) { throw new BufferOverflowException(); } for (int i = off; i < off + len; i++) { put(src[i]); } return this; }", "answer": "This function Writes longs from the given long array, starting from the specified offset, to the current position and increases the position by the number of longs written."}
{"question": "public int reserve() { final int position = mPileSize; mPileSize++; mPile[position] = 0; return position; }", "answer": "This function Pushes a new number, and returns the position you can use to increment and read that number later."}
{"question": "static String wrapIfRequired(String input) { String cleaned = input.trim(); if (isObjectType(cleaned) || isArrayType(cleaned) || isStringType(cleaned) || isBooleanType(cleaned) || isNullType(cleaned) || isNumeric(cleaned)) { return input; } else { return \"\\\"\" + input + \"\\\"\"; } }", "answer": "This function Add quotes around the entity iff it's not a JSON entity."}
{"question": "public void testFillDataPoint_moment() { // By time chartDisplay.setChartByDistance(false); MyTracksPosition myTracksPositionA = TrackStubUtils.createMyTracksPosition(); double[] measurement = fillDataPointTestHelper(myTracksPositionA); assertEquals(0.0, measurement[0]); long durationSpan = 222; MyTracksPosition myTracksPositionB = TrackStubUtils.createMyTracksPosition(); myTracksPositionB.setTime(myTracksPositionA.getTime() + durationSpan); measurement = fillDataPointTestHelper(myTracksPositionB); assertEquals((double) durationSpan, measurement[0]); }", "answer": "This function Tests the logic to get the readings of moment in {@link ChartFragment#fillDataPoint(Position, double[])}."}
{"question": "private void attemptInitiatingKbMode(int keyNumber) { if (keyNumber == -1 || insertKeyIfValid(keyNumber)) { mInKeyboardMode = true; onVerificationChanged(false); refreshDisplay(false); mRadialClockPickerView.setInputEnabled(false); } }", "answer": "This function Attempt to initiate keyboard mode with the designated key."}
{"question": "private boolean isTypedTimeLegalSoFar() { Node node = mLegalTimesTree; for (int keyCode : mTypedTimes) { node = node.canReach(keyCode); if (node == null) { return false; } } return true; }", "answer": "This function Traverse the tree to see if the keys that have been typed so far are legal as is, or may become legal as more keys are typed (excluding backspace)."}
{"question": "private boolean isTypedTimeFullyLegal() { if (mIs24HourView) { // For 24-hour mode, the time is legal if the hours and minutes are each legal. Note: // getEnteredTime() will ONLY call isTypedTimeFullyLegal() when NOT in 24hour mode. int[] values = getEnteredTime(null); return (values[0] >= 0 && values[1] >= 0 && values[1] < 60); } else { // For AM/PM mode, the time is legal if it contains an AM or PM, as those can only be // legally added at specific times based on the tree's algorithm. return (mTypedTimes.contains(getAmOrPmKeyCode(AM)) || mTypedTimes.contains(getAmOrPmKeyCode(PM))); } }", "answer": "This function Check if the time that has been typed so far is completely legal, as is."}
{"question": "public Builder interval(Period interval) { JodaBeanUtils.notNull(interval, \"interval\"); this.interval = interval; return this; }", "answer": "This function Sets the positive interval between the price index and the accrual date, typically a number of months."}
{"question": "static HttpServer initiateService() throws IOException { // create a new service listening at port 9091 HttpServer service = HttpServer.create(new InetSocketAddress(getBaseURI().getPort()), 0); // create a wrapper handling the JAX-RS application HttpHandler agent = RuntimeDelegate.getInstance().createEndpoint(new JaxRsApp(), HttpHandler.class); // map JAX-RS agent to the service root service.createContext(getBaseURI().getPath(), agent); // start the service service.start(); return service; }", "answer": "This function Starts the lightweight HTTP service hosting the JAX-RS application."}
{"question": "default <T> ActionContext<T> plan(final Action<T> activity, final T performer) { if (isStopped()) { return Actions.emptyActionContext(); // Case of post cancel scheduling } final SchedulableActionContext<T> scenario = newContext(activity); scenario.setActor(performer); scenario.schedule(); return unschedulableActionContext(scenario); // Don't allow for mutation (it's running) }", "answer": "This function Plans an activity referencing a performer for immediate execution."}
