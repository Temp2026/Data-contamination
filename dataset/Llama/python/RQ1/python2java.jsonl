{"question": "def _serialize_metadata_value(value: Any) -> str: \"\"\"Safely serializes metadata values to string format. Args: value: The value to serialize. Returns: String representation of the value. \"\"\" if hasattr(value, \"model_dump\"): try: return value.model_dump(exclude_none=True, by_alias=True) except Exception as e: logger.warning(\"Failed to serialize metadata value: %s\", e) return str(value) return str(value)", "answer": "public class MetadataSerializer { private static final Logger logger = Logger.getLogger(MetadataSerializer.class.getName()); public static String serializeMetadataValue(Object value) { if (value == null) { return \"null\"; } try { Method modelDumpMethod = value.getClass().getMethod(\"modelDump\", boolean.class, boolean.class); if (modelDumpMethod != null) { try { Object result = modelDumpMethod.invoke(value, true, true); return result != null ? result.toString() : \"null\"; } catch (Exception e) { logger.warning(\"Failed to serialize metadata value: \" + e.getMessage()); return value.toString(); } } } catch (NoSuchMethodException e) { } return value.toString(); } }"}
{"question": "def _create_artifact_id( app_name: str, user_id: str, session_id: str, filename: str, version: int ) -> str: components = [app_name, user_id, session_id, filename, str(version)] return ARTIFACT_ID_SEPARATOR.join(components)", "answer": "public class ArtifactUtil { private static final String ARTIFACT_ID_SEPARATOR = \"_\"; public static String createArtifactId(String appName, String userId, String sessionId, String filename, int version) { String[] components = { appName, userId, sessionId, filename, String.valueOf(version) }; return String.join(ARTIFACT_ID_SEPARATOR, components); } }"}
{"question": "def _process_long_running_tool(a2a_part: A2APart, event: Event) -> None: if ( isinstance(a2a_part.root, DataPart) and event.long_running_tool_ids and a2a_part.root.metadata and a2a_part.root.metadata.get( _get_adk_metadata_key(A2A_DATA_PART_METADATA_TYPE_KEY) ) == A2A_DATA_PART_METADATA_TYPE_FUNCTION_CALL and a2a_part.root.data.get(\"id\") in event.long_running_tool_ids ): a2a_part.root.metadata[ _get_adk_metadata_key(A2A_DATA_PART_METADATA_IS_LONG_RUNNING_KEY) ] = True", "answer": "public class ToolProcessor { public static void processLongRunningTool(A2APart a2aPart, Event event) { if (a2aPart.getRoot() instanceof DataPart root && event.getLongRunningToolIds() != null && !event.getLongRunningToolIds().isEmpty() && root.getMetadata() != null && A2A_DATA_PART_METADATA_TYPE_FUNCTION_CALL.equals( root.getMetadata().get(getAdkMetadataKey(A2A_DATA_PART_METADATA_TYPE_KEY))) && event.getLongRunningToolIds().contains(root.getData().get(\"id\"))) { root.getMetadata().put( getAdkMetadataKey(A2A_DATA_PART_METADATA_IS_LONG_RUNNING_KEY), Boolean.TRUE ); } }"}
{"question": "def _get_user_id(request: RequestContext) -> str: if ( request.call_context and request.call_context.user and request.call_context.user.user_name ): return request.call_context.user.user_name return f'A2A_USER_{request.context_id}'", "answer": "public class UserUtil { public static String getUserId(RequestContext request) { if (request.getCallContext() != null && request.getCallContext().getUser() != null && request.getCallContext().getUser().getUserName() != null && !request.getCallContext().getUser().getUserName().isEmpty()) { return request.getCallContext().getUser().getUserName(); } return \"A2A_USER_\" + request.getContextId(); } }"}
{"question": "def _get_adk_metadata_key(key: str) -> str: if not key: raise ValueError(\"Metadata key cannot be empty or None\") return f\"{ADK_METADATA_KEY_PREFIX}{key}\"", "answer": "public class MetadataUtil { private static final String ADK_METADATA_KEY_PREFIX = \"adk_\"; // 根据实际前缀设置 public static String getAdkMetadataKey(String key) { if (key == null || key.isEmpty()) { throw new IllegalArgumentException(\"Metadata key cannot be empty or null\"); } return ADK_METADATA_KEY_PREFIX + key; } }"}
{"question": "def _to_a2a_context_id(app_name: str, user_id: str, session_id: str) -> str: if not all([app_name, user_id, session_id]): raise ValueError(\"All parameters (app_name, user_id, session_id) must be non-empty\") return ADK_CONTEXT_ID_SEPARATOR.join([ADK_CONTEXT_ID_PREFIX, app_name, user_id, session_id])", "answer": "public class ContextUtil { private static final String ADK_CONTEXT_ID_PREFIX = \"adk\"; private static final String ADK_CONTEXT_ID_SEPARATOR = \"_\"; public static String toA2AContextId(String appName, String userId, String sessionId) { if (appName == null || appName.isEmpty() || userId == null || userId.isEmpty() || sessionId == null || sessionId.isEmpty()) { throw new IllegalArgumentException(\"All parameters (appName, userId, sessionId) must be non-empty\"); } return String.join(ADK_CONTEXT_ID_SEPARATOR, ADK_CONTEXT_ID_PREFIX, appName, userId, sessionId); } }"}
{"question": "def _from_a2a_context_id(context_id: str) -> tuple[str, str, str]: if not context_id: return None, None, None try: parts = context_id.split(ADK_CONTEXT_ID_SEPARATOR) if len(parts) != 4: return None, None, None prefix, app_name, user_id, session_id = parts if prefix == ADK_CONTEXT_ID_PREFIX and app_name and user_id and session_id: return app_name, user_id, session_id except ValueError: pass return None, None, None", "answer": "public class ContextUtil { private static final String ADK_CONTEXT_ID_PREFIX = \"adk\"; private static final String ADK_CONTEXT_ID_SEPARATOR = \"_\"; public static String[] fromA2AContextId(String contextId) { if (contextId == null || contextId.isEmpty()) { return new String[]{null, null, null}; } try { String[] parts = contextId.split(ADK_CONTEXT_ID_SEPARATOR); if (parts.length != 4) { return new String[]{null, null, null}; } String prefix = parts[0]; String appName = parts[1]; String userId = parts[2]; String sessionId = parts[3]; if (ADK_CONTEXT_ID_PREFIX.equals(prefix) && appName != null && !appName.isEmpty() && userId != null && !userId.isEmpty() && sessionId != null && !sessionId.isEmpty()) { return new String[]{appName, userId, sessionId}; } } catch (Exception e) { } return new String[]{null, null, null}; } }"}
{"question": "def __init__( self, *, runner: Runner | Callable[..., Runner | Awaitable[Runner]], config: Optional[A2aAgentExecutorConfig] = None, ): super().__init__() self._runner = runner self._config = config or A2aAgentExecutorConfig()", "answer": "import java.util.concurrent.CompletableFuture; import java.util.concurrent.Future; import java.util.function.Supplier; public class AgentExecutor { private Object runner; private A2aAgentExecutorConfig config; public AgentExecutor(Object runner, A2aAgentExecutorConfig config) { this.runner = runner; this.config = config != null ? config : new A2aAgentExecutorConfig(); } public Object getRunner() { return runner; } public A2aAgentExecutorConfig getConfig() { return config; } }"}
{"question": "def _is_a2a_task(obj) -> bool: \"\"\"Check if an object is an A2A Task, with fallback for isinstance issues.\"\"\" try: return isinstance(obj, A2ATask) except (TypeError, AttributeError): return type(obj).__name__ == \"Task\" and hasattr(obj, \"status\")", "answer": "public class TaskUtil { public static boolean isA2aTask(Object obj) { if (obj == null) { return false; } try { if (obj instanceof A2ATask) { return true; } } catch (Exception e) { } try { if (\"Task\".equals(obj.getClass().getSimpleName())) { Field statusField = obj.getClass().getDeclaredField(\"status\"); return statusField != null; } } catch (NoSuchFieldException | SecurityException e) { return false; } return false; } }"}
{"question": "def _is_a2a_message(obj) -> bool: try: return isinstance(obj, A2AMessage) except (TypeError, AttributeError): return type(obj).__name__ == \"Message\" and hasattr(obj, \"role\")", "answer": "public class MessageUtil { public static boolean isA2aMessage(Object obj) { if (obj == null) { return false; } try { if (obj instanceof A2AMessage) { return true; } } catch (Exception e) { } try { if (\"Message\".equals(obj.getClass().getSimpleName())) { Field roleField = obj.getClass().getDeclaredField(\"role\"); return roleField != null; } } catch (NoSuchFieldException | SecurityException e) { return false; } return false; } }"}
{"question": "class ActiveStreamingTool(BaseModel): model_config = ConfigDict( arbitrary_types_allowed=True, extra='forbid', ) task: Optional[asyncio.Task] = None stream: Optional[LiveRequestQueue] = None", "answer": "public class ActiveStreamingTool { private Future<?> task; private LiveRequestQueue stream; public Future<?> getTask() { return task; } public void setTask(Future<?> task) { this.task = task; } public LiveRequestQueue getStream() { return stream; } public void setStream(LiveRequestQueue stream) { this.stream = stream; } }"}
{"question": "def agent_config_discriminator(v: Any) -> str: if isinstance(v, dict): agent_class: str = v.get(\"agent_class\", \"LlmAgent\") if agent_class in _ADK_AGENT_CLASSES: return agent_class return \"BaseAgent\" raise ValueError(f\"Invalid agent config: {v}\")", "answer": "public class AgentConfigUtil { private static final Set<String> ADK_AGENT_CLASSES = Set.of( \"LlmAgent\", \"SomeOtherAgent\" ); public static String agentConfigDiscriminator(Object v) { if (v instanceof Map<?, ?> map) { Object agentClassObj = map.getOrDefault(\"agent_class\", \"LlmAgent\"); String agentClass = agentClassObj != null ? agentClassObj.toString() : \"LlmAgent\"; if (ADK_AGENT_CLASSES.contains(agentClass)) { return agentClass; } return \"BaseAgent\"; } throw new IllegalArgumentException(\"Invalid agent config: \" + v); } }"}
{"question": "async def _run_async_impl( self, ctx: InvocationContext ) -> AsyncGenerator[Event, None]: raise NotImplementedError( f'_run_async_impl for {type(self)} is not implemented.' ) yield", "answer": "public abstract class Agent { public Iterator<Event> runAsyncImpl(InvocationContext ctx) { throw new UnsupportedOperationException( \"_run_async_impl for \" + this.getClass().getName() + \" is not implemented.\" ); } }"}
{"question": "def root_agent(self) -> BaseAgent: root_agent = self while root_agent.parent_agent is not None: root_agent = root_agent.parent_agent return root_agent", "answer": "public class BaseAgent { private BaseAgent parentAgent; public BaseAgent getParentAgent() { return parentAgent; } public void setParentAgent(BaseAgent parentAgent) { this.parentAgent = parentAgent; } public BaseAgent rootAgent() { BaseAgent rootAgent = this; while (rootAgent.getParentAgent() != null) { rootAgent = rootAgent.getParentAgent(); } return rootAgent; } }"}
{"question": "def find_agent(self, name: str) -> Optional[BaseAgent]: if self.name == name: return self return self.find_sub_agent(name)", "answer": "public class BaseAgent { private String name; public String getName() { return name; } public void setName(String name) { this.name = name; } public Optional<BaseAgent> findAgent(String name) { if (this.name != null && this.name.equals(name)) { return Optional.of(this); } return findSubAgent(name); }"}
{"question": "def canonical_before_agent_callbacks(self) -> list[_SingleAgentCallback]: if not self.before_agent_callback: return [] if isinstance(self.before_agent_callback, list): return self.before_agent_callback return [self.before_agent_callback]", "answer": "public class BaseAgent { private Object beforeAgentCallback; public List<_SingleAgentCallback> canonicalBeforeAgentCallbacks() { if (beforeAgentCallback == null) { return Collections.emptyList(); } if (beforeAgentCallback instanceof List<?> list) { List<_SingleAgentCallback> callbacks = new ArrayList<>(); for (Object obj : list) { if (obj instanceof _SingleAgentCallback callback) { callbacks.add(callback); } } return callbacks; } if (beforeAgentCallback instanceof _SingleAgentCallback callback) { List<_SingleAgentCallback> callbacks = new ArrayList<>(); callbacks.add(callback); return callbacks; } return Collections.emptyList(); } }"}
{"question": "def __set_parent_agent_for_sub_agents(self) -> BaseAgent: for sub_agent in self.sub_agents: if sub_agent.parent_agent is not None: raise ValueError( f'Agent `{sub_agent.name}` already has a parent agent, current' f' parent: `{sub_agent.parent_agent.name}`, trying to add:' f' `{self.name}`' ) sub_agent.parent_agent = self return self", "answer": "public class BaseAgent { private String name; private BaseAgent parentAgent; private List<BaseAgent> subAgents; public BaseAgent getParentAgent() { return parentAgent; } public void setParentAgent(BaseAgent parentAgent) { this.parentAgent = parentAgent; } public String getName() { return name; } public List<BaseAgent> getSubAgents() { return subAgents; } public BaseAgent setParentAgentForSubAgents() { if (subAgents != null) { for (BaseAgent subAgent : subAgents) { if (subAgent.getParentAgent() != null) { throw new IllegalArgumentException( \"Agent `\" + subAgent.getName() + \"` already has a parent agent, current\" + \" parent: `\" + subAgent.getParentAgent().getName() + \"`, trying to add: `\" + this.name + \"`\" ); } subAgent.setParentAgent(this); } } return this; } }"}
{"question": "def _parse_config( cls: Type[SelfAgent], config: BaseAgentConfig, config_abs_path: str, kwargs: Dict[str, Any], ) -> Dict[str, Any]: return kwargs", "answer": "public class BaseAgent { public static Map<String, Object> parseConfig( Class<? extends BaseAgent> cls, BaseAgentConfig config, String configAbsPath, Map<String, Object> kwargs) { return kwargs; } }"}
{"question": "async def list_artifacts(self) -> list[str]: if self._invocation_context.artifact_service is None: raise ValueError(\"Artifact service is not initialized.\") return await self._invocation_context.artifact_service.list_artifact_keys( app_name=self._invocation_context.app_name, user_id=self._invocation_context.user_id, session_id=self._invocation_context.session.id, )", "answer": "public class Agent { private InvocationContext invocationContext; public CompletableFuture<List<String>> listArtifacts() { if (invocationContext.getArtifactService() == null) { throw new IllegalArgumentException(\"Artifact service is not initialized.\"); } return invocationContext.getArtifactService().listArtifactKeys( invocationContext.getAppName(), invocationContext.getUserId(), invocationContext.getSession().getId() ); } }"}
{"question": "async def save_credential(self, auth_config: AuthConfig) -> None: if self._invocation_context.credential_service is None: raise ValueError(\"Credential service is not initialized.\") await self._invocation_context.credential_service.save_credential( auth_config, self )", "answer": "public class Agent { private InvocationContext invocationContext; public CompletableFuture<Void> saveCredential(AuthConfig authConfig) { if (invocationContext.getCredentialService() == null) { throw new IllegalArgumentException(\"Credential service is not initialized.\"); } return invocationContext.getCredentialService().saveCredential(authConfig, this); } }"}
{"question": "async def load_credential( self, auth_config: AuthConfig ) -> Optional[AuthCredential]: if self._invocation_context.credential_service is None: raise ValueError(\"Credential service is not initialized.\") return await self._invocation_context.credential_service.load_credential( auth_config, self )", "answer": "public async AuthCredential loadCredential(AuthConfig authConfig) { if (this.invocationContext.getCredentialService() == null) { throw new IllegalArgumentException(\"Credential service is not initialized.\"); } return await this.invocationContext.getCredentialService() .loadCredential(authConfig, this); }"}
{"question": "def validate_exactly_one_field(self) -> AgentRefConfig: code_provided = self.code is not None config_path_provided = self.config_path is not None if code_provided and config_path_provided: raise ValueError(\"Only one of `code` or `config_path` should be provided\") if not code_provided and not config_path_provided: raise ValueError(\"Exactly one of `code` or `config_path` must be provided\") return self", "answer": "public AgentRefConfig validateExactlyOneField() { boolean codeProvided = this.code != null; boolean configPathProvided = this.configPath != null; if (codeProvided && configPathProvided) { throw new IllegalArgumentException(\"Only one of `code` or `configPath` should be provided\"); } if (!codeProvided && !configPathProvided) { throw new IllegalArgumentException(\"Exactly one of `code` or `configPath` must be provided\"); } return this; }"}
{"question": "def _resolve_agent_class(agent_class: str) -> type[BaseAgent]: agent_class_name = agent_class or \"LlmAgent\" if \".\" not in agent_class_name: agent_class_name = f\"google.adk.agents.{agent_class_name}\" agent_class = resolve_fully_qualified_name(agent_class_name) if inspect.isclass(agent_class) and issubclass(agent_class, BaseAgent): return agent_class raise ValueError( f\"Invalid agent class `{agent_class_name}`. It must be a subclass of BaseAgent.\" )", "answer": "public class AgentUtil { public static Class<? extends BaseAgent> resolveAgentClass(String agentClass) { String agentClassName = (agentClass != null && !agentClass.isEmpty()) ? agentClass : \"LlmAgent\"; if (!agentClassName.contains(\".\")) { agentClassName = \"google.adk.agents.\" + agentClassName; } try { Class<?> clazz = Class.forName(agentClassName); if (BaseAgent.class.isAssignableFrom(clazz)) { @SuppressWarnings(\"unchecked\") Class<? extends BaseAgent> agentClazz = (Class<? extends BaseAgent>) clazz; return agentClazz; } else { throw new IllegalArgumentException( \"Invalid agent class `\" + agentClassName + \"`. It must be a subclass of BaseAgent.\" ); } } catch (ClassNotFoundException e) { throw new IllegalArgumentException( \"Invalid agent class `\" + agentClassName + \"`. Class not found.\", e ); } } }"}
{"question": "def _load_config_from_path(config_path: str) -> AgentConfig: if not os.path.exists(config_path): raise FileNotFoundError(f\"Config file not found: {config_path}\") with open(config_path, \"r\", encoding=\"utf-8\") as f: config_data = yaml.safe_load(f) return AgentConfig.model_validate(config_data)", "answer": "public class AgentConfigLoader { public static AgentConfig loadConfigFromPath(String configPath) throws IOException { File file = new File(configPath); if (!file.exists()) { throw new IOException(\"Config file not found: \" + configPath); } Yaml yaml = new Yaml(); try (FileInputStream fis = new FileInputStream(file)) { Object configData = yaml.load(fis); return AgentConfig.modelValidate(configData); } } }"}
{"question": "def resolve_fully_qualified_name(name: str) -> Any: try: module_path, obj_name = name.rsplit(\".\", 1) module = importlib.import_module(module_path) return getattr(module, obj_name) except Exception as e: raise ValueError(f\"Invalid fully qualified name: {name}\") from e", "answer": "public class ReflectionUtil { public static Object resolveFullyQualifiedName(String name) { try { int lastDotIndex = name.lastIndexOf('.'); if (lastDotIndex == -1) { throw new IllegalArgumentException(\"Invalid fully qualified name: \" + name); } String className = name.substring(0, lastDotIndex); String memberName = name.substring(lastDotIndex + 1); Class<?> clazz = Class.forName(className); try { return clazz.getField(memberName).get(null); } catch (NoSuchFieldException e) { return clazz.getMethod(memberName); } } catch (Exception e) { throw new IllegalArgumentException(\"Invalid fully qualified name: \" + name, e); } } }"}
{"question": "def _resolve_agent_code_reference(code: str) -> Any: if \".\" not in code: raise ValueError(f\"Invalid code reference: {code}\") module_path, obj_name = code.rsplit(\".\", 1) module = importlib.import_module(module_path) obj = getattr(module, obj_name) if callable(obj): raise ValueError(f\"Invalid agent reference to a callable: {code}\") if not isinstance(obj, BaseAgent): raise ValueError(f\"Invalid agent reference to a non-agent instance: {code}\") return obj", "answer": "public class AgentUtil { public static BaseAgent resolveAgentCodeReference(String code) { if (!code.contains(\".\")) { throw new IllegalArgumentException(\"Invalid code reference: \" + code); } int lastDotIndex = code.lastIndexOf('.'); String className = code.substring(0, lastDotIndex); String memberName = code.substring(lastDotIndex + 1); try { Class<?> clazz = Class.forName(className); Object obj; try { obj = clazz.getField(memberName).get(null); } catch (NoSuchFieldException e) { obj = clazz.getMethod(memberName); } if (obj instanceof java.lang.reflect.Method) { throw new IllegalArgumentException(\"Invalid agent reference to a callable: \" + code); } if (!(obj instanceof BaseAgent)) { throw new IllegalArgumentException(\"Invalid agent reference to a non-agent instance: \" + code); } return (BaseAgent) obj; } catch (ClassNotFoundException | IllegalAccessException | NoSuchMethodException e) { throw new IllegalArgumentException(\"Invalid agent reference: \" + code, e); } } }"}
{"question": "def resolve_code_reference(code_config: CodeConfig) -> Any: if not code_config or not code_config.name: raise ValueError(\"Invalid CodeConfig.\") module_path, obj_name = code_config.name.rsplit(\".\", 1) module = importlib.import_module(module_path) obj = getattr(module, obj_name) if code_config.args and callable(obj): kwargs = {arg.name: arg.value for arg in code_config.args if arg.name} positional_args = [arg.value for arg in code_config.args if not arg.name] return obj(*positional_args, **kwargs) else: return obj", "answer": "public class CodeResolver { public static Object resolveCodeReference(CodeConfig codeConfig) { if (codeConfig == null || codeConfig.getName() == null || codeConfig.getName().isEmpty()) { throw new IllegalArgumentException(\"Invalid CodeConfig.\"); } String fullName = codeConfig.getName(); int lastDotIndex = fullName.lastIndexOf('.'); if (lastDotIndex == -1) { throw new IllegalArgumentException(\"Invalid CodeConfig name: \" + fullName); } String className = fullName.substring(0, lastDotIndex); String memberName = fullName.substring(lastDotIndex + 1); try { Class<?> clazz = Class.forName(className); Object obj; try { obj = clazz.getField(memberName).get(null); } catch (NoSuchFieldException e) { obj = clazz.getMethod(memberName); } if (codeConfig.getArgs() != null && obj instanceof Method method) { List<Object> positionalArgs = new ArrayList<>(); Map<String, Object> kwargs = new HashMap<>(); for (CodeArg arg : codeConfig.getArgs()) { if (arg.getName() != null) { kwargs.put(arg.getName(), arg.getValue()); } else { positionalArgs.add(arg.getValue()); } } return method.invoke(null, positionalArgs.toArray()); } else { return obj; } } catch (Exception e) { throw new IllegalArgumentException(\"Failed to resolve code reference: \" + fullName, e); } } }"}
{"question": "def increment_and_enforce_llm_calls_limit( self, run_config: Optional[RunConfig] ): self._number_of_llm_calls += 1 if ( run_config and run_config.max_llm_calls > 0 and self._number_of_llm_calls > run_config.max_llm_calls ): raise LlmCallsLimitExceededError( \"Max number of llm calls limit of\" f\" `{run_config.max_llm_calls}` exceeded\" )", "answer": "public class Agent { private int numberOfLlmCalls = 0; public void incrementAndEnforceLlmCallsLimit(RunConfig runConfig) { numberOfLlmCalls += 1; if (runConfig != null && runConfig.getMaxLlmCalls() > 0 && numberOfLlmCalls > runConfig.getMaxLlmCalls()) { throw new LlmCallsLimitExceededException( \"Max number of LLM calls limit of `\" + runConfig.getMaxLlmCalls() + \"` exceeded\" ); } }"}
{"question": "def should_pause_invocation(self, event: Event) -> bool: if not self.is_resumable: return False if not event.long_running_tool_ids or not event.get_function_calls(): return False for fc in event.get_function_calls(): if fc.id in event.long_running_tool_ids: return True return False", "answer": "public class Agent { private boolean isResumable; public boolean shouldPauseInvocation(Event event) { if (!isResumable) { return false; } if (event.getLongRunningToolIds() == null || event.getLongRunningToolIds().isEmpty() || event.getFunctionCalls() == null || event.getFunctionCalls().isEmpty()) { return false; } for (FunctionCall fc : event.getFunctionCalls()) { if (event.getLongRunningToolIds().contains(fc.getId())) { return true; } } return false; }"}
{"question": "def _find_matching_function_call( self, function_response_event: Event ) -> Optional[Event]: function_responses = function_response_event.get_function_responses() if not function_responses: return None function_call_id = function_responses[0].id events = self._get_events(current_invocation=True) for event in reversed(events[:-1]): if any(fc.id == function_call_id for fc in event.get_function_calls()): return event return None", "answer": "public class Agent { public Event findMatchingFunctionCall(Event functionResponseEvent) { List<FunctionResponse> functionResponses = functionResponseEvent.getFunctionResponses(); if (functionResponses == null || functionResponses.isEmpty()) { return null; } String functionCallId = functionResponses.get(0).getId(); List<Event> events = getEvents(true); for (int i = events.size() - 2; i >= 0; i--) { // 忽略最后一个事件 Event event = events.get(i); for (FunctionCall fc : event.getFunctionCalls()) { if (fc.getId().equals(functionCallId)) { return event; } } } return null; }"}
{"question": "def _get_last_human_messages(events: list[Event]) -> list[HumanMessage]: messages = [] for event in reversed(events): if messages and event.author != 'user': break if event.author == 'user' and event.content and event.content.parts: messages.append(HumanMessage(content=event.content.parts[0].text)) return list(reversed(messages))", "answer": "public class MessageUtils { public static List<HumanMessage> getLastHumanMessages(List<Event> events) { List<HumanMessage> messages = new ArrayList<>(); for (int i = events.size() - 1; i >= 0; i--) { Event event = events.get(i); if (!messages.isEmpty() && !\"user\".equals(event.getAuthor())) { break; } if (\"user\".equals(event.getAuthor()) && event.getContent() != null && event.getContent().getParts() != null && !event.getContent().getParts().isEmpty()) { messages.add(new HumanMessage(event.getContent().getParts().get(0).getText())); } } Collections.reverse(messages); return messages; }"}
{"question": "def _get_messages( self, events: list[Event] ) -> list[Union[HumanMessage, AIMessage]]: if self.graph.checkpointer: return _get_last_human_messages(events) else: return self._get_conversation_with_agent(events)", "answer": "public class Agent { private Graph graph; public List<Message> getMessages(List<Event> events) { if (graph.getCheckpointer() != null) { return MessageUtils.getLastHumanMessages(events); } else { return getConversationWithAgent(events); } } private List<Message> getConversationWithAgent(List<Event> events) { return List.of(); }"}
{"question": "def _get_conversation_with_agent( self, events: list[Event] ) -> list[Union[HumanMessage, AIMessage]]: messages = [] for event in events: if not event.content or not event.content.parts: continue if event.author == 'user': messages.append(HumanMessage(content=event.content.parts[0].text)) elif event.author == self.name: messages.append(AIMessage(content=event.content.parts[0].text)) return messages", "answer": "public class Agent { private String name; public List<Message> getConversationWithAgent(List<Event> events) { List<Message> messages = new ArrayList<>(); for (Event event : events) { if (event.getContent() == null || event.getContent().getParts() == null || event.getContent().getParts().isEmpty()) { continue; } String text = event.getContent().getParts().get(0).getText(); if (\"user\".equals(event.getAuthor())) { messages.add(new HumanMessage(text)); } else if (name.equals(event.getAuthor())) { messages.add(new AIMessage(text)); } } return messages; } }"}
{"question": "def __init__(self): try: asyncio.get_running_loop() except RuntimeError: loop = asyncio.new_event_loop() asyncio.set_event_loop(loop) self._queue = asyncio.Queue()", "answer": "public class AsyncQueueWrapper { private final BlockingQueue<Object> queue; public AsyncQueueWrapper() { this.queue = new LinkedBlockingQueue<>(); } public void put(Object item) throws InterruptedException { queue.put(item); } public Object take() throws InterruptedException { return queue.take(); } public boolean isEmpty() { return queue.isEmpty(); } }"}
{"question": "def canonical_model(self) -> BaseLlm: if isinstance(self.model, BaseLlm): return self.model elif self.model: # model is non-empty str return LLMRegistry.new_llm(self.model) else: ancestor_agent = self.parent_agent while ancestor_agent is not None: if isinstance(ancestor_agent, LlmAgent): return ancestor_agent.canonical_model ancestor_agent = ancestor_agent.parent_agent raise ValueError(f'No model found for {self.name}.')", "answer": "public class Agent { private Object model; private Agent parentAgent; private String name; public BaseLlm canonicalModel() { if (model instanceof BaseLlm) { return (BaseLlm) model; } else if (model instanceof String && !((String) model).isEmpty()) { return LLMRegistry.newLlm((String) model); } else { Agent ancestorAgent = parentAgent; while (ancestorAgent != null) { if (ancestorAgent instanceof LlmAgent) { return ((LlmAgent) ancestorAgent).canonicalModel(); } ancestorAgent = ancestorAgent.parentAgent; } throw new IllegalStateException(\"No model found for \" + name + \".\"); } } }"}
{"question": "async def canonical_tools( self, ctx: ReadonlyContext = None ) -> list[BaseTool]: resolved_tools = [] multiple_tools = len(self.tools) > 1 for tool_union in self.tools: resolved_tools.extend( await _convert_tool_union_to_tools( tool_union, ctx, self.model, multiple_tools ) ) return resolved_tools", "answer": "public class Agent { private List<ToolUnion> tools; private Object model; public CompletableFuture<List<BaseTool>> canonicalTools(ReadonlyContext ctx) { List<BaseTool> resolvedTools = new ArrayList<>(); boolean multipleTools = tools.size() > 1; List<CompletableFuture<List<BaseTool>>> futures = new ArrayList<>(); for (ToolUnion toolUnion : tools) { futures.add(_convertToolUnionToTools(toolUnion, ctx, model, multipleTools)); } return CompletableFuture.allOf(futures.toArray(new CompletableFuture[0])) .thenApply(v -> { for (CompletableFuture<List<BaseTool>> f : futures) { try { resolvedTools.addAll(f.get()); } catch (Exception e) { throw new RuntimeException(e); } } return resolvedTools; }); } private CompletableFuture<List<BaseTool>> _convertToolUnionToTools( ToolUnion toolUnion, ReadonlyContext ctx, Object model, boolean multipleTools) { return CompletableFuture.completedFuture(new ArrayList<>()); } static class BaseTool {} static class ToolUnion {} static class ReadonlyContext {} }"}
{"question": "def canonical_before_model_callbacks( self, ) -> list[_SingleBeforeModelCallback]: if not self.before_model_callback: return [] if isinstance(self.before_model_callback, list): return self.before_model_callback return [self.before_model_callback]", "answer": "public class Agent { private Object beforeModelCallback; public List<_SingleBeforeModelCallback> canonicalBeforeModelCallbacks() { if (beforeModelCallback == null) { return new ArrayList<>(); } if (beforeModelCallback instanceof List<?>) { List<?> list = (List<?>) beforeModelCallback; List<_SingleBeforeModelCallback> result = new ArrayList<>(); for (Object obj : list) { result.add((_SingleBeforeModelCallback) obj); } return result; } else { List<_SingleBeforeModelCallback> result = new ArrayList<>(); result.add((_SingleBeforeModelCallback) beforeModelCallback); return result; } } static class _SingleBeforeModelCallback {} }"}
{"question": "def canonical_after_model_callbacks(self) -> list[_SingleAfterModelCallback]: if not self.after_model_callback: return [] if isinstance(self.after_model_callback, list): return self.after_model_callback return [self.after_model_callback]", "answer": "public class Agent { private Object afterModelCallback; public List<_SingleAfterModelCallback> canonicalAfterModelCallbacks() { if (afterModelCallback == null) { return new ArrayList<>(); } if (afterModelCallback instanceof List<?>) { List<?> list = (List<?>) afterModelCallback; List<_SingleAfterModelCallback> result = new ArrayList<>(); for (Object obj : list) { result.add((_SingleAfterModelCallback) obj); } return result; } else { List<_SingleAfterModelCallback> result = new ArrayList<>(); result.add((_SingleAfterModelCallback) afterModelCallback); return result; } } static class _SingleAfterModelCallback {} }"}
{"question": "def collect_agents(agent): agents.append(agent.name) if hasattr(agent, 'sub_agents') and agent.sub_agents: for sub_agent in agent.sub_agents: collect_agents(sub_agent) collect_agents(self.root_agent) return agents", "answer": "public class AgentCollector { private List<String> agents = new ArrayList<>(); public List<String> collectAgents(Agent rootAgent) { collectAgentsRecursive(rootAgent); return agents; } private void collectAgentsRecursive(Agent agent) { agents.add(agent.getName()); if (agent.getSubAgents() != null) { for (Agent subAgent : agent.getSubAgents()) { collectAgentsRecursive(subAgent); } } } static class Agent { private String name; private List<Agent> subAgents; public String getName() { return name; } public List<Agent> getSubAgents() { return subAgents; } } }"}
{"question": "def _parse_config( cls: type[LoopAgent], config: LoopAgentConfig, config_abs_path: str, kwargs: Dict[str, Any], ) -> Dict[str, Any]: if config.max_iterations: kwargs['max_iterations'] = config.max_iterations return kwargs", "answer": "public class LoopAgentUtils { public static Map<String, Object> parseConfig( LoopAgentConfig config, String configAbsPath, Map<String, Object> kwargs ) { if (config.getMaxIterations() != null) { kwargs.put(\"max_iterations\", config.getMaxIterations()); } return kwargs; }"}
{"question": "def _create_branch_ctx_for_sub_agent( agent: BaseAgent, sub_agent: BaseAgent, invocation_context: InvocationContext, ) -> InvocationContext: invocation_context = invocation_context.model_copy() branch_suffix = f'{agent.name}.{sub_agent.name}' invocation_context.branch = ( f'{invocation_context.branch}.{branch_suffix}' if invocation_context.branch else branch_suffix ) return invocation_context", "answer": "public class AgentUtils { public static InvocationContext createBranchCtxForSubAgent( BaseAgent agent, BaseAgent subAgent, InvocationContext invocationContext ) { InvocationContext newContext = invocationContext.modelCopy(); String branchSuffix = agent.getName() + \".\" + subAgent.getName(); if (newContext.getBranch() != null && !newContext.getBranch().isEmpty()) { newContext.setBranch(newContext.getBranch() + \".\" + branchSuffix); } else { newContext.setBranch(branchSuffix); } return newContext; } static class BaseAgent { private String name; public String getName() { return name; } } static class InvocationContext { private String branch; public InvocationContext modelCopy() { InvocationContext copy = new InvocationContext(); copy.branch = this.branch; return copy; } public String getBranch() { return branch; } public void setBranch(String branch) { this.branch = branch; } } }"}
{"question": "async def process_an_agent(events_for_one_agent): try: async for event in events_for_one_agent: resume_signal = asyncio.Event() await queue.put((event, resume_signal)) await resume_signal.wait() finally: await queue.put((sentinel, None))", "answer": "public class AgentProcessor { private final BlockingQueue<Pair<Event, CompletableFuture<Void>>> queue = new LinkedBlockingQueue<>(); private final Pair<Event, CompletableFuture<Void>> sentinel = new Pair<>(null, null); public void processAnAgent(AsyncIterable<Event> eventsForOneAgent) { CompletableFuture.runAsync(() -> { try { for (Event event : eventsForOneAgent) { // 假设 AsyncIterable 已被封装为可同步迭代 CompletableFuture<Void> resumeSignal = new CompletableFuture<>(); queue.put(new Pair<>(event, resumeSignal)); resumeSignal.get(); // 等待上游处理完成 } } catch (Exception e) { throw new RuntimeException(e); } finally { try { queue.put(sentinel); } catch (InterruptedException e) { Thread.currentThread().interrupt(); } } }); } public static class Pair<K, V> { public final K first; public final V second; public Pair(K first, V second) { this.first = first; this.second = second; } }"}
{"question": "class ParallelAgentConfig(BaseAgentConfig): model_config = ConfigDict( extra=\"forbid\", ) agent_class: str = Field( default=\"ParallelAgent\", description=\"The value is used to uniquely identify the ParallelAgent class.\", )", "answer": "public class ParallelAgentConfig extends BaseAgentConfig { private String agentClass = \"ParallelAgent\"; public String getAgentClass() { return agentClass; } public void setAgentClass(String agentClass) { this.agentClass = agentClass; } }"}
{"question": "def validate_max_llm_calls(cls, value: int) -> int: if value == sys.maxsize: raise ValueError(f'max_llm_calls should be less than {sys.maxsize}.') elif value <= 0: logger.warning( 'max_llm_calls is less than or equal to 0. This will result in' ' no enforcement on total number of llm calls that will be made for a' ' run. This may not be ideal, as this could result in a never' ' ending communication between the model and the agent in certain' ' cases.', ) return value", "answer": "public static int validateMaxLlmCalls(int value) { if (value == Integer.MAX_VALUE) { throw new IllegalArgumentException(\"max_llm_calls should be less than \" + Integer.MAX_VALUE + \".\"); } else if (value <= 0) { System.out.println( \"Warning: max_llm_calls is less than or equal to 0. This will result in \" + \"no enforcement on total number of llm calls that will be made for a run. \" + \"This may not be ideal, as this could result in a never-ending \" + \"communication between the model and the agent in certain cases.\" ); } return value; }"}
{"question": "class SequentialAgentConfig(BaseAgentConfig): model_config = ConfigDict( extra=\"forbid\", ) agent_class: str = Field( default=\"SequentialAgent\", description=\"The value is used to uniquely identify the SequentialAgent class.\", )", "answer": "public class SequentialAgentConfig extends BaseAgentConfig { private String agentClass = \"SequentialAgent\"; public SequentialAgentConfig() { } public String getAgentClass() { return agentClass; } public void setAgentClass(String agentClass) { this.agentClass = agentClass; } }"}
{"question": "def __init__( self, llm: BaseLlm, prompt_template: Optional[str] = None, ): self._llm = llm self._prompt_template = prompt_template or self._DEFAULT_PROMPT_TEMPLATE", "answer": "public class LlmEventSummarizer { private BaseLlm llm; private String promptTemplate; private static final String DEFAULT_PROMPT_TEMPLATE = \"...\"; public LlmEventSummarizer(BaseLlm llm, String promptTemplate) { this.llm = llm; this.promptTemplate = (promptTemplate != null) ? promptTemplate : DEFAULT_PROMPT_TEMPLATE; } }"}
{"question": "def _format_events_for_prompt(self, events: list[Event]) -> str: formatted_history = [] for event in events: if event.content and event.content.parts: for part in event.content.parts: if part.text: formatted_history.append(f'{event.author}: {part.text}') return '\\n'.join(formatted_history)", "answer": "public String formatEventsForPrompt(List<Event> events) { StringBuilder formattedHistory = new StringBuilder(); for (Event event : events) { if (event.getContent() != null && event.getContent().getParts() != null) { for (ContentPart part : event.getContent().getParts()) { if (part.getText() != null) { if (formattedHistory.length() > 0) { formattedHistory.append(\"\\n\"); } formattedHistory.append(event.getAuthor()).append(\": \").append(part.getText()); } } } } return formattedHistory.toString(); }"}
{"question": "def is_artifact_ref(artifact: types.Part) -> bool: return bool( artifact.file_data and artifact.file_data.file_uri and artifact.file_data.file_uri.startswith(\"artifact://\") )", "answer": "public boolean isArtifactRef(Part artifact) { return artifact.getFileData() != null && artifact.getFileData().getFileUri() != null && artifact.getFileData().getFileUri().startsWith(\"artifact://\"); }"}
{"question": "def _iter_artifact_dirs(root: Path) -> list[Path]: if not root.exists(): return [] artifact_dirs: list[Path] = [] for dirpath, dirnames, _ in os.walk(root): current = Path(dirpath) if (current / \"versions\").exists(): artifact_dirs.append(current) dirnames.clear() return artifact_dirs", "answer": "public class ArtifactUtils { public static List<File> iterArtifactDirs(File root) { List<File> artifactDirs = new ArrayList<>(); if (!root.exists() || !root.isDirectory()) { return artifactDirs; } File[] files = root.listFiles(); if (files == null) { return artifactDirs; } for (File file : files) { if (file.isDirectory()) { File versionsDir = new File(file, \"versions\"); if (versionsDir.exists() && versionsDir.isDirectory()) { artifactDirs.add(file); } else { artifactDirs.addAll(iterArtifactDirs(file)); // recursively check subdirectories } } } return artifactDirs; } }"}
{"question": "def _strip_user_namespace(filename: str) -> str: if _file_has_user_namespace(filename): return filename[len(_USER_NAMESPACE_PREFIX):] return filename", "answer": "private String stripUserNamespace(String filename) { if (fileHasUserNamespace(filename)) { return filename.substring(USER_NAMESPACE_PREFIX.length()); } return filename; }"}
{"question": "def _to_posix_path(path_value: str) -> PurePosixPath: if \"\\\\\" in path_value: path_value = PureWindowsPath(path_value).as_posix() return PurePosixPath(path_value)", "answer": "public class PathUtils { public static Path toPosixPath(String pathValue) { if (pathValue.contains(\"\\\\\")) { pathValue = pathValue.replace(\"\\\\\", \"/\"); } return Paths.get(pathValue); } }"}
{"question": "class FileArtifactVersion(ArtifactVersion): model_config = ConfigDict( alias_generator=alias_generators.to_camel, populate_by_name=True, ) file_name: str = Field( description=\"Original filename supplied by the caller.\" )", "answer": "public class FileArtifactVersion extends ArtifactVersion { private String fileName; public String getFileName() { return fileName; } public void setFileName(String fileName) { this.fileName = fileName; } }"}
{"question": "def _scope_root( self, app_name: str, user_id: str, session_id: Optional[str], filename: str, ) -> Path: base = self._base_root(app_name, user_id) if _is_user_scoped(session_id, filename): return _user_artifacts_dir(base) if not session_id: raise ValueError( \"Session ID must be provided for session-scoped artifacts.\" ) return _session_artifacts_dir(base, session_id)", "answer": "private Path scopeRoot(String appName, String userId, String sessionId, String filename) { Path base = this.baseRoot(appName, userId); if (isUserScoped(sessionId, filename)) { return userArtifactsDir(base); } if (sessionId == null || sessionId.isEmpty()) { throw new IllegalArgumentException(\"Session ID must be provided for session-scoped artifacts.\"); } return sessionArtifactsDir(base, sessionId); }"}
{"question": "def _latest_metadata(self, artifact_dir: Path) -> Optional[FileArtifactVersion]: versions = _list_versions_on_disk(artifact_dir) if not versions: return None return _read_metadata(_metadata_path(artifact_dir, versions[-1]))", "answer": "public FileArtifactVersion latestMetadata(Path artifactDir) { List<String> versions = listVersionsOnDisk(artifactDir); if (versions.isEmpty()) { return null; } return readMetadata(metadataPath(artifactDir, versions.get(versions.size() - 1))); }"}
{"question": "async def list_artifact_keys( self, *, app_name: str, user_id: str, session_id: Optional[str] = None, ) -> list[str]: return await asyncio.to_thread( self._list_artifact_keys_sync, app_name, user_id, session_id, )", "answer": "public CompletableFuture<List<String>> listArtifactKeys( String appName, String userId, @Nullable String sessionId ) { return CompletableFuture.supplyAsync(() -> _listArtifactKeysSync(appName, userId, sessionId) ); }"}
{"question": "def _delete_artifact_sync( self, app_name: str, user_id: str, filename: str, session_id: Optional[str], ) -> None: artifact_dir = self._artifact_dir( app_name=app_name, user_id=user_id, session_id=session_id, filename=filename, ) if artifact_dir.exists(): shutil.rmtree(artifact_dir) logger.debug(\"Deleted artifact %s at %s\", filename, artifact_dir)", "answer": "private void deleteArtifactSync(String appName, String userId, String filename, @Nullable String sessionId) { Path artifactDir = artifactDir(appName, userId, sessionId, filename); if (Files.exists(artifactDir)) { try { Files.walk(artifactDir) .sorted(Comparator.reverseOrder()) .forEach(path -> { try { Files.delete(path); } catch (IOException e) { throw new RuntimeException(e); } }); System.out.printf(\"Deleted artifact %s at %s%n\", filename, artifactDir); } catch (IOException e) { throw new RuntimeException(e); } } }"}
{"question": "def _read_metadata(path: Path) -> Optional[FileArtifactVersion]: if not path.exists(): return None try: return FileArtifactVersion.model_validate_json( path.read_text(encoding=\"utf-8\") ) except ValidationError as exc: logger.warning(\"Failed to parse metadata at %s: %s\", path, exc) return None except ValueError as exc: logger.warning(\"Invalid metadata JSON at %s: %s\", path, exc) return None", "answer": "public class ArtifactUtils { private static final Logger logger = Logger.getLogger(ArtifactUtils.class.getName()); public static FileArtifactVersion readMetadata(Path path) { if (!Files.exists(path)) { return null; } try { String json = Files.readString(path); return FileArtifactVersion.modelValidateJson(json); } catch (ValidationException exc) { logger.warning(String.format(\"Failed to parse metadata at %s: %s\", path, exc.getMessage())); return null; } catch (IllegalArgumentException exc) { logger.warning(String.format(\"Invalid metadata JSON at %s: %s\", path, exc.getMessage())); return null; } catch (Exception exc) { logger.warning(String.format(\"Unexpected error reading metadata at %s: %s\", path, exc.getMessage())); return null; } } }"}
{"question": "def __init__(self, bucket_name: str, **kwargs): self.bucket_name = bucket_name self.storage_client = storage.Client(**kwargs) self.bucket = self.storage_client.bucket(self.bucket_name)", "answer": "public class GcsArtifactService { private String bucketName; private Storage storageClient; private Bucket bucket; public GcsArtifactService(String bucketName, StorageOptions options) { this.bucketName = bucketName; this.storageClient = options.getService(); this.bucket = storageClient.get(bucketName); } }"}
{"question": "async def list_artifact_keys( self, *, app_name: str, user_id: str, session_id: Optional[str] = None ) -> list[str]: return await asyncio.to_thread( self._list_artifact_keys, app_name, user_id, session_id, )", "answer": "private List<String> _listArtifactKeys(String appName, String userId, String sessionId) { return List.of(); } public CompletableFuture<List<String>> listArtifactKeys(String appName, String userId, String sessionId) { return CompletableFuture.supplyAsync(() -> _listArtifactKeys(appName, userId, sessionId)); }"}
{"question": "async def delete_artifact( self, *, app_name: str, user_id: str, filename: str, session_id: Optional[str] = None, ) -> None: path = self._artifact_path(app_name, user_id, filename, session_id) if not self.artifacts.get(path): return None self.artifacts.pop(path, None)", "answer": "public class ArtifactManager { private Map<String, Object> artifacts; private String artifactPath(String appName, String userId, String filename, String sessionId) { if (sessionId != null) { return appName + \"/\" + userId + \"/\" + sessionId + \"/\" + filename; } else { return appName + \"/\" + userId + \"/\" + filename; } } public void deleteArtifact(String appName, String userId, String filename, String sessionId) { String path = artifactPath(appName, userId, filename, sessionId); if (!artifacts.containsKey(path)) { return; } artifacts.remove(path); } }"}
{"question": "async def load_credential( self, auth_config: AuthConfig, callback_context: CallbackContext, ) -> Optional[AuthCredential]: credential_bucket = self._get_bucket_for_current_context(callback_context) return credential_bucket.get(auth_config.credential_key)", "answer": "import java.util.Map; public class CredentialManager { private Map<String, AuthCredential> getBucketForCurrentContext(CallbackContext callbackContext) { return null; } public AuthCredential loadCredential(AuthConfig authConfig, CallbackContext callbackContext) { Map<String, AuthCredential> credentialBucket = getBucketForCurrentContext(callbackContext); if (credentialBucket == null) { return null; } return credentialBucket.get(authConfig.getCredentialKey()); } }"}
{"question": "async def save_credential( self, auth_config: AuthConfig, callback_context: CallbackContext, ) -> None: credential_bucket = self._get_bucket_for_current_context(callback_context) credential_bucket[auth_config.credential_key] = ( auth_config.exchanged_auth_credential )", "answer": "public class CredentialManager { private Map<String, AuthCredential> getBucketForCurrentContext(CallbackContext callbackContext) { return null; } public void saveCredential(AuthConfig authConfig, CallbackContext callbackContext) { Map<String, AuthCredential> credentialBucket = getBucketForCurrentContext(callbackContext); if (credentialBucket != null) { credentialBucket.put(authConfig.getCredentialKey(), authConfig.getExchangedAuthCredential()); } } }"}
{"question": "def _get_bucket_for_current_context( self, callback_context: CallbackContext ) -> str: app_name = callback_context._invocation_context.app_name user_id = callback_context._invocation_context.user_id if app_name not in self._credentials: self._credentials[app_name] = {} if user_id not in self._credentials[app_name]: self._credentials[app_name][user_id] = {} return self._credentials[app_name][user_id]", "answer": "public class CredentialManager { private Map<String, Map<String, Map<String, AuthCredential>>> credentials = new HashMap<>(); private Map<String, AuthCredential> getBucketForCurrentContext(CallbackContext callbackContext) { String appName = callbackContext.getInvocationContext().getAppName(); String userId = callbackContext.getInvocationContext().getUserId(); credentials.putIfAbsent(appName, new HashMap<>()); Map<String, Map<String, AuthCredential>> appMap = credentials.get(appName); appMap.putIfAbsent(userId, new HashMap<>()); return appMap.get(userId); } }"}
{"question": "def register( self, credential_type: AuthCredentialTypes, exchanger_instance: BaseCredentialExchanger, ) -> None: self._exchangers[credential_type] = exchanger_instance", "answer": "public class CredentialManager { private Map<AuthCredentialTypes, BaseCredentialExchanger> exchangers = new HashMap<>(); public void register(AuthCredentialTypes credentialType, BaseCredentialExchanger exchangerInstance) { exchangers.put(credentialType, exchangerInstance); } }"}
{"question": "def get_exchanger( self, credential_type: AuthCredentialTypes ) -> Optional[BaseCredentialExchanger]: return self._exchangers.get(credential_type)", "answer": "public class CredentialManager { private Map<AuthCredentialTypes, BaseCredentialExchanger> exchangers = new HashMap<>(); public BaseCredentialExchanger getExchanger(AuthCredentialTypes credentialType) { return exchangers.get(credentialType); } }"}
{"question": "def _normalize_auth_uri(self, auth_uri: str | None) -> str | None: if auth_uri and auth_uri.endswith(\"#\"): return auth_uri[:-1]", "answer": "public class AuthUtils { public String normalizeAuthUri(String authUri) { if (authUri != null && authUri.endsWith(\"#\")) { return authUri.substring(0, authUri.length() - 1); } return authUri; } }"}
{"question": "def from_flow(flow: OAuthFlows) -> \"OAuthGrantType\": if flow.clientCredentials: return OAuthGrantType.CLIENT_CREDENTIALS if flow.authorizationCode: return OAuthGrantType.AUTHORIZATION_CODE if flow.implicit: return OAuthGrantType.IMPLICIT if flow.password: return OAuthGrantType.PASSWORD return None", "answer": "public class OAuthUtils { public static OAuthGrantType fromFlow(OAuthFlows flow) { if (flow.isClientCredentials()) { return OAuthGrantType.CLIENT_CREDENTIALS; } if (flow.isAuthorizationCode()) { return OAuthGrantType.AUTHORIZATION_CODE; } if (flow.isImplicit()) { return OAuthGrantType.IMPLICIT; } if (flow.isPassword()) { return OAuthGrantType.PASSWORD; } return null; } }"}
{"question": "async def _load_from_credential_service( self, callback_context: CallbackContext ) -> Optional[AuthCredential]: credential_service = callback_context._invocation_context.credential_service if credential_service: return await callback_context.load_credential(self._auth_config) return None", "answer": "public class CredentialManager { private AuthConfig authConfig; public CompletableFuture<Optional<AuthCredential>> loadFromCredentialService(CallbackContext callbackContext) { CredentialService credentialService = callbackContext.getInvocationContext().getCredentialService(); if (credentialService != null) { return callbackContext.loadCredential(authConfig) .thenApply(Optional::ofNullable); } return CompletableFuture.completedFuture(Optional.empty()); } }"}
{"question": "async def _load_from_auth_response( self, callback_context: CallbackContext ) -> Optional[AuthCredential]: return callback_context.get_auth_response(self._auth_config)", "answer": "public class CredentialManager { private AuthConfig authConfig; public CompletableFuture<Optional<AuthCredential>> loadFromAuthResponse(CallbackContext callbackContext) { AuthCredential authResponse = callbackContext.getAuthResponse(authConfig); return CompletableFuture.completedFuture(Optional.ofNullable(authResponse)); } }"}
{"question": "class AuthorizationServerMetadata(BaseModel): issuer: str authorization_endpoint: str token_endpoint: str scopes_supported: Optional[List[str]] = None registration_endpoint: Optional[str] = None", "answer": "public class AuthorizationServerMetadata { private String issuer; private String authorizationEndpoint; private String tokenEndpoint; private List<String> scopesSupported; private String registrationEndpoint; public AuthorizationServerMetadata(String issuer, String authorizationEndpoint, String tokenEndpoint) { this.issuer = issuer; this.authorizationEndpoint = authorizationEndpoint; this.tokenEndpoint = tokenEndpoint; } public String getIssuer() { return issuer; } public void setIssuer(String issuer) { this.issuer = issuer; } public String getAuthorizationEndpoint() { return authorizationEndpoint; } public void setAuthorizationEndpoint(String authorizationEndpoint) { this.authorizationEndpoint = authorizationEndpoint; } public String getTokenEndpoint() { return tokenEndpoint; } public void setTokenEndpoint(String tokenEndpoint) { this.tokenEndpoint = tokenEndpoint; } public Optional<List<String>> getScopesSupported() { return Optional.ofNullable(scopesSupported); } public void setScopesSupported(List<String> scopesSupported) { this.scopesSupported = scopesSupported; } public Optional<String> getRegistrationEndpoint() { return Optional.ofNullable(registrationEndpoint); } public void setRegistrationEndpoint(String registrationEndpoint) { this.registrationEndpoint = registrationEndpoint; } }"}
{"question": "def load_test_case(test_case_dir: Path) -> TestSpec: spec_file = test_case_dir / \"spec.yaml\" with open(spec_file, \"r\", encoding=\"utf-8\") as f: data: dict[str, Any] = yaml.safe_load(f) return TestSpec.model_validate(data)", "answer": "public class TestCaseLoader { public static TestSpec loadTestCase(Path testCaseDir) throws Exception { Path specFile = testCaseDir.resolve(\"spec.yaml\"); Yaml yaml = new Yaml(); try (InputStream in = Files.newInputStream(specFile)) { Map<String, Object> data = yaml.load(in); return TestSpec.modelValidate(data); } } }"}
{"question": "def load_recorded_session(test_case_dir: Path) -> Optional[Session]: session_file = test_case_dir / \"generated-session.yaml\" if not session_file.exists(): return None with open(session_file, \"r\", encoding=\"utf-8\") as f: session_data = yaml.safe_load(f) if not session_data: return None", "answer": "public class SessionLoader { public static Optional<Session> loadRecordedSession(Path testCaseDir) throws Exception { Path sessionFile = testCaseDir.resolve(\"generated-session.yaml\"); if (!Files.exists(sessionFile)) { return Optional.empty(); } Yaml yaml = new Yaml(); try (InputStream in = Files.newInputStream(sessionFile)) { Map<String, Object> sessionData = yaml.load(in); if (sessionData == null || sessionData.isEmpty()) { return Optional.empty(); } return Optional.of(Session.fromMap(sessionData)); } } }"}
{"question": "def _generate_mismatch_message( context: str, actual_value: str, recorded_value: str ) -> str: return ( f\"{context} mismatch - \\nActual: \\n{actual_value} \\nRecorded:\" f\" \\n{recorded_value}\" )", "answer": "public class MessageUtils { public static String generateMismatchMessage(String context, String actualValue, String recordedValue) { return String.format( \"%s mismatch - %nActual: %n%s %nRecorded: %n%s\", context, actualValue, recordedValue ); } }"}
{"question": "def __init__( self, base_url: str = \"http://127.0.0.1:8000\", timeout: float = 30.0 ): self.base_url = base_url.rstrip(\"/\") self.timeout = timeout self._client: Optional[httpx.AsyncClient] = None", "answer": "public class AdkWebClient { private String baseUrl; private double timeout; private Optional<HttpClient> client; public AdkWebClient() { this(\"http://127.0.0.1:8000\", 30.0); } public AdkWebClient(String baseUrl, double timeout) { this.baseUrl = baseUrl.endsWith(\"/\") ? baseUrl.substring(0, baseUrl.length() - 1) : baseUrl; this.timeout = timeout; this.client = Optional.empty(); } public String getBaseUrl() { return baseUrl; } public double getTimeout() { return timeout; } public Optional<HttpClient> getClient() { return client; } public void setClient(HttpClient client) { this.client = Optional.of(client); } }"}
{"question": "async def _get_client(self) -> AsyncGenerator[httpx.AsyncClient, None]: if self._client is None: self._client = httpx.AsyncClient( base_url=self.base_url, timeout=httpx.Timeout(self.timeout), ) try: yield self._client finally: pass", "answer": "public class AdkWebClient { private String baseUrl; private double timeout; private HttpClient client; public CompletableFuture<HttpClient> getClient() { if (client == null) { client = HttpClient.newBuilder() .connectTimeout(Duration.ofSeconds((long) timeout)) .build(); } return CompletableFuture.completedFuture(client); } }"}
{"question": "async def close(self) -> None: if self._client: await self._client.aclose() self._client = None", "answer": "public class AdkWebClient { private HttpClient client; public CompletableFuture<Void> close() { if (client != null) { client = null; } return CompletableFuture.completedFuture(null); } }"}
{"question": "def success_rate(self) -> float: if self.total_tests == 0: return 0.0 return (self.passed_tests / self.total_tests) * 100", "answer": "public class TestMetrics { private int totalTests; private int passedTests; public double successRate() { if (totalTests == 0) { return 0.0; } return ((double) passedTests / totalTests) * 100; } public int getTotalTests() { return totalTests; } public void setTotalTests(int totalTests) { this.totalTests = totalTests; } public int getPassedTests() { return passedTests; } public void setPassedTests(int passedTests) { this.passedTests = passedTests; } }"}
{"question": "def _print_test_header(mode: str) -> None: click.echo(\"=\" * 50) click.echo(f\"Running ADK conformance tests in {mode} mode...\") click.echo(\"=\" * 50)", "answer": "public class TestUtils { public static void printTestHeader(String mode) { System.out.println(\"==================================================\"); System.out.println(\"Running ADK conformance tests in \" + mode + \" mode...\"); System.out.println(\"==================================================\"); } }"}
{"question": "def _print_test_case_result(result: _TestResult) -> None: if result.success: click.secho(\" ✓ PASS\", fg=\"green\") else: click.secho(\" ✗ FAIL\", fg=\"red\") if result.error_message: click.secho(f\"Error: {result.error_message}\", fg=\"red\", err=True)", "answer": "public class TestUtils { public static void printTestCaseResult(TestResult result) { if (result.isSuccess()) { System.out.println(\" ✓ PASS\"); } else { System.out.println(\" ✗ FAIL\"); if (result.getErrorMessage() != null && !result.getErrorMessage().isEmpty()) { System.err.println(\"Error: \" + result.getErrorMessage()); } } } }"}
{"question": "def __init__(self, *, name: str = \"adk_recordings\") -> None: super().__init__(name=name) self._invocation_states: dict[str, _InvocationRecordingState] = {}", "answer": "public class AdkRecordings extends SomeSuperClass { private Map<String, InvocationRecordingState> invocationStates; public AdkRecordings() { this(\"adk_recordings\"); } public AdkRecordings(String name) { super(name); this.invocationStates = new HashMap<>(); } public Map<String, InvocationRecordingState> getInvocationStates() { return invocationStates; } }"}
{"question": "async def before_run_callback( self, *, invocation_context: InvocationContext ) -> Optional[types.Content]: ctx = CallbackContext(invocation_context) if self._is_record_mode_on(ctx): self._create_invocation_state(ctx) return None", "answer": "public class RecordingHandler { public CompletableFuture<Optional<Content>> beforeRunCallback(InvocationContext invocationContext) { CallbackContext ctx = new CallbackContext(invocationContext); if (isRecordModeOn(ctx)) { createInvocationState(ctx); } return CompletableFuture.completedFuture(Optional.empty()); } private boolean isRecordModeOn(CallbackContext ctx) { return false; } private void createInvocationState(CallbackContext ctx) { } }"}
{"question": "class Recordings(BaseModel): model_config = ConfigDict( extra=\"forbid\", ) recordings: list[Recording] = Field(default_factory=list)", "answer": "public class Recordings { private List<Recording> recordings; public Recordings() { this.recordings = new ArrayList<>(); } public List<Recording> getRecordings() { return recordings; } public void setRecordings(List<Recording> recordings) { this.recordings = recordings; } }"}
{"question": "def __init__(self, *, name: str = \"adk_replay\") -> None: super().__init__(name=name) self._invocation_states: dict[str, _InvocationReplayState] = {}", "answer": "public class AdkReplay extends SomeSuperClass { private Map<String, InvocationReplayState> invocationStates; public AdkReplay() { this(\"adk_replay\"); } public AdkReplay(String name) { super(name); this.invocationStates = new HashMap<>(); } public Map<String, InvocationReplayState> getInvocationStates() { return invocationStates; } }"}
{"question": "async def before_run_callback( self, *, invocation_context: InvocationContext ) -> Optional[types.Content]: ctx = CallbackContext(invocation_context) if self._is_replay_mode_on(ctx): self._load_invocation_state(ctx) return None", "answer": "public class ReplayHandler { public CompletableFuture<Optional<Content>> beforeRunCallback(InvocationContext invocationContext) { CallbackContext ctx = new CallbackContext(invocationContext); if (isReplayModeOn(ctx)) { loadInvocationState(ctx); } return CompletableFuture.completedFuture(Optional.empty()); } private boolean isReplayModeOn(CallbackContext ctx) { return false; } private void loadInvocationState(CallbackContext ctx) { } }"}
{"question": "async def after_run_callback( self, *, invocation_context: InvocationContext ) -> None: ctx = CallbackContext(invocation_context) if not self._is_replay_mode_on(ctx): return None self._invocation_states.pop(ctx.invocation_id, None) logger.debug(\"Cleaned up replay state for invocation %s\", ctx.invocation_id)", "answer": "public class ReplayHandler { private static final Logger logger = Logger.getLogger(ReplayHandler.class.getName()); private Map<String, InvocationReplayState> invocationStates; public CompletableFuture<Void> afterRunCallback(InvocationContext invocationContext) { CallbackContext ctx = new CallbackContext(invocationContext); if (!isReplayModeOn(ctx)) { return CompletableFuture.completedFuture(null); } invocationStates.remove(ctx.getInvocationId()); logger.fine(\"Cleaned up replay state for invocation \" + ctx.getInvocationId()); return CompletableFuture.completedFuture(null); } private boolean isReplayModeOn(CallbackContext ctx) { return false; } }"}
{"question": "def get_finished_spans(self, session_id: str): trace_ids = self.trace_dict.get(session_id, None) if trace_ids is None or not trace_ids: return [] return [x for x in self._spans if x.context.trace_id in trace_ids]", "answer": "public class Tracer { private Map<String, List<String>> traceDict; // session_id -> trace_ids private List<Span> spans; public List<Span> getFinishedSpans(String sessionId) { List<String> traceIds = traceDict.get(sessionId); if (traceIds == null || traceIds.isEmpty()) { return new ArrayList<>(); } return spans.stream() .filter(x -> traceIds.contains(x.getContext().getTraceId())) .collect(Collectors.toList()); } }"}
{"question": "def _otel_env_vars_enabled() -> bool: return any([ os.getenv(endpoint_var) for endpoint_var in [ otel_env.OTEL_EXPORTER_OTLP_ENDPOINT, otel_env.OTEL_EXPORTER_OTLP_TRACES_ENDPOINT, otel_env.OTEL_EXPORTER_OTLP_METRICS_ENDPOINT, otel_env.OTEL_EXPORTER_OTLP_LOGS_ENDPOINT, ] ])", "answer": "public class OtelUtils { public static boolean otelEnvVarsEnabled() { String[] envVars = { OtelEnv.OTEL_EXPORTER_OTLP_ENDPOINT, OtelEnv.OTEL_EXPORTER_OTLP_TRACES_ENDPOINT, OtelEnv.OTEL_EXPORTER_OTLP_METRICS_ENDPOINT, OtelEnv.OTEL_EXPORTER_OTLP_LOGS_ENDPOINT }; return Arrays.stream(envVars) .anyMatch(var -> System.getenv(var) != null && !System.getenv(var).isEmpty()); } }"}
{"question": "def _get_project_id_and_location_from_resource_name( self, resource_name: str, pattern: str ) -> tuple[str, str]: match = re.fullmatch(pattern, resource_name) if not match: raise ValueError(f'resource name {resource_name} is not valid.') return match.groups()[0], match.groups()[1]", "answer": "public class ResourceUtils { public static class ProjectAndLocation { private final String projectId; private final String location; public ProjectAndLocation(String projectId, String location) { this.projectId = projectId; this.location = location; } public String getProjectId() { return projectId; } public String getLocation() { return location; } } public ProjectAndLocation getProjectIdAndLocationFromResourceName(String resourceName, String pattern) { Pattern regex = Pattern.compile(pattern); Matcher matcher = regex.matcher(resourceName); if (!matcher.matches()) { throw new IllegalArgumentException(\"resource name \" + resourceName + \" is not valid.\"); } return new ProjectAndLocation(matcher.group(1), matcher.group(2)); } }"}
{"question": "def get_execution_id(self) -> Optional[str]: if _SESSION_ID_KEY not in self._context: return None return self._context[_SESSION_ID_KEY]", "answer": "public class CodeExecutorHandler { private Map<String, String> context; private static final String SESSION_ID_KEY = \"_SESSION_ID_KEY\"; public Optional<String> getExecutionId() { if (!context.containsKey(SESSION_ID_KEY)) { return Optional.empty(); } return Optional.ofNullable(context.get(SESSION_ID_KEY)); } }"}
{"question": "def add_processed_file_names(self, file_names: [str]): if _PROCESSED_FILE_NAMES_KEY not in self._context: self._context[_PROCESSED_FILE_NAMES_KEY] = [] self._context[_PROCESSED_FILE_NAMES_KEY].extend(file_names)", "answer": "public class CodeExecutorHandler { private Map<String, Object> context; private static final String PROCESSED_FILE_NAMES_KEY = \"_PROCESSED_FILE_NAMES_KEY\"; @SuppressWarnings(\"unchecked\") public void addProcessedFileNames(List<String> fileNames) { if (!context.containsKey(PROCESSED_FILE_NAMES_KEY)) { context.put(PROCESSED_FILE_NAMES_KEY, new ArrayList<String>()); } ((List<String>) context.get(PROCESSED_FILE_NAMES_KEY)).addAll(fileNames); } }"}
{"question": "def increment_error_count(self, invocation_id: str): if _ERROR_COUNT_KEY not in self._session_state: self._session_state[_ERROR_COUNT_KEY] = {} self._session_state[_ERROR_COUNT_KEY][invocation_id] = ( self.get_error_count(invocation_id) + 1 )", "answer": "public class SessionHandler { private Map<String, Object> sessionState; private static final String ERROR_COUNT_KEY = \"_ERROR_COUNT_KEY\"; @SuppressWarnings(\"unchecked\") public void incrementErrorCount(String invocationId) { if (!sessionState.containsKey(ERROR_COUNT_KEY)) { sessionState.put(ERROR_COUNT_KEY, new HashMap<String, Integer>()); } Map<String, Integer> errorCounts = (Map<String, Integer>) sessionState.get(ERROR_COUNT_KEY); errorCounts.put(invocationId, getErrorCount(invocationId) + 1); } @SuppressWarnings(\"unchecked\") public int getErrorCount(String invocationId) { if (!sessionState.containsKey(ERROR_COUNT_KEY)) { return 0; } Map<String, Integer> errorCounts = (Map<String, Integer>) sessionState.get(ERROR_COUNT_KEY); return errorCounts.getOrDefault(invocationId, 0); } }"}
{"question": "def reset_error_count(self, invocation_id: str): if _ERROR_COUNT_KEY not in self._session_state: return if invocation_id in self._session_state[_ERROR_COUNT_KEY]: del self._session_state[_ERROR_COUNT_KEY][invocation_id]", "answer": "public class SessionHandler { private Map<String, Object> sessionState; private static final String ERROR_COUNT_KEY = \"_ERROR_COUNT_KEY\"; @SuppressWarnings(\"unchecked\") public void resetErrorCount(String invocationId) { if (!sessionState.containsKey(ERROR_COUNT_KEY)) { return; } Map<String, Integer> errorCounts = (Map<String, Integer>) sessionState.get(ERROR_COUNT_KEY); if (errorCounts.containsKey(invocationId)) { errorCounts.remove(invocationId); } } }"}
{"question": "def _get_code_executor_context(self, session_state: State) -> dict[str, Any]: if _CONTEXT_KEY not in session_state: session_state[_CONTEXT_KEY] = {} return session_state[_CONTEXT_KEY]", "answer": "public class CodeExecutorHandler { private static final String CONTEXT_KEY = \"_CONTEXT_KEY\"; @SuppressWarnings(\"unchecked\") public Map<String, Object> getCodeExecutorContext(State sessionState) { if (!sessionState.containsKey(CONTEXT_KEY)) { sessionState.put(CONTEXT_KEY, new HashMap<String, Object>()); } return (Map<String, Object>) sessionState.get(CONTEXT_KEY); } }"}
{"question": "def _build_docker_image(self): if not self.docker_path: raise ValueError('Docker path is not set.') if not os.path.exists(self.docker_path): raise FileNotFoundError(f'Invalid Docker path: {self.docker_path}') logger.info('Building Docker image...') self._client.images.build( path=self.docker_path, tag=self.image, rm=True, ) logger.info('Docker image: %s built.', self.image)", "answer": "public class DockerBuilder { private static final Logger logger = Logger.getLogger(DockerBuilder.class.getName()); private String dockerPath; private String image; private DockerClient client; public void buildDockerImage() throws Exception { if (dockerPath == null || dockerPath.isEmpty()) { throw new IllegalArgumentException(\"Docker path is not set.\"); } Path path = Path.of(dockerPath); if (!Files.exists(path)) { throw new IllegalArgumentException(\"Invalid Docker path: \" + dockerPath); } logger.info(\"Building Docker image...\"); client.getImages().build(dockerPath, image, true); logger.info(String.format(\"Docker image: %s built.\", image)); } }"}
{"question": "def _verify_python_installation(self): exec_result = self._container.exec_run(['which', 'python3']) if exec_result.exit_code != 0: raise ValueError('python3 is not installed in the container.')", "answer": "public class ContainerVerifier { private Container container; public void verifyPythonInstallation() { ExecResult execResult = container.execRun(new String[]{\"which\", \"python3\"}); if (execResult.getExitCode() != 0) { throw new IllegalStateException(\"python3 is not installed in the container.\"); } } }"}
{"question": "def __init__(self, **data): if 'stateful' in data and data['stateful']: raise ValueError('Cannot set `stateful=True` in UnsafeLocalCodeExecutor.') if 'optimize_data_file' in data and data['optimize_data_file']: raise ValueError( 'Cannot set `optimize_data_file=True` in UnsafeLocalCodeExecutor.' ) super().__init__(**data)", "answer": "public class UnsafeLocalCodeExecutor extends BaseCodeExecutor { public UnsafeLocalCodeExecutor(Map<String, Object> data) { if (data.containsKey(\"stateful\") && Boolean.TRUE.equals(data.get(\"stateful\"))) { throw new IllegalArgumentException(\"Cannot set `stateful=True` in UnsafeLocalCodeExecutor.\"); } if (data.containsKey(\"optimize_data_file\") && Boolean.TRUE.equals(data.get(\"optimize_data_file\"))) { throw new IllegalArgumentException( \"Cannot set `optimize_data_file=True` in UnsafeLocalCodeExecutor.\" ); } super(data); } }"}
{"question": "def __init__(self, message=\"The requested item was not found.\"): self.message = message super().__init__(self.message)", "answer": "public class ItemNotFoundException extends Exception { public ItemNotFoundException() { super(\"The requested item was not found.\"); } public ItemNotFoundException(String message) { super(message); } }"}
{"question": "def create_eval_set_result( app_name: str, eval_set_id: str, eval_case_results: list[EvalCaseResult], ) -> EvalSetResult: timestamp = time.time() eval_set_result_id = f\"{app_name}_{eval_set_id}_{timestamp}\" eval_set_result_name = _sanitize_eval_set_result_name(eval_set_result_id) eval_set_result = EvalSetResult( eval_set_result_id=eval_set_result_id, eval_set_result_name=eval_set_result_name, eval_set_id=eval_set_id, eval_case_results=eval_case_results, creation_timestamp=timestamp, ) return eval_set_result", "answer": "public class EvalSetUtils { public static EvalSetResult createEvalSetResult( String appName, String evalSetId, List<EvalCaseResult> evalCaseResults ) { long timestamp = System.currentTimeMillis() / 1000; String evalSetResultId = appName + \"_\" + evalSetId + \"_\" + timestamp; String evalSetResultName = sanitizeEvalSetResultName(evalSetResultId); EvalSetResult evalSetResult = new EvalSetResult( evalSetResultId, evalSetResultName, evalSetId, evalCaseResults, timestamp ); return evalSetResult; } private static String sanitizeEvalSetResultName(String name) { return name.replaceAll(\"[^a-zA-Z0-9_\\\\-]\", \"_\"); } }"}
{"question": "def get_eval_set_from_app_and_id( eval_sets_manager: EvalSetsManager, app_name: str, eval_set_id: str ) -> EvalSet: eval_set = eval_sets_manager.get_eval_set(app_name, eval_set_id) if not eval_set: raise NotFoundError(f\"Eval set `{eval_set_id}` not found.\") return eval_set", "answer": "public class EvalSetUtils { public static EvalSet getEvalSetFromAppAndId(EvalSetsManager evalSetsManager, String appName, String evalSetId) throws NotFoundException { EvalSet evalSet = evalSetsManager.getEvalSet(appName, evalSetId); if (evalSet == null) { throw new NotFoundException(\"Eval set `\" + evalSetId + \"` not found.\"); } return evalSet; } }"}
{"question": "def get_eval_case_from_eval_set( eval_set: EvalSet, eval_case_id: str ) -> Optional[EvalCase]: eval_case_to_find = None for eval_case in eval_set.eval_cases: if eval_case.eval_id == eval_case_id: eval_case_to_find = eval_case break return eval_case_to_find", "answer": "public class EvalSetUtils { public static Optional<EvalCase> getEvalCaseFromEvalSet(EvalSet evalSet, String evalCaseId) { if (evalSet == null || evalSet.getEvalCases() == null) { return Optional.empty(); } for (EvalCase evalCase : evalSet.getEvalCases()) { if (evalCaseId.equals(evalCase.getEvalId())) { return Optional.of(evalCase); } } return Optional.empty(); } }"}
