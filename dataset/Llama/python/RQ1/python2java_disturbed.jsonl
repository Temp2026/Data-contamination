{"question": "def _encode_data_item(item: Any) -> str: \"\"\"Safely encodes data items to string format. Args: item: The item to encode. Returns: String representation of the item. \"\"\" if hasattr(item, \"model_dump\"): try: return item.model_dump(exclude_none=True, by_alias=True) except Exception as ex: log.warning(\"Failed to encode data item: %s\", ex) return str(item) return str(item)", "answer": "public class DataEncoder { private static final Logger log = Logger.getLogger(DataEncoder.class.getName()); public static String encodeDataItem(Object item) { if (item == null) { return \"null\"; } try { Method dumpFunc = item.getClass().getMethod(\"modelDump\", boolean.class, boolean.class); if (dumpFunc != null) { try { Object output = dumpFunc.invoke(item, true, true); return output != null ? output.toString() : \"null\"; } catch (Exception ex) { log.warning(\"Failed to encode data item: \" + ex.getMessage()); return item.toString(); } } } catch (NoSuchMethodException ex) { } return item.toString(); } }"}
{"question": "def _build_resource_id( project_name: str, owner_id: str, context_id: str, filepath: str, revision: int ) -> str: parts = [project_name, owner_id, context_id, filepath, str(revision)] return RESOURCE_ID_DELIMITER.join(parts)", "answer": "public class ResourceBuilder { private static final String RESOURCE_ID_DELIMITER = \"_\"; public static String buildResourceId(String projectName, String ownerId, String contextId, String filepath, int revision) { String[] parts = { projectName, ownerId, contextId, filepath, String.valueOf(revision) }; return String.join(RESOURCE_ID_DELIMITER, parts); } }"}
{"question": "def _handle_extended_operation(a2a_section: A2APart, occurrence: Event) -> None: if ( isinstance(a2a_section.root, DataPart) and occurrence.extended_operation_ids and a2a_section.root.metadata and a2a_section.root.metadata.get( _get_adk_metadata_key(A2A_DATA_PART_METADATA_TYPE_KEY) ) == A2A_DATA_PART_METADATA_TYPE_FUNCTION_CALL and a2a_section.root.data.get(\"id\") in occurrence.extended_operation_ids ): a2a_section.root.metadata[ _get_adk_metadata_key(A2A_DATA_PART_METADATA_IS_EXTENDED_OPERATION_KEY) ] = True", "answer": "public class OperationHandler { public static void handleExtendedOperation(A2APart a2aSection, Event occurrence) { if (a2aSection.getRoot() instanceof DataPart core && occurrence.getExtendedOperationIds() != null && !occurrence.getExtendedOperationIds().isEmpty() && core.getMetadata() != null && A2A_DATA_PART_METADATA_TYPE_FUNCTION_CALL.equals( core.getMetadata().get(getAdkMetadataKey(A2A_DATA_PART_METADATA_TYPE_KEY))) && occurrence.getExtendedOperationIds().contains(core.getData().get(\"id\"))) { core.getMetadata().put( getAdkMetadataKey(A2A_DATA_PART_METADATA_IS_EXTENDED_OPERATION_KEY), Boolean.TRUE ); } } }"}
{"question": "def _retrieve_user_identifier(ctx: RequestContext) -> str: if ( ctx.call_context and ctx.call_context.user and ctx.call_context.user.user_name ): return ctx.call_context.user.user_name return f'A2A_USER_{ctx.context_id}'", "answer": "public class IdentityHelper { public static String retrieveUserIdentifier(RequestContext ctx) { if (ctx.getCallContext() != null && ctx.getCallContext().getUser() != null && ctx.getCallContext().getUser().getUserName() != null && !ctx.getCallContext().getUser().getUserName().isEmpty()) { return ctx.getCallContext().getUser().getUserName(); } return \"A2A_USER_\" + ctx.getContextId(); } }"}
{"question": "def _generate_adk_metadata_key(identifier: str) -> str: if not identifier: raise ValueError(\"Metadata identifier cannot be empty or None\") return f\"{ADK_METADATA_KEY_PREFIX}{identifier}\"", "answer": "public class MetadataHelper { private static final String ADK_METADATA_KEY_PREFIX = \"adk_\"; // 根据实际前缀设置 public static String generateAdkMetadataKey(String identifier) { if (identifier == null || identifier.isEmpty()) { throw new IllegalArgumentException(\"Metadata identifier cannot be empty or null\"); } return ADK_METADATA_KEY_PREFIX + identifier; } }"}
{"question": "def _create_a2a_context_identifier(project_name: str, owner_id: str, session_identifier: str) -> str: if not all([project_name, owner_id, session_identifier]): raise ValueError(\"All parameters (project_name, owner_id, session_identifier) must be non-empty\") return ADK_CONTEXT_ID_SEPARATOR.join([ADK_CONTEXT_ID_PREFIX, project_name, owner_id, session_identifier])", "answer": "public class ContextHelper { private static final String ADK_CONTEXT_ID_PREFIX = \"adk\"; private static final String ADK_CONTEXT_ID_SEPARATOR = \"_\"; public static String createA2AContextIdentifier(String projectName, String ownerId, String sessionIdentifier) { if (projectName == null || projectName.isEmpty() || ownerId == null || ownerId.isEmpty() || sessionIdentifier == null || sessionIdentifier.isEmpty()) { throw new IllegalArgumentException(\"All parameters (projectName, ownerId, sessionIdentifier) must be non-empty\"); } return String.join(ADK_CONTEXT_ID_SEPARATOR, ADK_CONTEXT_ID_PREFIX, projectName, ownerId, sessionIdentifier); } }"}
{"question": "def _parse_a2a_context_identifier(ctx_identifier: str) -> tuple[str, str, str]: if not ctx_identifier: return None, None, None try: segments = ctx_identifier.split(ADK_CONTEXT_ID_SEPARATOR) if len(segments) != 4: return None, None, None prefix, project_name, owner_id, session_identifier = segments if prefix == ADK_CONTEXT_ID_PREFIX and project_name and owner_id and session_identifier: return project_name, owner_id, session_identifier except ValueError: pass return None, None, None", "answer": "public class ContextHelper { private static final String ADK_CONTEXT_ID_PREFIX = \"adk\"; private static final String ADK_CONTEXT_ID_SEPARATOR = \"_\"; public static String[] parseA2AContextIdentifier(String ctxIdentifier) { if (ctxIdentifier == null || ctxIdentifier.isEmpty()) { return new String[]{null, null, null}; } try { String[] segments = ctxIdentifier.split(ADK_CONTEXT_ID_SEPARATOR); if (segments.length != 4) { return new String[]{null, null, null}; } String prefix = segments[0]; String projectName = segments[1]; String ownerId = segments[2]; String sessionIdentifier = segments[3]; if (ADK_CONTEXT_ID_PREFIX.equals(prefix) && projectName != null && !projectName.isEmpty() && ownerId != null && !ownerId.isEmpty() && sessionIdentifier != null && !sessionIdentifier.isEmpty()) { return new String[]{projectName, ownerId, sessionIdentifier}; } } catch (Exception ex) { // Ignore } return new String[]{null, null, null}; } }"}
{"question": "def __init__( self, *, runner: Runner | Callable[..., Runner | Awaitable[Runner]], config: Optional[A2aAgentExecutorConfig] = None, ): super().__init__() self._runner = runner self._config = config or A2aAgentExecutorConfig()", "answer": "import java.util.concurrent.CompletableFuture; import java.util.concurrent.Future; import java.util.function.Supplier; public class AgentExecutor { private Object runner; private A2aAgentExecutorConfig config; public AgentExecutor(Object runner, A2aAgentExecutorConfig config) { this.runner = runner; this.config = config != null ? config : new A2aAgentExecutorConfig(); } public Object getRunner() { return runner; } public A2aAgentExecutorConfig getConfig() { return config; } }"}
{"question": "def _check_if_a2a_job(item) -> bool: \"\"\"Verify if an object is an A2A Job, with fallback for isinstance issues.\"\"\" try: return isinstance(item, A2ATask) except (TypeError, AttributeError): return type(item).__name__ == \"Task\" and hasattr(item, \"status\")", "answer": "public class TaskHelper { public static boolean checkIfA2aJob(Object item) { if (item == null) { return false; } try { if (item instanceof A2ATask) { return true; } } catch (Exception ex) { // Ignore } try { // Fallback check if (\"Task\".equals(item.getClass().getSimpleName())) { Field statusField = item.getClass().getDeclaredField(\"status\"); return statusField != null; } } catch (NoSuchFieldException | SecurityException ex) { return false; } return false; } }"}
{"question": "def _verify_if_a2a_notification(item) -> bool: try: return isinstance(item, A2AMessage) except (TypeError, AttributeError): return type(item).__name__ == \"Message\" and hasattr(item, \"role\")", "answer": "public class MessageHelper { public static boolean verifyIfA2aNotification(Object item) { if (item == null) { return false; } try { if (item instanceof A2AMessage) { return true; } } catch (Exception ex) { } try { if (\"Message\".equals(item.getClass().getSimpleName())) { Field roleField = item.getClass().getDeclaredField(\"role\"); return roleField != null; } } catch (NoSuchFieldException | SecurityException ex) { return false; } return false; } }"}
{"question": "class ActiveStreamingHandler(BaseModel): model_config = ConfigDict( arbitrary_types_allowed=True, extra='forbid', ) operation: Optional[asyncio.Task] = None channel: Optional[LiveRequestQueue] = None", "answer": "public class ActiveStreamingHandler { private Future<?> operation; private LiveRequestQueue channel; public Future<?> getOperation() { return operation; } public void setOperation(Future<?> operation) { this.operation = operation; } public LiveRequestQueue getChannel() { return channel; } public void setChannel(LiveRequestQueue channel) { this.channel = channel; } }"}
{"question": "def determine_agent_config_type(config: Any) -> str: if isinstance(config, dict): agent_type: str = config.get(\"agent_class\", \"LlmAgent\") if agent_type in _ADK_AGENT_CLASSES: return agent_type return \"BaseAgent\" raise ValueError(f\"Invalid agent configuration: {config}\")", "answer": "public class AgentConfigHelper { private static final Set<String> ADK_AGENT_CLASSES = Set.of( \"LlmAgent\", \"SomeOtherAgent\" ); public static String determineAgentConfigType(Object config) { if (config instanceof Map<?, ?> map) { Object agentTypeObj = map.getOrDefault(\"agent_class\", \"LlmAgent\"); String agentType = agentTypeObj != null ? agentTypeObj.toString() : \"LlmAgent\"; if (ADK_AGENT_CLASSES.contains(agentType)) { return agentType; } return \"BaseAgent\"; } throw new IllegalArgumentException(\"Invalid agent configuration: \" + config); } }"}
{"question": "async def _execute_async_implementation( self, context: InvocationContext ) -> AsyncGenerator[Event, None]: raise NotImplementedError( f'_execute_async_implementation for {type(self)} is not implemented.' ) yield", "answer": "public abstract class Agent { public Iterator<Event> executeAsyncImplementation(InvocationContext context) { throw new UnsupportedOperationException( \"_execute_async_implementation for \" + this.getClass().getName() + \" is not implemented.\" ); } }"}
{"question": "def main_agent(self) -> BaseAgent: main_agent = self while main_agent.super_agent is not None: main_agent = main_agent.super_agent return main_agent", "answer": "public class BaseAgent { private BaseAgent superAgent; public BaseAgent getSuperAgent() { return superAgent; } public void setSuperAgent(BaseAgent superAgent) { this.superAgent = superAgent; } public BaseAgent mainAgent() { BaseAgent mainAgent = this; while (mainAgent.getSuperAgent() != null) { mainAgent = mainAgent.getSuperAgent(); } return mainAgent; } }"}
{"question": "def locate_agent(self, target_name: str) -> Optional[BaseAgent]: if self.identifier == target_name: return self return self.locate_sub_agent(target_name)", "answer": "public class BaseAgent { private String identifier; public String getIdentifier() { return identifier; } public void setIdentifier(String identifier) { this.identifier = identifier; } public Optional<BaseAgent> locateAgent(String targetName) { if (this.identifier != null && this.identifier.equals(targetName)) { return Optional.of(this); } return locateSubAgent(targetName); } }"}
{"question": "def standard_pre_agent_callbacks(self) -> list[_SingleAgentCallback]: if not self.pre_agent_callback: return [] if isinstance(self.pre_agent_callback, list): return self.pre_agent_callback return [self.pre_agent_callback]", "answer": "public class BaseAgent { private Object preAgentCallback; public List<_SingleAgentCallback> standardPreAgentCallbacks() { if (preAgentCallback == null) { return Collections.emptyList(); } if (preAgentCallback instanceof List<?> list) { List<_SingleAgentCallback> handlers = new ArrayList<>(); for (Object obj : list) { if (obj instanceof _SingleAgentCallback handler) { handlers.add(handler); } } return handlers; } if (preAgentCallback instanceof _SingleAgentCallback handler) { List<_SingleAgentCallback> handlers = new ArrayList<>(); handlers.add(handler); return handlers; } return Collections.emptyList(); } }"}
{"question": "def __assign_parent_agent_to_child_agents(self) -> BaseAgent: for child_agent in self.child_agents: if child_agent.parent_agent is not None: raise ValueError( f'Agent `{child_agent.agent_name}` already has a parent agent, current' f' parent: `{child_agent.parent_agent.agent_name}`, trying to add:' f' `{self.agent_name}`' ) child_agent.parent_agent = self return self", "answer": "public class BaseAgent { private String agentName; private BaseAgent parentAgent; private List<BaseAgent> childAgents; public BaseAgent getParentAgent() { return parentAgent; } public void setParentAgent(BaseAgent parentAgent) { this.parentAgent = parentAgent; } public String getAgentName() { return agentName; } public List<BaseAgent> getChildAgents() { return childAgents; } public BaseAgent assignParentAgentToChildAgents() { if (childAgents != null) { for (BaseAgent childAgent : childAgents) { if (childAgent.getParentAgent() != null) { throw new IllegalArgumentException( \"Agent `\" + childAgent.getAgentName() + \"` already has a parent agent, current\" + \" parent: `\" + childAgent.getParentAgent().getAgentName() + \"`, trying to add: `\" + this.agentName + \"`\" ); } childAgent.setParentAgent(this); } } return this; } }"}
{"question": "def _parse_settings( agent_cls: Type[SelfAgent], agent_cfg: BaseAgentConfig, config_abs_path: str, args_map: Dict[str, Any], ) -> Dict[str, Any]: return args_map", "answer": "public class BaseAgent { public static Map<String, Object> parseSettings( Class<? extends BaseAgent> agentCls, BaseAgentConfig agentCfg, String configAbsPath, Map<String, Object> argsMap) { return argsMap; } }"}
{"question": "async def list_artifacts(self) -> list[str]: if self._invocation_ctx.artifact_service is None: raise ValueError(\"Artifact service is not initialized.\") return await self._invocation_ctx.artifact_service.list_artifact_keys( app_name=self._invocation_ctx.app_name, user_id=self._invocation_ctx.user_id, session_id=self._invocation_ctx.session.id, )", "answer": "public class Agent { private InvocationContext invocationCtx; public CompletableFuture<List<String>> listArtifacts() { if (invocationCtx.getArtifactService() == null) { throw new IllegalArgumentException(\"Artifact service is not initialized.\"); } return invocationCtx.getArtifactService().listArtifactKeys( invocationCtx.getAppName(), invocationCtx.getUserId(), invocationCtx.getSession().getId() ); } }"}
{"question": "async def store_credential(self, auth_cfg: AuthConfig) -> None: if self._invocation_ctx.credential_service is None: raise ValueError(\"Credential service is not initialized.\") await self._invocation_ctx.credential_service.store_credential( auth_cfg, self )", "answer": "public class Agent { private InvocationContext invocationCtx; public CompletableFuture<Void> storeCredential(AuthConfig authCfg) { if (invocationCtx.getCredentialService() == null) { throw new IllegalArgumentException(\"Credential service is not initialized.\"); } return invocationCtx.getCredentialService().storeCredential(authCfg, this); } }"}
{"question": "async def fetch_credential( self, auth_cfg: AuthConfig ) -> Optional[AuthCredential]: if self._invocation_ctx.credential_service is None: raise ValueError(\"Credential service is not initialized.\") return await self._invocation_ctx.credential_service.fetch_credential( auth_cfg, self )", "answer": "public async AuthCredential fetchCredential(AuthConfig authCfg) { if (this.invocationCtx.getCredentialService() == null) { throw new IllegalArgumentException(\"Credential service is not initialized.\"); } return await this.invocationCtx.getCredentialService() .fetchCredential(authCfg, this); }"}
{"question": "def verify_exactly_one_field(self) -> AgentRefConfig: has_code = self.code is not None has_config_path = self.config_path is not None if has_code and has_config_path: raise ValueError(\"Only one of `code` or `config_path` should be provided\") if not has_code and not has_config_path: raise ValueError(\"Exactly one of `code` or `config_path` must be provided\") return self", "answer": "public AgentRefConfig verifyExactlyOneField() { boolean hasCode = this.code != null; boolean hasConfigPath = this.configPath != null; if (hasCode && hasConfigPath) { throw new IllegalArgumentException(\"Only one of `code` or `configPath` should be provided\"); } if (!hasCode && !hasConfigPath) { throw new IllegalArgumentException(\"Exactly one of `code` or `configPath` must be provided\"); } return this; }"}
{"question": "def _determine_agent_type(agent_type: str) -> type[BaseAgent]: agent_type_name = agent_type or \"LlmAgent\" if \".\" not in agent_type_name: agent_type_name = f\"google.adk.agents.{agent_type_name}\" agent_class = resolve_fully_qualified_name(agent_type_name) if inspect.isclass(agent_class) and issubclass(agent_class, BaseAgent): return agent_class raise ValueError( f\"Invalid agent type `{agent_type_name}`. It must be a subclass of BaseAgent.\" )", "answer": "public class AgentUtil { public static Class<? extends BaseAgent> determineAgentType(String agentType) { String agentTypeName = (agentType != null && !agentType.isEmpty()) ? agentType : \"LlmAgent\"; if (!agentTypeName.contains(\".\")) { agentTypeName = \"google.adk.agents.\" + agentTypeName; } try { Class<?> cls = Class.forName(agentTypeName); if (BaseAgent.class.isAssignableFrom(cls)) { @SuppressWarnings(\"unchecked\") Class<? extends BaseAgent> agentClass = (Class<? extends BaseAgent>) cls; return agentClass; } else { throw new IllegalArgumentException( \"Invalid agent type `\" + agentTypeName + \"`. It must be a subclass of BaseAgent.\" ); } } catch (ClassNotFoundException e) { throw new IllegalArgumentException( \"Invalid agent type `\" + agentTypeName + \"`. Class not found.\", e ); } } }"}
{"question": "def _read_config_from_path(config_file_path: str) -> AgentConfig: if not os.path.exists(config_file_path): raise FileNotFoundError(f\"Config file not found: {config_file_path}\") with open(config_file_path, \"r\", encoding=\"utf-8\") as f: config_obj = yaml.safe_load(f) return AgentConfig.model_validate(config_obj)", "answer": "public class AgentConfigLoader { public static AgentConfig readConfigFromPath(String configFilePath) throws IOException { File configFile = new File(configFilePath); if (!configFile.exists()) { throw new IOException(\"Config file not found: \" + configFilePath); } Yaml yamlParser = new Yaml(); try (FileInputStream fis = new FileInputStream(configFile)) { Object configObj = yamlParser.load(fis); return AgentConfig.modelValidate(configObj); } } }"}
{"question": "def resolve_fully_qualified_name(fq_name: str) -> Any: try: module_path, obj_name = fq_name.rsplit(\".\", 1) module = importlib.import_module(module_path) return getattr(module, obj_name) except Exception as e: raise ValueError(f\"Invalid fully qualified name: {fq_name}\") from e", "answer": "public class ReflectionUtil { public static Object resolveFullyQualifiedName(String fqName) { try { int lastDotPos = fqName.lastIndexOf('.'); if (lastDotPos == -1) { throw new IllegalArgumentException(\"Invalid fully qualified name: \" + fqName); } String className = fqName.substring(0, lastDotPos); String memberName = fqName.substring(lastDotPos + 1); Class<?> cls = Class.forName(className); try { return cls.getField(memberName).get(null); } catch (NoSuchFieldException e) { return cls.getMethod(memberName); } } catch (Exception e) { throw new IllegalArgumentException(\"Invalid fully qualified name: \" + fqName, e); } } }"}
{"question": "def _resolve_agent_code_ref(ref: str) -> Any: if \".\" not in ref: raise ValueError(f\"Invalid code reference: {ref}\") module_path, obj_name = ref.rsplit(\".\", 1) module = importlib.import_module(module_path) obj = getattr(module, obj_name) if callable(obj): raise ValueError(f\"Invalid agent reference to a callable: {ref}\") if not isinstance(obj, BaseAgent): raise ValueError(f\"Invalid agent reference to a non-agent instance: {ref}\") return obj", "answer": "public class AgentUtil { public static BaseAgent resolveAgentCodeRef(String ref) { if (!ref.contains(\".\")) { throw new IllegalArgumentException(\"Invalid code reference: \" + ref); } int lastDotPos = ref.lastIndexOf('.'); String clsName = ref.substring(0, lastDotPos); String memberName = ref.substring(lastDotPos + 1); try { Class<?> cls = Class.forName(clsName); Object obj; try { obj = cls.getField(memberName).get(null); } catch (NoSuchFieldException e) { obj = cls.getMethod(memberName); } if (obj instanceof java.lang.reflect.Method) { throw new IllegalArgumentException(\"Invalid agent reference to a callable: \" + ref); } if (!(obj instanceof BaseAgent)) { throw new IllegalArgumentException(\"Invalid agent reference to a non-agent instance: \" + ref); } return (BaseAgent) obj; } catch (ClassNotFoundException | IllegalAccessException | NoSuchMethodException e) { throw new IllegalArgumentException(\"Invalid agent reference: \" + ref, e); } } }"}
{"question": "def determine_code_reference(configuration: CodeConfiguration) -> Any: if not configuration or not configuration.name: raise ValueError(\"Invalid CodeConfiguration.\") module_path, object_name = configuration.name.rsplit(\".\", 1) module = importlib.import_module(module_path) instance = getattr(module, object_name) if configuration.arguments and callable(instance): keyword_arguments = {argument.name: argument.value for argument in configuration.arguments if argument.name} positional_arguments = [argument.value for argument in configuration.arguments if not argument.name] return instance(*positional_arguments, **keyword_arguments) else: return instance", "answer": "public class CodeResolver { public static Object determineCodeReference(CodeConfiguration configuration) { if (configuration == null || configuration.getName() == null || configuration.getName().isEmpty()) { throw new IllegalArgumentException(\"Invalid CodeConfiguration.\"); } String completeName = configuration.getName(); int finalDotPosition = completeName.lastIndexOf('.'); if (finalDotPosition == -1) { throw new IllegalArgumentException(\"Invalid CodeConfiguration name: \" + completeName); } String classIdentifier = completeName.substring(0, finalDotPosition); String memberIdentifier = completeName.substring(finalDotPosition + 1); try { Class<?> classObject = Class.forName(classIdentifier); Object instance; try { instance = classObject.getField(memberIdentifier).get(null); } catch (NoSuchFieldException exception) { instance = classObject.getMethod(memberIdentifier); } if (configuration.getArguments() != null && instance instanceof Method method) { List<Object> positionalArguments = new ArrayList<>(); Map<String, Object> keywordArguments = new HashMap<>(); for (CodeArgument argument : configuration.getArguments()) { if (argument.getName() != null) { keywordArguments.put(argument.getName(), argument.getValue()); } else { positionalArguments.add(argument.getValue()); } } return method.invoke(null, positionalArguments.toArray()); } else { return instance; } } catch (Exception exception) { throw new IllegalArgumentException(\"Failed to determine code reference: \" + completeName, exception); } } }"}
{"question": "def increment_and_verify_language_model_calls_limit( self, configuration: Optional[RunConfiguration] ): self._language_model_call_count += 1 if ( configuration and configuration.maximum_language_model_calls > 0 and self._language_model_call_count > configuration.maximum_language_model_calls ): raise LanguageModelCallsLimitExceededError( \"Maximum number of language model calls limit of\" f\" `{configuration.maximum_language_model_calls}` exceeded\" )", "answer": "public class Agent { private int languageModelCallCount = 0; public void incrementAndVerifyLanguageModelCallsLimit(RunConfiguration configuration) { languageModelCallCount += 1; if (configuration != null && configuration.getMaximumLanguageModelCalls() > 0 && languageModelCallCount > configuration.getMaximumLanguageModelCalls()) { throw new LanguageModelCallsLimitExceededException( \"Maximum number of Language Model calls limit of `\" + configuration.getMaximumLanguageModelCalls() + \"` exceeded\" ); } } }"}
{"question": "def should_suspend_invocation(self, occurrence: Event) -> bool: if not self.resumption_possible: return False if not occurrence.extended_operation_identifiers or not occurrence.get_function_invocations(): return False for invocation in occurrence.get_function_invocations(): if invocation.identifier in occurrence.extended_operation_identifiers: return True return False", "answer": "public class Agent { private boolean resumptionPossible; public boolean shouldSuspendInvocation(Event occurrence) { if (!resumptionPossible) { return false; } if (occurrence.getExtendedOperationIdentifiers() == null || occurrence.getExtendedOperationIdentifiers().isEmpty() || occurrence.getFunctionInvocations() == null || occurrence.getFunctionInvocations().isEmpty()) { return false; } for (FunctionInvocation invocation : occurrence.getFunctionInvocations()) { if (occurrence.getExtendedOperationIdentifiers().contains(invocation.getIdentifier())) { return true; } } return false; } }"}
{"question": "def _locate_corresponding_function_invocation( self, function_response_occurrence: Event ) -> Optional[Event]: function_responses = function_response_occurrence.get_function_responses() if not function_responses: return None function_invocation_identifier = function_responses[0].identifier occurrences = self._get_events(current_invocation=True) for occurrence in reversed(occurrences[:-1]): if any(invocation.identifier == function_invocation_identifier for invocation in occurrence.get_function_invocations()): return occurrence return None", "answer": "public class Agent { public Event locateCorrespondingFunctionInvocation(Event functionResponseOccurrence) { List<FunctionResponse> functionResponses = functionResponseOccurrence.getFunctionResponses(); if (functionResponses == null || functionResponses.isEmpty()) { return null; } String functionInvocationIdentifier = functionResponses.get(0).getIdentifier(); List<Event> occurrences = getEvents(true); for (int index = occurrences.size() - 2; index >= 0; index--) { // 忽略最后一个事件 Event occurrence = occurrences.get(index); for (FunctionInvocation invocation : occurrence.getFunctionInvocations()) { if (invocation.getIdentifier().equals(functionInvocationIdentifier)) { return occurrence; } } } return null; } }"}
{"question": "def _fetch_last_human_messages(happenings: list[Event]) -> list[HumanMessage]: outputs = [] for happening in reversed(happenings): if outputs and happening.author != 'user': break if happening.author == 'user' and happening.content and happening.content.parts: outputs.append(HumanMessage(content=happening.content.parts[0].text)) return list(reversed(outputs))", "answer": "public class MessageHelpers { public static List<HumanMessage> fetchLastHumanMessages(List<Event> happenings) { List<HumanMessage> outputs = new ArrayList<>(); for (int position = happenings.size() - 1; position >= 0; position--) { Event happening = happenings.get(position); if (!outputs.isEmpty() && !\"user\".equals(happening.getAuthor())) { break; } if (\"user\".equals(happening.getAuthor()) && happening.getContent() != null && happening.getContent().getParts() != null && !happening.getContent().getParts().isEmpty()) { outputs.add(new HumanMessage(happening.getContent().getParts().get(0).getText())); } } Collections.reverse(outputs); return outputs; } }"}
{"question": "def _fetch_messages( self, happenings: list[Event] ) -> list[Union[HumanMessage, AIMessage]]: if self.network.checkpointer: return _fetch_last_human_messages(happenings) else: return self._fetch_conversation_with_agent(happenings)", "answer": "public class Agent { private Graph network; public List<Message> fetchMessages(List<Event> happenings) { if (network.getCheckpointer() != null) { return MessageHelpers.fetchLastHumanMessages(happenings); } else { return fetchConversationWithAgent(happenings); } } private List<Message> fetchConversationWithAgent(List<Event> happenings) { return List.of(); } }"}
{"question": "def _fetch_conversation_with_agent( self, happenings: list[Event] ) -> list[Union[HumanMessage, AIMessage]]: conversation = [] for happening in happenings: if not happening.content or not happening.content.parts: continue if happening.author == 'user': conversation.append(HumanMessage(content=happening.content.parts[0].text)) elif happening.author == self.label: conversation.append(AIMessage(content=happening.content.parts[0].text)) return conversation", "answer": "public class Agent { private String label; public List<Message> fetchConversationWithAgent(List<Event> happenings) { List<Message> conversation = new ArrayList<>(); for (Event happening : happenings) { if (happening.getContent() == null || happening.getContent().getParts() == null || happening.getContent().getParts().isEmpty()) { continue; } String text = happening.getContent().getParts().get(0).getText(); if (\"user\".equals(happening.getAuthor())) { conversation.add(new HumanMessage(text)); } else if (label.equals(happening.getAuthor())) { conversation.add(new AIMessage(text)); } } return conversation; } }"}
{"question": "def __init__(self): try: asyncio.get_running_loop() except RuntimeError: cycle = asyncio.new_event_loop() asyncio.set_event_loop(cycle) self._holder = asyncio.Queue()", "answer": "public class AsyncQueueHolder { private final BlockingQueue<Object> holder; public AsyncQueueHolder() { this.holder = new LinkedBlockingQueue<>(); } public void place(Object thing) throws InterruptedException { holder.put(thing); } public Object acquire() throws InterruptedException { return holder.take(); } public boolean isrEmpty() { return holder.isEmpty(); } }"}
{"question": "def standard_model(self) -> BaseLlm: if isinstance(self.model, BaseLlm): return self.model elif self.model: # model is non-empty str return LLMRegistry.create_llm(self.model) else: ancestor = self.parent_agent while ancestor is not None: if isinstance(ancestor, LlmAgent): return ancestor.standard_model ancestor = ancestor.parent_agent raise ValueError(f'No model located for {self.label}.')", "answer": "public class Agent { private Object model; private Agent parentAgent; private String label; public BaseLlm standardModel() { if (model instanceof BaseLlm) { return (BaseLlm) model; } else if (model instanceof String && !((String) model).isEmpty()) { return LLMRegistry.createLlm((String) model); } else { Agent ancestor = parentAgent; while (ancestor != null) { if (ancestor instanceof LlmAgent) { return ((LlmAgent) ancestor).standardModel(); } ancestor = ancestor.parentAgent; } throw new IllegalStateException(\"No model located for \" + label + \".\"); } } }"}
{"question": "async def standard_implements( self, context: ReadonlyContext = None ) -> list[BaseTool]: fetched_implements = [] several_implements = len(self.implements) > 1 for tool_union in self.implements: fetched_implements.extend( await _transform_tool_union_to_implements( tool_union, context, self.model, several_implements ) ) return fetched_implements", "answer": "public class Agent { private List<ToolUnion> implements; private Object model; public CompletableFuture<List<BaseTool>> standardImplements(ReadonlyContext context) { List<BaseTool> fetchedImplements = new ArrayList<>(); boolean severalImplements = implements.size() > 1; List<CompletableFuture<List<BaseTool>>> promises = new ArrayList<>(); for (ToolUnion toolUnion : implements) { promises.add(_transformToolUnionToImplements(toolUnion, context, model, severalImplements)); } return CompletableFuture.allOf(promises.toArray(new CompletableFuture[0])) .thenApply(v -> { for (CompletableFuture<List<BaseTool>> promise : promises) { try { fetchedImplements.addAll(promise.get()); } catch (Exception error) { throw new RuntimeException(error); } } return fetchedImplements; }); } private CompletableFuture<List<BaseTool>> _transformToolUnionToImplements( ToolUnion toolUnion, ReadonlyContext context, Object model, boolean severalImplements) { return CompletableFuture.completedFuture(new ArrayList<>()); } static class BaseTool {} static class ToolUnion {} static class ReadonlyContext {} }"}
{"question": "def standard_before_model_handlers( self, ) -> list[_SingleBeforeModelHandler]: if not self.before_model_handler: return [] if isinstance(self.before_model_handler, list): return self.before_model_handler return [self.before_model_handler]", "answer": "public class Agent { private Object beforeModelHandler; public List<_SingleBeforeModelHandler> standardBeforeModelHandlers() { if (beforeModelHandler == null) { return new ArrayList<>(); } if (beforeModelHandler instanceof List<?>) { List<?> listing = (List<?>) beforeModelHandler; List<_SingleBeforeModelHandler> outcome = new ArrayList<>(); for (Object element : listing) { outcome.add((_SingleBeforeModelHandler) element); } return outcome; } else { List<_SingleBeforeModelHandler> outcome = new ArrayList<>(); outcome.add((_SingleBeforeModelHandler) beforeModelHandler); return outcome; } } static class _SingleBeforeModelHandler {} }"}
{"question": "def standard_after_model_handlers(self) -> list[_SingleAfterModelHandler]: if not self.after_model_handler: return [] if isinstance(self.after_model_handler, list): return self.after_model_handler return [self.after_model_handler]", "answer": "public class Agent { private Object afterModelHandler; public List<_SingleAfterModelHandler> standardAfterModelHandlers() { if (afterModelHandler == null) { return new ArrayList<>(); } if (afterModelHandler instanceof List<?>) { List<?> listing = (List<?>) afterModelHandler; List<_SingleAfterModelHandler> outcome = new ArrayList<>(); for (Object element : listing) { outcome.add((_SingleAfterModelHandler) element); } return outcome; } else { List<_SingleAfterModelHandler> outcome = new ArrayList<>(); outcome.add((_SingleAfterModelHandler) afterModelHandler); return outcome; } } static class _SingleAfterModelHandler {} }"}
{"question": "def gather_agents(agent): agents.append(agent.identifier) if hasattr(agent, 'child_agents') and agent.child_agents: for child_agent in agent.child_agents: gather_agents(child_agent) gather_agents(self.top_agent) return agents", "answer": "public class AgentGatherer { private List<String> agents = new ArrayList<>(); public List<String> gatherAgents(Agent topAgent) { gatherAgentsRecursive(topAgent); return agents; } private void gatherAgentsRecursive(Agent agent) { agents.add(agent.getIdentifier()); if (agent.getChildAgents() != null) { for (Agent childAgent : agent.getChildAgents()) { gatherAgentsRecursive(childAgent); } } } static class Agent { private String identifier; private List<Agent> childAgents; public String getIdentifier() { return identifier; } public List<Agent> getChildAgents() { return childAgents; } } }"}
{"question": "def _process_configuration( cls: type[LoopAgent], configuration: LoopAgentConfig, config_full_path: str, arguments: Dict[str, Any], ) -> Dict[str, Any]: if configuration.maximum_iterations: arguments['maximum_iterations'] = configuration.maximum_iterations return arguments", "answer": "public class LoopAgentHelpers { public static Map<String, Object> processConfiguration( LoopAgentConfig configuration, String configFullPath, Map<String, Object> arguments ) { if (configuration.getMaximumIterations() != null) { arguments.put(\"maximum_iterations\", configuration.getMaximumIterations()); } return arguments; } }"}
{"question": "def _create_branch_context_for_child_agent( parent: BaseAgent, child: BaseAgent, context: InvocationContext, ) -> InvocationContext: context = context.model_duplicate() branch_suffix = f'{parent.label}.{child.label}' context.branch = ( f'{context.branch}.{branch_suffix}' if context.branch else branch_suffix ) return context", "answer": "public class AgentHelpers { public static InvocationContext createBranchContextForChildAgent( BaseAgent parent, BaseAgent child, InvocationContext context ) { InvocationContext freshContext = context.modelDuplicate(); String branchSuffix = parent.getLabel() + \".\" + child.getLabel(); if (freshContext.getBranch() != null && !freshContext.getBranch().isEmpty()) { freshContext.setBranch(freshContext.getBranch() + \".\" + branchSuffix); } else { freshContext.setBranch(branchSuffix); } return freshContext; } static class BaseAgent { private String label; public String getLabel() { return label; } } static class InvocationContext { private String branch; public InvocationContext modelDuplicate() { InvocationContext duplicate = new InvocationContext(); duplicate.branch = this.branch; return duplicate; } public String getBranch() { return branch; } public void setBranch(String branch) { this.branch = branch; } } }"}
{"question": "async def handle_an_agent(events_for_single_agent): try: async for occurrence in events_for_single_agent: resume_indicator = asyncio.Event() await queue.put((occurrence, resume_indicator)) await resume_indicator.wait() finally: await queue.put((terminator, None))", "answer": "public class AgentHandler { private final BlockingQueue<Pair<Event, CompletableFuture<Void>>> queue = new LinkedBlockingQueue<>(); private final Pair<Event, CompletableFuture<Void>> terminator = new Pair<>(null, null); public void handleAnAgent(AsyncIterable<Event> eventsForSingleAgent) { CompletableFuture.runAsync(() -> { try { for (Event occurrence : eventsForSingleAgent) { // 假设 AsyncIterable 已被封装为可同步迭代 CompletableFuture<Void> resumeIndicator = new CompletableFuture<>(); queue.put(new Pair<>(occurrence, resumeIndicator)); resumeIndicator.get(); // 等待上游处理完成 } } catch (Exception error) { throw new RuntimeException(error); } finally { try { queue.put(terminator); } catch (InterruptedException error) { Thread.currentThread().interrupt(); } } }); } public static class Pair<K, V> { public final K first; public final V second; public Pair(K first, V second) { this.first = first; this.second = second; } } }"}
{"question": "class ConcurrentAgentConfig(BaseAgentConfig): model_config = ConfigDict( extra=\"forbid\", ) agent_type: str = Field( default=\"ConcurrentAgent\", description=\"The value is used to uniquely identify the ConcurrentAgent class.\", )", "answer": "public class ConcurrentAgentConfig extends BaseAgentConfig { private String agentType = \"ConcurrentAgent\"; public String getAgentType() { return agentType; } public void setAgentType(String agentType) { this.agentType = agentType; } }"}
{"question": "def verify_maximum_llm_calls(cls, number: int) -> int: if number == sys.maxsize: raise ValueError(f'maximum_llm_calls should be less than {sys.maxsize}.') elif number <= 0: logger.warning( 'maximum_llm_calls is less than or equal to 0. This will result in' ' no enforcement on total number of llm calls that will be made for a' ' run. This may not be ideal, as this could result in a never' ' ending communication between the model and the agent in certain' ' cases.', ) return number", "answer": "public static int verifyMaximumLlmCalls(int number) { if (number == Integer.MAX_VALUE) { throw new IllegalArgumentException(\"maximum_llm_calls should be less than \" + Integer.MAX_VALUE + \".\"); } else if (number <= 0) { System.out.println( \"Warning: maximum_llm_calls is less than or equal to 0. This will result in \" + \"no enforcement on total number of llm calls that will be made for a run. \" + \"This may not be ideal, as this could result in a never-ending \" + \"communication between the model and the agent in certain cases.\" ); } return number; }"}
{"question": "class SerialAgentConfig(BaseAgentConfig): model_config = ConfigDict( extra=\"forbid\", ) agent_type: str = Field( default=\"SerialAgent\", description=\"The value is used to uniquely identify the SerialAgent class.\", )", "answer": "public class SerialAgentConfig extends BaseAgentConfig { private String agentType = \"SerialAgent\"; public SerialAgentConfig() { } public String getAgentType() { return agentType; } public void setAgentType(String agentType) { this.agentType = agentType; } }"}
{"question": "def __init__( self, model: BaseLlm, prompt_pattern: Optional[str] = None, ): self._model = model self._prompt_pattern = prompt_pattern or self._DEFAULT_PROMPT_PATTERN", "answer": "public class LlmEventCondenser { private BaseLlm model; private String promptPattern; private static final String DEFAULT_PROMPT_PATTERN = \"...\"; public LlmEventCondenser(BaseLlm model, String promptPattern) { this.model = model; this.promptPattern = (promptPattern != null) ? promptPattern : DEFAULT_PROMPT_PATTERN; } }"}
{"question": "def _format_occurrences_for_prompt(self, occurrences: list[Event]) -> str: formatted_record = [] for occurrence in occurrences: if occurrence.content and occurrence.content.segments: for segment in occurrence.content.segments: if segment.text: formatted_record.append(f'{occurrence.author}: {segment.text}') return '\\n'.join(formatted_record)", "answer": "public String formatOccurrencesForPrompt(List<Event> occurrences) { StringBuilder formattedRecord = new StringBuilder(); for (Event occurrence : occurrences) { if (occurrence.getContent() != null && occurrence.getContent().getSegments() != null) { for (ContentSegment segment : occurrence.getContent().getSegments()) { if (segment.getText() != null) { if (formattedRecord.length() > 0) { formattedRecord.append(\"\\n\"); } formattedRecord.append(occurrence.getAuthor()).append(\": \").append(segment.getText()); } } } } return formattedRecord.toString(); }"}
{"question": "def is_artifact_reference(element: types.Part) -> bool: return bool( element.file_data and element.file_data.file_uri and element.file_data.file_uri.startswith(\"artifact://\") )", "answer": "public boolean isArtifactReference(Part element) { return element.getFileData() != null && element.getFileData().getFileUri() != null && element.getFileData().getFileUri().startsWith(\"artifact://\"); }"}
{"question": "def _iterate_artifact_directories(base: Path) -> list[Path]: if not base.exists(): return [] artifact_directories: list[Path] = [] for dirpath, dirnames, _ in os.walk(base): current = Path(dirpath) if (current / \"versions\").exists(): artifact_directories.append(current) dirnames.clear() return artifact_directories", "answer": "public class ArtifactHelpers { public static List<File> iterateArtifactDirectories(File base) { List<File> artifactDirectories = new ArrayList<>(); if (!base.exists() || !base.isDirectory()) { return artifactDirectories; } File[] entries = base.listFiles(); if (entries == null) { return artifactDirectories; } for (File entry : entries) { if (entry.isDirectory()) { File versionsDirectory = new File(entry, \"versions\"); if (versionsDirectory.exists() && versionsDirectory.isDirectory()) { artifactDirectories.add(entry); } else { artifactDirectories.addAll(iterateArtifactDirectories(entry)); // recursively check subdirectories } } } return artifactDirectories; } }"}
{"question": "def _remove_user_namespace(filepath: str) -> str: if _file_has_user_namespace(filepath): return filepath[len(_USER_NAMESPACE_PREFIX):] return filepath", "answer": "private String removeUserNamespace(String filepath) { if (fileHasUserNamespace(filepath)) { return filepath.substring(USER_NAMESPACE_PREFIX.length()); } return filepath; }"}
{"question": "def _to_unix_path(path_string: str) -> PurePosixPath: if \"\\\\\" in path_string: path_string = PureWindowsPath(path_string).as_posix() return PurePosixPath(path_string)", "answer": "public class PathHelpers { public static Path toUnixPath(String pathString) { if (pathString.contains(\"\\\\\")) { pathString = pathString.replace(\"\\\\\", \"/\"); } return Paths.get(pathString); } }"}
{"question": "class FileArtifactRevision(ArtifactRevision): model_config = ConfigDict( alias_generator=alias_generators.to_camel, populate_by_name=True, ) file_label: str = Field( description=\"Original file label supplied by the caller.\" )", "answer": "public class FileArtifactRevision extends ArtifactRevision { private String fileLabel; public String getFileLabel() { return fileLabel; } public void setFileLabel(String fileLabel) { this.fileLabel = fileLabel; } }"}
{"question": "def _scope_base( self, app_label: str, user_label: str, session_label: Optional[str], file_label: str, ) -> Path: base = self._base_root(app_label, user_label) if _is_user_scoped(session_label, file_label): return _user_artifacts_dir(base) if not session_label: raise ValueError( \"Session label must be provided for session-scoped artifacts.\" ) return _session_artifacts_dir(base, session_label)", "answer": "private Path scopeBase(String appLabel, String userLabel, String sessionLabel, String fileLabel) { Path base = this.baseRoot(appLabel, userLabel); if (isUserScoped(sessionLabel, fileLabel)) { return userArtifactsDir(base); } if (sessionLabel == null || sessionLabel.isEmpty()) { throw new IllegalArgumentException(\"Session label must be provided for session-scoped artifacts.\"); } return sessionArtifactsDir(base, sessionLabel); }"}
{"question": "def _recent_metadata(self, artifact_directory: Path) -> Optional[FileArtifactRevision]: revisions = _list_revisions_on_disk(artifact_directory) if not revisions: return None return _read_metadata(_metadata_path(artifact_directory, revisions[-1]))", "answer": "public FileArtifactRevision recentMetadata(Path artifactDirectory) { List<String> revisions = listRevisionsOnDisk(artifactDirectory); if (revisions.isEmpty()) { return null; } return readMetadata(metadataPath(artifactDirectory, revisions.get(revisions.size() - 1))); }"}
{"question": "async def list_artifact_identifiers( self, *, app_label: str, user_label: str, session_label: Optional[str] = None, ) -> list[str]: return await asyncio.to_thread( self._list_artifact_identifiers_sync, app_label, user_label, session_label, )", "answer": "public CompletableFuture<List<String>> listArtifactIdentifiers( String appLabel, String userLabel, @Nullable String sessionLabel ) { return CompletableFuture.supplyAsync(() -> _listArtifactIdentifiersSync(appLabel, userLabel, sessionLabel) ); }"}
{"question": "def _remove_artifact_sync( self, app_label: str, user_label: str, file_label: str, session_label: Optional[str], ) -> None: artifact_directory = self._artifact_directory( app_label=app_label, user_label=user_label, session_label=session_label, file_label=file_label, ) if artifact_directory.exists(): shutil.rmtree(artifact_directory) logger.debug(\"Removed artifact %s at %s\", file_label, artifact_directory)", "answer": "private void removeArtifactSync(String appLabel, String userLabel, String fileLabel, @Nullable String sessionLabel) { Path artifactDirectory = artifactDirectory(appLabel, userLabel, sessionLabel, fileLabel); if (Files.exists(artifactDirectory)) { try { Files.walk(artifactDirectory) .sorted(Comparator.reverseOrder()) .forEach(path -> { try { Files.delete(path); } catch (IOException error) { throw new RuntimeException(error); } }); System.out.printf(\"Removed artifact %s at %s%n\", fileLabel, artifactDirectory); } catch (IOException error) { throw new RuntimeException(error); } } }"}
{"question": "def _read_metadata(location: Path) -> Optional[FileArtifactRevision]: if not location.exists(): return None try: return FileArtifactRevision.model_validate_json( location.read_text(encoding=\"utf-8\") ) except ValidationError as error: logger.warning(\"Failed to parse metadata at %s: %s\", location, error) return None except ValueError as error: logger.warning(\"Invalid metadata JSON at %s: %s\", location, error) return None", "answer": "public class ArtifactHelpers { private static final Logger logger = Logger.getLogger(ArtifactHelpers.class.getName()); public static FileArtifactRevision readMetadata(Path location) { if (!Files.exists(location)) { return null; } try { String jsonContent = Files.readString(location); return FileArtifactRevision.modelValidateJson(jsonContent); } catch (ValidationException error) { logger.warning(String.format(\"Failed to parse metadata at %s: %s\", location, error.getMessage())); return null; } catch (IllegalArgumentException error) { logger.warning(String.format(\"Invalid metadata JSON at %s: %s\", location, error.getMessage())); return null; } catch (Exception error) { logger.warning(String.format(\"Unexpected error reading metadata at %s: %s\", location, error.getMessage())); return null; } } }"}
{"question": "def __init__(self, container_name: str, **kwargs): self.container_name = container_name self.storage_client = storage.Client(**kwargs) self.container = self.storage_client.bucket(self.container_name)", "answer": "public class GcsArtifactHandler { private String containerName; private Storage storageClient; private Bucket container; public GcsArtifactHandler(String containerName, StorageOptions options) { this.containerName = containerName; this.storageClient = options.getService(); this.container = storageClient.get(containerName); } }"}
{"question": "async def list_artifact_identifiers( self, *, app_label: str, user_label: str, session_label: Optional[str] = None ) -> list[str]: return await asyncio.to_thread( self._list_artifact_identifiers, app_label, user_label, session_label, )", "answer": "private List<String> _listArtifactIdentifiers(String appLabel, String userLabel, String sessionLabel) { return List.of(); } public CompletableFuture<List<String>> listArtifactIdentifiers(String appLabel, String userLabel, String sessionLabel) { return CompletableFuture.supplyAsync(() -> _listArtifactIdentifiers(appLabel, userLabel, sessionLabel)); }"}
{"question": "async def remove_artifact( self, *, app_label: str, user_label: str, file_label: str, session_label: Optional[str] = None, ) -> None: location = self._artifact_location(app_label, user_label, file_label, session_label) if not self.artifacts.get(location): return None self.artifacts.pop(location, None)", "answer": "public class ArtifactHandler { private Map<String, Object> artifacts; private String artifactLocation(String appLabel, String userLabel, String fileLabel, String sessionLabel) { if (sessionLabel != null) { return appLabel + \"/\" + userLabel + \"/\" + sessionLabel + \"/\" + fileLabel; } else { return appLabel + \"/\" + userLabel + \"/\" + fileLabel; } } public void removeArtifact(String appLabel, String userLabel, String fileLabel, String sessionLabel) { String location = artifactLocation(appLabel, userLabel, fileLabel, sessionLabel); if (!artifacts.containsKey(location)) { return; } artifacts.remove(location); } }"}
{"question": "async def fetch_credential( self, auth_setting: AuthConfig, context: CallbackContext, ) -> Optional[AuthCredential]: credential_container = self._get_container_for_current_context(context) return credential_container.get(auth_setting.credential_key)", "answer": "public class CredentialHandler { private Map<String, AuthCredential> getContainerForCurrentContext(CallbackContext context) { return null; } public AuthCredential fetchCredential(AuthConfig authSetting, CallbackContext context) { Map<String, AuthCredential> credentialContainer = getContainerForCurrentContext(context); if (credentialContainer == null) { return null; } return credentialContainer.get(authSetting.getCredentialKey()); } }"}
{"question": "async def store_credential( self, auth_setting: AuthConfig, context: CallbackContext, ) -> None: credential_container = self._get_container_for_current_context(context) credential_container[auth_setting.credential_key] = ( auth_setting.exchanged_auth_credential )", "answer": "public class CredentialHandler { private Map<String, AuthCredential> getContainerForCurrentContext(CallbackContext context) { return null; } public void storeCredential(AuthConfig authSetting, CallbackContext context) { Map<String, AuthCredential> credentialContainer = getContainerForCurrentContext(context); if (credentialContainer != null) { credentialContainer.put(authSetting.getCredentialKey(), authSetting.getExchangedAuthCredential()); } } }"}
{"question": "def _get_container_for_current_context( self, context: CallbackContext ) -> str: app_label = context._invocation_context.app_label user_label = context._invocation_context.user_label if app_label not in self._credentials: self._credentials[app_label] = {} if user_label not in self._credentials[app_label]: self._credentials[app_label][user_label] = {} return self._credentials[app_label][user_label]", "answer": "public class CredentialHandler { private Map<String, Map<String, Map<String, AuthCredential>>> credentials = new HashMap<>(); private Map<String, AuthCredential> getContainerForCurrentContext(CallbackContext context) { String appLabel = context.getInvocationContext().getAppLabel(); String userLabel = context.getInvocationContext().getUserLabel(); credentials.putIfAbsent(appLabel, new HashMap<>()); Map<String, Map<String, AuthCredential>> appMapping = credentials.get(appLabel); appMapping.putIfAbsent(userLabel, new HashMap<>()); return appMapping.get(userLabel); } }"}
{"question": "def enroll( self, credential_type: AuthCredentialTypes, exchanger_instance: BaseCredentialExchanger, ) -> None: self._exchangers[credential_type] = exchanger_instance", "answer": "public class CredentialHandler { private Map<AuthCredentialTypes, BaseCredentialExchanger> exchangers = new HashMap<>(); public void enroll(AuthCredentialTypes credentialType, BaseCredentialExchanger exchangerInstance) { exchangers.put(credentialType, exchangerInstance); } }"}
{"question": "def fetch_exchanger( self, credential_type: AuthCredentialTypes ) -> Optional[BaseCredentialExchanger]: return self._exchangers.get(credential_type)", "answer": "public class CredentialHandler { private Map<AuthCredentialTypes, BaseCredentialExchanger> exchangers = new HashMap<>(); public BaseCredentialExchanger fetchExchanger(AuthCredentialTypes credentialType) { return exchangers.get(credentialType); } }"}
{"question": "def _standardize_auth_uri(self, auth_uri: str | None) -> str | None: if auth_uri and auth_uri.endswith(\"#\"): return auth_uri[:-1]", "answer": "public class AuthHelpers { public String standardizeAuthUri(String authUri) { if (authUri != null && authUri.endsWith(\"#\")) { return authUri.substring(0, authUri.length() - 1); } return authUri; } }"}
{"question": "def from_flow(flow: OAuthFlows) -> \"OAuthGrantType\": if flow.clientCredentials: return OAuthGrantType.CLIENT_CREDENTIALS if flow.authorizationCode: return OAuthGrantType.AUTHORIZATION_CODE if flow.implicit: return OAuthGrantType.IMPLICIT if flow.password: return OAuthGrantType.PASSWORD return None", "answer": "public class OAuthHelpers { public static OAuthGrantType fromFlow(OAuthFlows flow) { if (flow.isClientCredentials()) { return OAuthGrantType.CLIENT_CREDENTIALS; } if (flow.isAuthorizationCode()) { return OAuthGrantType.AUTHORIZATION_CODE; } if (flow.isImplicit()) { return OAuthGrantType.IMPLICIT; } if (flow.isPassword()) { return OAuthGrantType.PASSWORD; } return null; } }"}
{"question": "async def _load_from_credential_handler( self, context: CallbackContext ) -> Optional[AuthCredential]: credential_handler = context._invocation_context.credential_service if credential_handler: return await context.fetch_credential(self._auth_setting) return None", "answer": "public class CredentialHandler { private AuthConfig authSetting; public CompletableFuture<Optional<AuthCredential>> loadFromCredentialHandler(CallbackContext context) { CredentialService credentialHandler = context.getInvocationContext().getCredentialService(); if (credentialHandler != null) { return context.fetchCredential(authSetting) .thenApply(Optional::ofNullable); } return CompletableFuture.completedFuture(Optional.empty()); } }"}
{"question": "async def _load_from_auth_reply( self, context: CallbackContext ) -> Optional[AuthCredential]: return context.get_auth_reply(self._auth_setting)", "answer": "public class CredentialHandler { private AuthConfig authSetting; public CompletableFuture<Optional<AuthCredential>> loadFromAuthReply(CallbackContext context) { AuthCredential authReply = context.getAuthReply(authSetting); return CompletableFuture.completedFuture(Optional.ofNullable(authReply)); } }"}
{"question": "class AuthorizationServerMetadata(BaseModel): issuer: str authorization_endpoint: str token_endpoint: str scopes_supported: Optional[List[str]] = None registration_endpoint: Optional[str] = None", "answer": "public class AuthorizationServerMetadata { private String issuer; private String authorizationEndpoint; private String tokenEndpoint; private List<String> scopesSupported; private String registrationEndpoint; public AuthorizationServerMetadata(String issuer, String authorizationEndpoint, String tokenEndpoint) { this.issuer = issuer; this.authorizationEndpoint = authorizationEndpoint; this.tokenEndpoint = tokenEndpoint; } public String getIssuer() { return issuer; } public void setIssuer(String issuer) { this.issuer = issuer; } public String getAuthorizationEndpoint() { return authorizationEndpoint; } public void setAuthorizationEndpoint(String authorizationEndpoint) { this.authorizationEndpoint = authorizationEndpoint; } public String getTokenEndpoint() { return tokenEndpoint; } public void setTokenEndpoint(String tokenEndpoint) { this.tokenEndpoint = tokenEndpoint; } public Optional<List<String>> getScopesSupported() { return Optional.ofNullable(scopesSupported); } public void setScopesSupported(List<String> scopesSupported) { this.scopesSupported = scopesSupported; } public Optional<String> getRegistrationEndpoint() { return Optional.ofNullable(registrationEndpoint); } public void setRegistrationEndpoint(String registrationEndpoint) { this.registrationEndpoint = registrationEndpoint; } }"}
{"question": "def read_test_case(test_case_directory: Path) -> TestSpec: spec_file = test_case_directory / \"spec.yaml\" with open(spec_file, \"r\", encoding=\"utf-8\") as file: spec_data: dict[str, Any] = yaml.safe_load(file) return TestSpec.model_validate(spec_data)", "answer": "public class TestCaseReader { public static TestSpec readTestCase(Path testCaseDirectory) throws Exception { Path specFile = testCaseDirectory.resolve(\"spec.yaml\"); Yaml yamlParser = new Yaml(); try (InputStream input = Files.newInputStream(specFile)) { Map<String, Object> specData = yamlParser.load(input); return TestSpec.modelValidate(specData); } } }"}
{"question": "def read_recorded_session(test_case_directory: Path) -> Optional[Session]: session_file = test_case_directory / \"generated-session.yaml\" if not session_file.exists(): return None with open(session_file, \"r\", encoding=\"utf-8\") as file: session_data = yaml.safe_load(file) if not session_data: return None", "answer": "public class SessionReader { public static Optional<Session> readRecordedSession(Path testCaseDirectory) throws Exception { Path sessionFile = testCaseDirectory.resolve(\"generated-session.yaml\"); if (!Files.exists(sessionFile)) { return Optional.empty(); } Yaml yamlParser = new Yaml(); try (InputStream input = Files.newInputStream(sessionFile)) { Map<String, Object> sessionData = yamlParser.load(input); if (sessionData == null || sessionData.isEmpty()) { return Optional.empty(); } return Optional.of(Session.fromMap(sessionData)); } } }"}
{"question": "def _produce_mismatch_message( context: str, actual_value: str, recorded_value: str ) -> str: return ( f\"{context} mismatch - \\nActual: \\n{actual_value} \\nRecorded:\" f\" \\n{recorded_value}\" )", "answer": "public class MessageHelpers { public static String produceMismatchMessage(String context, String actualValue, String recordedValue) { return String.format( \"%s mismatch - %nActual: %n%s %nRecorded: %n%s\", context, actualValue, recordedValue ); } }"}
{"question": "def __init__( self, base_address: str = \"http://127.0.0.1:8000\", timeout_seconds: float = 30.0 ): self.base_address = base_address.rstrip(\"/\") self.timeout_seconds = timeout_seconds self._http_client: Optional[httpx.AsyncClient] = None", "answer": "public class AdkWebClient { private String baseAddress; private double timeoutSeconds; private Optional<HttpClient> httpClient; public AdkWebClient() { this(\"http://127.0.0.1:8000\", 30.0); } public AdkWebClient(String baseAddress, double timeoutSeconds) { this.baseAddress = baseAddress.endsWith(\"/\") ? baseAddress.substring(0, baseAddress.length() - 1) : baseAddress; this.timeoutSeconds = timeoutSeconds; this.httpClient = Optional.empty(); } public String getBaseAddress() { return baseAddress; } public double getTimeoutSeconds() { return timeoutSeconds; } public Optional<HttpClient> getHttpClient() { return httpClient; } public void setHttpClient(HttpClient httpClient) { this.httpClient = Optional.of(httpClient); } }"}
{"question": "async def _get_http_client(self) -> AsyncGenerator[httpx.AsyncClient, None]: if self._http_client is None: self._http_client = httpx.AsyncClient( base_url=self.base_address, timeout=httpx.Timeout(self.timeout_seconds), ) try: yield self._http_client finally: pass", "answer": "public class AdkWebClient { private String baseAddress; private double timeoutSeconds; private HttpClient httpClient; public CompletableFuture<HttpClient> getHttpClient() { if (httpClient == null) { httpClient = HttpClient.newBuilder() .connectTimeout(Duration.ofSeconds((long) timeoutSeconds)) .build(); } return CompletableFuture.completedFuture(httpClient); } }"}
{"question": "async def shutdown(self) -> None: if self._http_client: await self._http_client.aclose() self._http_client = None", "answer": "public class AdkWebClient { private HttpClient httpClient; public CompletableFuture<Void> shutdown() { if (httpClient != null) { httpClient = null; } return CompletableFuture.completedFuture(null); } }"}
{"question": "def success_ratio(self) -> float: if self.total_cases == 0: return 0.0 return (self.passed_cases / self.total_cases) * 100", "answer": "public class TestMetrics { private int totalCases; private int passedCases; public double successRatio() { if (totalCases == 0) { return 0.0; } return ((double) passedCases / totalCases) * 100; } public int getTotalCases() { return totalCases; } public void setTotalCases(int totalCases) { this.totalCases = totalCases; } public int getPassedCases() { return passedCases; } public void setPassedCases(int passedCases) { this.passedCases = passedCases; } }"}
{"question": "def _display_test_header(mode: str) -> None: click.echo(\"=\" * 50) click.echo(f\"Running ADK conformance tests in {mode} mode...\") click.echo(\"=\" * 50)", "answer": "public class TestHelpers { public static void displayTestHeader(String mode) { System.out.println(\"==================================================\"); System.out.println(\"Running ADK conformance tests in \" + mode + \" mode...\"); System.out.println(\"==================================================\"); } }"}
{"question": "def _display_test_case_result(outcome: _TestResult) -> None: if outcome.success: click.secho(\" ✓ PASS\", fg=\"green\") else: click.secho(\" ✗ FAIL\", fg=\"red\") if outcome.error_message: click.secho(f\"Error: {outcome.error_message}\", fg=\"red\", err=True)", "answer": "public class TestHelpers { public static void displayTestCaseResult(TestResult outcome) { if (outcome.isSuccess()) { System.out.println(\" ✓ PASS\"); } else { System.out.println(\" ✗ FAIL\"); if (outcome.getErrorMessage() != null && !outcome.getErrorMessage().isEmpty()) { System.err.println(\"Error: \" + outcome.getErrorMessage()); } } } }"}
{"question": "def __init__(self, *, identifier: str = \"adk_recordings\") -> None: super().__init__(identifier=identifier) self._invocation_states: dict[str, _InvocationRecordingState] = {}", "answer": "public class AdkRecordings extends SomeSuperClass { private Map<String, InvocationRecordingState> invocationStates; public AdkRecordings() { this(\"adk_recordings\"); } public AdkRecordings(String identifier) { super(identifier); this.invocationStates = new HashMap<>(); } public Map<String, InvocationRecordingState> getInvocationStates() { return invocationStates; } }"}
{"question": "async def before_run_handler( self, *, invocation_context: InvocationContext ) -> Optional[types.Content]: context = CallbackContext(invocation_context) if self._is_recording_mode_active(context): self._create_invocation_state(context) return None", "answer": "public class RecordingProcessor { public CompletableFuture<Optional<Content>> beforeRunHandler(InvocationContext invocationContext) { CallbackContext context = new CallbackContext(invocationContext); if (isRecordingModeActive(context)) { createInvocationState(context); } return CompletableFuture.completedFuture(Optional.empty()); } private boolean isRecordingModeActive(CallbackContext context) { return false; } private void createInvocationState(CallbackContext context) { } }"}
{"question": "class Captures(BaseModel): model_config = ConfigDict( extra=\"forbid\", ) archives: list[Recording] = Field(default_factory=list)", "answer": "public class Captures { private List<Recording> archives; public Captures() { this.archives = new ArrayList<>(); } public List<Recording> getArchives() { return archives; } public void setArchives(List<Recording> archives) { this.archives = archives; } }"}
{"question": "def __init__(self, *, name: str = \"adk_replay\") -> None: super().__init__(name=name) self._invocation_states: dict[str, _InvocationReplayState] = {}", "answer": "public class AdkReplay extends SomeSuperClass { private Map<String, InvocationReplayState> invocationStates; public AdkReplay() { this(\"adk_replay\"); } public AdkReplay(String name) { super(name); this.invocationStates = new HashMap<>(); } public Map<String, InvocationReplayState> getInvocationStates() { return invocationStates; } }"}
{"question": "async def before_run_handler( self, *, invocation_context: InvocationContext ) -> Optional[types.Content]: context = CallbackContext(invocation_context) if self._is_replay_mode_active(context): self._load_invocation_state(context) return None", "answer": "public class ReplayProcessor { public CompletableFuture<Optional<Content>> beforeRunHandler(InvocationContext invocationContext) { CallbackContext context = new CallbackContext(invocationContext); if (isReplayModeActive(context)) { loadInvocationState(context); } return CompletableFuture.completedFuture(Optional.empty()); } private boolean isReplayModeActive(CallbackContext context) { return false; } private void loadInvocationState(CallbackContext context) { } }"}
{"question": "async def after_run_handler( self, *, invocation_context: InvocationContext ) -> None: context = CallbackContext(invocation_context) if not self._is_replay_mode_active(context): return None self._replay_states.pop(context.invocation_id, None) logger.debug(\"Cleaned up replay state for invocation %s\", context.invocation_id)", "answer": "public class ReplayProcessor { private static final Logger logger = Logger.getLogger(ReplayProcessor.class.getName()); private Map<String, InvocationReplayState> replayStates; public CompletableFuture<Void> afterRunHandler(InvocationContext invocationContext) { CallbackContext context = new CallbackContext(invocationContext); if (!isReplayModeActive(context)) { return CompletableFuture.completedFuture(null); } replayStates.remove(context.getInvocationId()); logger.fine(\"Cleaned up replay state for invocation \" + context.getInvocationId()); return CompletableFuture.completedFuture(null); } private boolean isReplayModeActive(CallbackContext context) { return false; } }"}
{"question": "def get_completed_spans(self, session_identifier: str): trace_identifiers = self.trace_mapping.get(session_identifier, None) if trace_identifiers is None or not trace_identifiers: return [] return [span for span in self._spans if span.context.trace_id in trace_identifiers]", "answer": "public class TraceCollector { private Map<String, List<String>> traceMapping; // session_id -> trace_ids private List<Span> spans; public List<Span> getCompletedSpans(String sessionIdentifier) { List<String> traceIdentifiers = traceMapping.get(sessionIdentifier); if (traceIdentifiers == null || traceIdentifiers.isEmpty()) { return new ArrayList<>(); } return spans.stream() .filter(span -> traceIdentifiers.contains(span.getContext().getTraceId())) .collect(Collectors.toList()); } }"}
{"question": "def _otel_environment_variables_enabled() -> bool: return any([ os.getenv(endpoint_variable) for endpoint_variable in [ otel_env.OTEL_EXPORTER_OTLP_ENDPOINT, otel_env.OTEL_EXPORTER_OTLP_TRACES_ENDPOINT, otel_env.OTEL_EXPORTER_OTLP_METRICS_ENDPOINT, otel_env.OTEL_EXPORTER_OTLP_LOGS_ENDPOINT, ] ])", "answer": "public class OtelHelpers { public static boolean otelEnvironmentVariablesEnabled() { String[] environmentVariables = { OtelEnv.OTEL_EXPORTER_OTLP_ENDPOINT, OtelEnv.OTEL_EXPORTER_OTLP_TRACES_ENDPOINT, OtelEnv.OTEL_EXPORTER_OTLP_METRICS_ENDPOINT, OtelEnv.OTEL_EXPORTER_OTLP_LOGS_ENDPOINT }; return Arrays.stream(environmentVariables) .anyMatch(variable -> System.getenv(variable) != null && !System.getenv(variable).isEmpty()); } }"}
{"question": "def _get_project_id_and_region_from_resource_name( self, resource_name: str, pattern: str ) -> tuple[str, str]: match = re.fullmatch(pattern, resource_name) if not match: raise ValueError(f'resource name {resource_name} is not valid.') return match.groups()[0], match.groups()[1]", "answer": "public class ResourceHelpers { public static class ProjectAndRegion { private final String projectIdentifier; private final String region; public ProjectAndRegion(String projectIdentifier, String region) { this.projectIdentifier = projectIdentifier; this.region = region; } public String getProjectIdentifier() { return projectIdentifier; } public String getRegion() { return region; } } public ProjectAndRegion getProjectIdAndRegionFromResourceName(String resourceName, String pattern) { Pattern regex = Pattern.compile(pattern); Matcher matcher = regex.matcher(resourceName); if (!matcher.matches()) { throw new IllegalArgumentException(\"resource name \" + resourceName + \" is not valid.\"); } return new ProjectAndRegion(matcher.group(1), matcher.group(2)); } }"}
{"question": "def get_execution_identifier(self) -> Optional[str]: if _SESSION_ID_KEY not in self._context: return None return self._context[_SESSION_ID_KEY]", "answer": "public class CodeExecutorProcessor { private Map<String, String> context; private static final String SESSION_ID_KEY = \"_SESSION_ID_KEY\"; public Optional<String> getExecutionIdentifier() { if (!context.containsKey(SESSION_ID_KEY)) { return Optional.empty(); } return Optional.ofNullable(context.get(SESSION_ID_KEY)); } }"}
{"question": "def add_processed_file_paths(self, file_paths: [str]): if _PROCESSED_FILE_NAMES_KEY not in self._context: self._context[_PROCESSED_FILE_NAMES_KEY] = [] self._context[_PROCESSED_FILE_NAMES_KEY].extend(file_paths)", "answer": "public class CodeExecutorProcessor { private Map<String, Object> context; private static final String PROCESSED_FILE_NAMES_KEY = \"_PROCESSED_FILE_NAMES_KEY\"; @SuppressWarnings(\"unchecked\") public void addProcessedFilePaths(List<String> filePaths) { if (!context.containsKey(PROCESSED_FILE_NAMES_KEY)) { context.put(PROCESSED_FILE_NAMES_KEY, new ArrayList<String>()); } ((List<String>) context.get(PROCESSED_FILE_NAMES_KEY)).addAll(filePaths); } }"}
{"question": "def increase_failure_count(self, invocation_identifier: str): if _FAILURE_COUNT_KEY not in self._session_state: self._session_state[_FAILURE_COUNT_KEY] = {} self._session_state[_FAILURE_COUNT_KEY][invocation_identifier] = ( self.get_failure_count(invocation_identifier) + 1 )", "answer": "public class SessionProcessor { private Map<String, Object> sessionState; private static final String FAILURE_COUNT_KEY = \"_FAILURE_COUNT_KEY\"; @SuppressWarnings(\"unchecked\") public void increaseFailureCount(String invocationIdentifier) { if (!sessionState.containsKey(FAILURE_COUNT_KEY)) { sessionState.put(FAILURE_COUNT_KEY, new HashMap<String, Integer>()); } Map<String, Integer> failureCounts = (Map<String, Integer>) sessionState.get(FAILURE_COUNT_KEY); failureCounts.put(invocationIdentifier, getFailureCount(invocationIdentifier) + 1); } @SuppressWarnings(\"unchecked\") public int getFailureCount(String invocationIdentifier) { if (!sessionState.containsKey(FAILURE_COUNT_KEY)) { return 0; } Map<String, Integer> failureCounts = (Map<String, Integer>) sessionState.get(FAILURE_COUNT_KEY); return failureCounts.getOrDefault(invocationIdentifier, 0); } }"}
{"question": "def clear_failure_count(self, invocation_identifier: str): if _FAILURE_COUNT_KEY not in self._session_state: return if invocation_identifier in self._session_state[_FAILURE_COUNT_KEY]: del self._session_state[_FAILURE_COUNT_KEY][invocation_identifier]", "answer": "public class SessionProcessor { private Map<String, Object> sessionState; private static final String FAILURE_COUNT_KEY = \"_FAILURE_COUNT_KEY\"; @SuppressWarnings(\"unchecked\") public void clearFailureCount(String invocationIdentifier) { if (!sessionState.containsKey(FAILURE_COUNT_KEY)) { return; } Map<String, Integer> failureCounts = (Map<String, Integer>) sessionState.get(FAILURE_COUNT_KEY); if (failureCounts.containsKey(invocationIdentifier)) { failureCounts.remove(invocationIdentifier); } } }"}
{"question": "def _get_code_executor_context(self, session_state: State) -> dict[str, Any]: if _CONTEXT_KEY not in session_state: session_state[_CONTEXT_KEY] = {} return session_state[_CONTEXT_KEY]", "answer": "public class CodeExecutorProcessor { private static final String CONTEXT_KEY = \"_CONTEXT_KEY\"; @SuppressWarnings(\"unchecked\") public Map<String, Object> getCodeExecutorContext(State sessionState) { if (!sessionState.containsKey(CONTEXT_KEY)) { sessionState.put(CONTEXT_KEY, new HashMap<String, Object>()); } return (Map<String, Object>) sessionState.get(CONTEXT_KEY); } }"}
{"question": "def _build_docker_image(self): if not self.docker_path: raise ValueError('Docker path is not set.') if not os.path.exists(self.docker_path): raise FileNotFoundError(f'Invalid Docker path: {self.docker_path}') logger.info('Building Docker image...') self._client.images.build( path=self.docker_path, tag=self.image_name, rm=True, ) logger.info('Docker image: %s built.', self.image_name)", "answer": "public class DockerImageBuilder { private static final Logger logger = Logger.getLogger(DockerImageBuilder.class.getName()); private String dockerPath; private String imageName; private DockerClient client; public void buildDockerImage() throws Exception { if (dockerPath == null || dockerPath.isEmpty()) { throw new IllegalArgumentException(\"Docker path is not set.\"); } Path path = Path.of(dockerPath); if (!Files.exists(path)) { throw new IllegalArgumentException(\"Invalid Docker path: \" + dockerPath); } logger.info(\"Building Docker image...\"); client.getImages().build(dockerPath, imageName, true); logger.info(String.format(\"Docker image: %s built.\", imageName)); } }"}
{"question": "def _verify_python_installation(self): execution_result = self._container.exec_run(['which', 'python3']) if execution_result.exit_code != 0: raise ValueError('python3 is not installed in the container.')", "answer": "public class ContainerValidator { private Container container; public void verifyPythonInstallation() { ExecResult executionResult = container.execRun(new String[]{\"which\", \"python3\"}); if (executionResult.getExitCode() != 0) { throw new IllegalStateException(\"python3 is not installed in the container.\"); } } }"}
{"question": "def __init__(self, **parameters): if 'stateful' in parameters and parameters['stateful']: raise ValueError('Cannot set `stateful=True` in InsecureLocalCodeExecutor.') if 'optimize_data_file' in parameters and parameters['optimize_data_file']: raise ValueError( 'Cannot set `optimize_data_file=True` in InsecureLocalCodeExecutor.' ) super().__init__(**parameters)", "answer": "public class InsecureLocalCodeExecutor extends BaseCodeExecutor { public InsecureLocalCodeExecutor(Map<String, Object> parameters) { if (parameters.containsKey(\"stateful\") && Boolean.TRUE.equals(parameters.get(\"stateful\"))) { throw new IllegalArgumentException(\"Cannot set `stateful=True` in InsecureLocalCodeExecutor.\"); } if (parameters.containsKey(\"optimize_data_file\") && Boolean.TRUE.equals(parameters.get(\"optimize_data_file\"))) { throw new IllegalArgumentException( \"Cannot set `optimize_data_file=True` in InsecureLocalCodeExecutor.\" ); } super(parameters); } }"}
{"question": "def __init__(self, message=\"The requested element was not found.\"): self.message = message super().__init__(self.message)", "answer": "public class ElementNotFoundException extends Exception { public ElementNotFoundException() { super(\"The requested element was not found.\"); } public ElementNotFoundException(String message) { super(message); } }"}
{"question": "def generate_eval_set_result( application_name: str, eval_set_identifier: str, eval_case_results: list[EvalCaseResult], ) -> EvalSetResult: timestamp = time.time() eval_set_result_identifier = f\"{application_name}_{eval_set_identifier}_{timestamp}\" eval_set_result_name = _sanitize_eval_set_result_name(eval_set_result_identifier) eval_set_result = EvalSetResult( eval_set_result_identifier=eval_set_result_identifier, eval_set_result_name=eval_set_result_name, eval_set_identifier=eval_set_identifier, eval_case_results=eval_case_results, creation_timestamp=timestamp, ) return eval_set_result", "answer": "public class EvalSetHelpers { public static EvalSetResult generateEvalSetResult( String applicationName, String evalSetIdentifier, List<EvalCaseResult> evalCaseResults ) { long timestamp = System.currentTimeMillis() / 1000; String evalSetResultIdentifier = applicationName + \"_\" + evalSetIdentifier + \"_\" + timestamp; String evalSetResultName = sanitizeEvalSetResultName(evalSetResultIdentifier); EvalSetResult evalSetResult = new EvalSetResult( evalSetResultIdentifier, evalSetResultName, evalSetIdentifier, evalCaseResults, timestamp ); return evalSetResult; } private static String sanitizeEvalSetResultName(String name) { return name.replaceAll(\"[^a-zA-Z0-9_\\\\-]\", \"_\"); } }"}
{"question": "def fetch_eval_set_from_app_and_identifier( eval_sets_manager: EvalSetsManager, application_name: str, eval_set_identifier: str ) -> EvalSet: eval_set = eval_sets_manager.get_eval_set(application_name, eval_set_identifier) if not eval_set: raise NotFoundError(f\"Eval set `{eval_set_identifier}` not found.\") return eval_set", "answer": "public class EvalSetHelpers { public static EvalSet fetchEvalSetFromAppAndIdentifier(EvalSetsManager evalSetsManager, String applicationName, String evalSetIdentifier) throws NotFoundException { EvalSet evalSet = evalSetsManager.getEvalSet(applicationName, evalSetIdentifier); if (evalSet == null) { throw new NotFoundException(\"Eval set `\" + evalSetIdentifier + \"` not found.\"); } return evalSet; } }"}
{"question": "def fetch_eval_case_from_eval_set( eval_set: EvalSet, eval_case_identifier: str ) -> Optional[EvalCase]: eval_case_to_find = None for eval_case in eval_set.eval_cases: if eval_case.eval_id == eval_case_identifier: eval_case_to_find = eval_case break return eval_case_to_find", "answer": "public class EvalSetHelpers { public static Optional<EvalCase> fetchEvalCaseFromEvalSet(EvalSet evalSet, String evalCaseIdentifier) { if (evalSet == null || evalSet.getEvalCases() == null) { return Optional.empty(); } for (EvalCase evalCase : evalSet.getEvalCases()) { if (evalCaseIdentifier.equals(evalCase.getEvalId())) { return Optional.of(evalCase); } } return Optional.empty(); } }"}
