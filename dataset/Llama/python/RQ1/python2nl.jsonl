{"question": "def _serialize_metadata_value(value: Any) -> str: \"\"\"Safely serializes metadata values to string format. Args: value: The value to serialize. Returns: String representation of the value. \"\"\" if hasattr(value, \"model_dump\"): try: return value.model_dump(exclude_none=True, by_alias=True) except Exception as e: logger.warning(\"Failed to serialize metadata value: %s\", e) return str(value) return str(value)", "answer": "This function converts a metadata value to its string representation, using a specialized `model_dump` method if available and falling back to a simple string conversion on failure."}
{"question": "def _create_artifact_id( app_name: str, user_id: str, session_id: str, filename: str, version: int ) -> str: components = [app_name, user_id, session_id, filename, str(version)] return ARTIFACT_ID_SEPARATOR.join(components)", "answer": "This function generates a unique artifact ID by concatenating the application name, user ID, session ID, filename, and version number using a predefined separator."}
{"question": "def _process_long_running_tool(a2a_part: A2APart, event: Event) -> None: if ( isinstance(a2a_part.root, DataPart) and event.long_running_tool_ids and a2a_part.root.metadata and a2a_part.root.metadata.get( _get_adk_metadata_key(A2A_DATA_PART_METADATA_TYPE_KEY) ) == A2A_DATA_PART_METADATA_TYPE_FUNCTION_CALL and a2a_part.root.data.get(\"id\") in event.long_running_tool_ids ): a2a_part.root.metadata[ _get_adk_metadata_key(A2A_DATA_PART_METADATA_IS_LONG_RUNNING_KEY) ] = True", "answer": "This function marks a data part as long-running in its metadata if it represents a function call whose ID is listed in the event’s long-running tool IDs."}
{"question": "def _get_user_id(request: RequestContext) -> str: if ( request.call_context and request.call_context.user and request.call_context.user.user_name ): return request.call_context.user.user_name return f'A2A_USER_{request.context_id}'", "answer": "This function returns the username from the request's call context if available, otherwise it generates a default user ID using the request's context ID."}
{"question": "def _get_adk_metadata_key(key: str) -> str: if not key: raise ValueError(\"Metadata key cannot be empty or None\") return f\"{ADK_METADATA_KEY_PREFIX}{key}\"", "answer": "This function validates that a given metadata key is non-empty and returns it prefixed with a predefined constant."}
{"question": "def _to_a2a_context_id(app_name: str, user_id: str, session_id: str) -> str: if not all([app_name, user_id, session_id]): raise ValueError(\"All parameters (app_name, user_id, session_id) must be non-empty\") return ADK_CONTEXT_ID_SEPARATOR.join([ADK_CONTEXT_ID_PREFIX, app_name, user_id, session_id])", "answer": "This function validates that all input parameters are non-empty and returns a context ID string composed of a fixed prefix followed by the application name, user ID, and session ID separated by a predefined delimiter."}
{"question": "def _from_a2a_context_id(context_id: str) -> tuple[str, str, str]: if not context_id: return None, None, None try: parts = context_id.split(ADK_CONTEXT_ID_SEPARATOR) if len(parts) != 4: return None, None, None prefix, app_name, user_id, session_id = parts if prefix == ADK_CONTEXT_ID_PREFIX and app_name and user_id and session_id: return app_name, user_id, session_id except ValueError: pass return None, None, None", "answer": "This function parses a context ID string into application name, user ID, and session ID if it matches the expected format and prefix, otherwise returns three None values."}
{"question": "def __init__( self, *, runner: Runner | Callable[..., Runner | Awaitable[Runner]], config: Optional[A2aAgentExecutorConfig] = None, ): super().__init__() self._runner = runner self._config = config or A2aAgentExecutorConfig()", "answer": "This constructor initializes the object with a specified runner and an optional configuration, using a default configuration if none is provided."}
{"question": "def _is_a2a_task(obj) -> bool: \"\"\"Check if an object is an A2A Task, with fallback for isinstance issues.\"\"\" try: return isinstance(obj, A2ATask) except (TypeError, AttributeError): return type(obj).__name__ == \"Task\" and hasattr(obj, \"status\")", "answer": "This function determines whether a given object is an A2A Task, using a type check with a fallback based on its name and attributes."}
{"question": "def _is_a2a_message(obj) -> bool: try: return isinstance(obj, A2AMessage) except (TypeError, AttributeError): return type(obj).__name__ == \"Message\" and hasattr(obj, \"role\")", "answer": "This function checks whether a given object is an instance of `A2AMessage` or, if that fails, whether it is a `Message` with a `role` attribute."}
{"question": "class ActiveStreamingTool(BaseModel): model_config = ConfigDict( arbitrary_types_allowed=True, extra='forbid', ) task: Optional[asyncio.Task] = None stream: Optional[LiveRequestQueue] = None", "answer": "This class defines a model for managing an active streaming tool with optional asynchronous task and live request queue attributes, enforcing strict configuration rules."}
{"question": "def agent_config_discriminator(v: Any) -> str: if isinstance(v, dict): agent_class: str = v.get(\"agent_class\", \"LlmAgent\") if agent_class in _ADK_AGENT_CLASSES: return agent_class return \"BaseAgent\" raise ValueError(f\"Invalid agent config: {v}\")", "answer": "This function determines and returns the appropriate agent class name from a given configuration dictionary, defaulting to \"BaseAgent\" if unrecognized, and raises an error for invalid inputs."}
{"question": "async def _run_async_impl( self, ctx: InvocationContext ) -> AsyncGenerator[Event, None]: raise NotImplementedError( f'_run_async_impl for {type(self)} is not implemented.' ) yield", "answer": "This asynchronous function is a placeholder that raises a \"not implemented\" error when called and is intended to yield events in the future."}
{"question": "def root_agent(self) -> BaseAgent: root_agent = self while root_agent.parent_agent is not None: root_agent = root_agent.parent_agent return root_agent", "answer": "This function returns the topmost parent agent in the hierarchy by traversing up through parent agents until none remain."}
{"question": "def find_agent(self, name: str) -> Optional[BaseAgent]: if self.name == name: return self return self.find_sub_agent(name)", "answer": "This function returns the current agent if its name matches the given name, otherwise it searches for and returns a matching sub-agent."}
{"question": "def canonical_before_agent_callbacks(self) -> list[_SingleAgentCallback]: if not self.before_agent_callback: return [] if isinstance(self.before_agent_callback, list): return self.before_agent_callback return [self.before_agent_callback]", "answer": "This function returns the stored \"before agent\" callbacks as a list, ensuring a single callback is wrapped in a list and returning an empty list if none exist."}
{"question": "def __set_parent_agent_for_sub_agents(self) -> BaseAgent: for sub_agent in self.sub_agents: if sub_agent.parent_agent is not None: raise ValueError( f'Agent `{sub_agent.name}` already has a parent agent, current' f' parent: `{sub_agent.parent_agent.name}`, trying to add:' f' `{self.name}`' ) sub_agent.parent_agent = self return self", "answer": "This function assigns the current agent as the parent to all its sub-agents, raising an error if any sub-agent already has a parent."}
{"question": "def _parse_config( cls: Type[SelfAgent], config: BaseAgentConfig, config_abs_path: str, kwargs: Dict[str, Any], ) -> Dict[str, Any]: return kwargs", "answer": "This function returns the provided keyword arguments dictionary without modification."}
{"question": "async def list_artifacts(self) -> list[str]: if self._invocation_context.artifact_service is None: raise ValueError(\"Artifact service is not initialized.\") return await self._invocation_context.artifact_service.list_artifact_keys( app_name=self._invocation_context.app_name, user_id=self._invocation_context.user_id, session_id=self._invocation_context.session.id, )", "answer": "This asynchronous function retrieves and returns a list of artifact keys for the current application, user, and session, raising an error if the artifact service is not initialized."}
{"question": "async def save_credential(self, auth_config: AuthConfig) -> None: if self._invocation_context.credential_service is None: raise ValueError(\"Credential service is not initialized.\") await self._invocation_context.credential_service.save_credential( auth_config, self )", "answer": "This function asynchronously saves authentication credentials using the initialized credential service, raising an error if the service is not available."}
{"question": "async def load_credential( self, auth_config: AuthConfig ) -> Optional[AuthCredential]: if self._invocation_context.credential_service is None: raise ValueError(\"Credential service is not initialized.\") return await self._invocation_context.credential_service.load_credential( auth_config, self )", "answer": "This function asynchronously loads and returns authentication credentials using a configured credential service, raising an error if the service is not initialized."}
{"question": "def validate_exactly_one_field(self) -> AgentRefConfig: code_provided = self.code is not None config_path_provided = self.config_path is not None if code_provided and config_path_provided: raise ValueError(\"Only one of `code` or `config_path` should be provided\") if not code_provided and not config_path_provided: raise ValueError(\"Exactly one of `code` or `config_path` must be provided\") return self", "answer": "This function ensures that exactly one of the `code` or `config_path` attributes is provided, raising an error otherwise."}
{"question": "def _resolve_agent_class(agent_class: str) -> type[BaseAgent]: agent_class_name = agent_class or \"LlmAgent\" if \".\" not in agent_class_name: agent_class_name = f\"google.adk.agents.{agent_class_name}\" agent_class = resolve_fully_qualified_name(agent_class_name) if inspect.isclass(agent_class) and issubclass(agent_class, BaseAgent): return agent_class raise ValueError( f\"Invalid agent class `{agent_class_name}`. It must be a subclass of BaseAgent.\" )", "answer": "This function resolves a given agent class name to its corresponding subclass of BaseAgent, defaulting to \"google.adk.agents.LlmAgent\" if unspecified, and raises an error if the resolution fails."}
{"question": "def _load_config_from_path(config_path: str) -> AgentConfig: if not os.path.exists(config_path): raise FileNotFoundError(f\"Config file not found: {config_path}\") with open(config_path, \"r\", encoding=\"utf-8\") as f: config_data = yaml.safe_load(f) return AgentConfig.model_validate(config_data)", "answer": "This function loads a YAML configuration file from a given path, validates it against the AgentConfig model, and returns the resulting configuration object."}
{"question": "def resolve_fully_qualified_name(name: str) -> Any: try: module_path, obj_name = name.rsplit(\".\", 1) module = importlib.import_module(module_path) return getattr(module, obj_name) except Exception as e: raise ValueError(f\"Invalid fully qualified name: {name}\") from e", "answer": "This function imports a module from a fully qualified name string and returns the specified attribute or object, raising a ValueError if the name is invalid."}
{"question": "def _resolve_agent_code_reference(code: str) -> Any: if \".\" not in code: raise ValueError(f\"Invalid code reference: {code}\") module_path, obj_name = code.rsplit(\".\", 1) module = importlib.import_module(module_path) obj = getattr(module, obj_name) if callable(obj): raise ValueError(f\"Invalid agent reference to a callable: {code}\") if not isinstance(obj, BaseAgent): raise ValueError(f\"Invalid agent reference to a non-agent instance: {code}\") return obj", "answer": "This function imports a module and retrieves a specified attribute by name, ensuring it is a non-callable instance of BaseAgent, and returns it or raises an error if validation fails."}
{"question": "def resolve_code_reference(code_config: CodeConfig) -> Any: if not code_config or not code_config.name: raise ValueError(\"Invalid CodeConfig.\") module_path, obj_name = code_config.name.rsplit(\".\", 1) module = importlib.import_module(module_path) obj = getattr(module, obj_name) if code_config.args and callable(obj): kwargs = {arg.name: arg.value for arg in code_config.args if arg.name} positional_args = [arg.value for arg in code_config.args if not arg.name] return obj(*positional_args, **kwargs) else: return obj", "answer": "This function imports a specified module, retrieves an object by name, and optionally calls it with provided positional and keyword arguments."}
{"question": "def increment_and_enforce_llm_calls_limit( self, run_config: Optional[RunConfig] ): self._number_of_llm_calls += 1 if ( run_config and run_config.max_llm_calls > 0 and self._number_of_llm_calls > run_config.max_llm_calls ): raise LlmCallsLimitExceededError( \"Max number of llm calls limit of\" f\" `{run_config.max_llm_calls}` exceeded\" )", "answer": "This function increments the count of LLM calls and raises an error if the count exceeds the maximum allowed limit specified in the run configuration."}
{"question": "def should_pause_invocation(self, event: Event) -> bool: if not self.is_resumable: return False if not event.long_running_tool_ids or not event.get_function_calls(): return False for fc in event.get_function_calls(): if fc.id in event.long_running_tool_ids: return True return False", "answer": "This function determines whether to pause execution based on the presence of resumable state and matching long-running tool function calls in the given event."}
{"question": "def _find_matching_function_call( self, function_response_event: Event ) -> Optional[Event]: function_responses = function_response_event.get_function_responses() if not function_responses: return None function_call_id = function_responses[0].id events = self._get_events(current_invocation=True) for event in reversed(events[:-1]): if any(fc.id == function_call_id for fc in event.get_function_calls()): return event return None", "answer": "This function searches past events in the current invocation to find and return the event whose function call matches the ID of the first function response in the given event."}
{"question": "def _get_last_human_messages(events: list[Event]) -> list[HumanMessage]: messages = [] for event in reversed(events): if messages and event.author != 'user': break if event.author == 'user' and event.content and event.content.parts: messages.append(HumanMessage(content=event.content.parts[0].text)) return list(reversed(messages))", "answer": "This function retrieves the most recent consecutive human-authored messages from a list of events, preserving their original order."}
{"question": "def _get_messages( self, events: list[Event] ) -> list[Union[HumanMessage, AIMessage]]: if self.graph.checkpointer: return _get_last_human_messages(events) else: return self._get_conversation_with_agent(events)", "answer": "This function returns either the last human messages or the full conversation with the agent based on whether a checkpointer is present in the graph."}
{"question": "def _get_conversation_with_agent( self, events: list[Event] ) -> list[Union[HumanMessage, AIMessage]]: messages = [] for event in events: if not event.content or not event.content.parts: continue if event.author == 'user': messages.append(HumanMessage(content=event.content.parts[0].text)) elif event.author == self.name: messages.append(AIMessage(content=event.content.parts[0].text)) return messages", "answer": "This function converts a list of event objects into a sequence of human and AI message objects based on the event author and content."}
{"question": "def __init__(self): try: asyncio.get_running_loop() except RuntimeError: loop = asyncio.new_event_loop() asyncio.set_event_loop(loop) self._queue = asyncio.Queue()", "answer": "This function initializes an asynchronous event loop if none is running and creates an asyncio queue for the instance."}
{"question": "def canonical_model(self) -> BaseLlm: if isinstance(self.model, BaseLlm): return self.model elif self.model: # model is non-empty str return LLMRegistry.new_llm(self.model) else: ancestor_agent = self.parent_agent while ancestor_agent is not None: if isinstance(ancestor_agent, LlmAgent): return ancestor_agent.canonical_model ancestor_agent = ancestor_agent.parent_agent raise ValueError(f'No model found for {self.name}.')", "answer": "This function returns the current model as a `BaseLlm` instance, creating or inheriting it from ancestor agents if necessary, and raises an error if none is found."}
{"question": "async def canonical_tools( self, ctx: ReadonlyContext = None ) -> list[BaseTool]: resolved_tools = [] multiple_tools = len(self.tools) > 1 for tool_union in self.tools: resolved_tools.extend( await _convert_tool_union_to_tools( tool_union, ctx, self.model, multiple_tools ) ) return resolved_tools", "answer": "This function asynchronously resolves and returns a list of tool instances by converting each tool union in the object's tool collection using the provided context and model."}
{"question": "def canonical_before_model_callbacks( self, ) -> list[_SingleBeforeModelCallback]: if not self.before_model_callback: return [] if isinstance(self.before_model_callback, list): return self.before_model_callback return [self.before_model_callback]", "answer": "This function returns a list of before-model callbacks, ensuring that a single callback is wrapped in a list and returning an empty list if none exist."}
{"question": "def canonical_after_model_callbacks(self) -> list[_SingleAfterModelCallback]: if not self.after_model_callback: return [] if isinstance(self.after_model_callback, list): return self.after_model_callback return [self.after_model_callback]", "answer": "This function returns a list of after-model callbacks, ensuring that a single callback is wrapped in a list and returning an empty list if none exist."}
{"question": "def collect_agents(agent): agents.append(agent.name) if hasattr(agent, 'sub_agents') and agent.sub_agents: for sub_agent in agent.sub_agents: collect_agents(sub_agent) collect_agents(self.root_agent) return agents", "answer": "This function recursively collects the names of a root agent and all its sub-agents into a list."}
{"question": "def _parse_config( cls: type[LoopAgent], config: LoopAgentConfig, config_abs_path: str, kwargs: Dict[str, Any], ) -> Dict[str, Any]: if config.max_iterations: kwargs['max_iterations'] = config.max_iterations return kwargs", "answer": "This function updates the given keyword arguments with a maximum iterations value from the configuration if it is set, and returns the updated dictionary."}
{"question": "def _create_branch_ctx_for_sub_agent( agent: BaseAgent, sub_agent: BaseAgent, invocation_context: InvocationContext, ) -> InvocationContext: invocation_context = invocation_context.model_copy() branch_suffix = f'{agent.name}.{sub_agent.name}' invocation_context.branch = ( f'{invocation_context.branch}.{branch_suffix}' if invocation_context.branch else branch_suffix ) return invocation_context", "answer": "This function creates a copy of the given invocation context and updates its branch attribute to include the names of the specified agent and sub-agent."}
{"question": "async def process_an_agent(events_for_one_agent): try: async for event in events_for_one_agent: resume_signal = asyncio.Event() await queue.put((event, resume_signal)) await resume_signal.wait() finally: await queue.put((sentinel, None))", "answer": "This function asynchronously processes events for a single agent by queuing each event with a resume signal and waits for the signal before continuing, then sends a sentinel when finished."}
{"question": "class ParallelAgentConfig(BaseAgentConfig): model_config = ConfigDict( extra=\"forbid\", ) agent_class: str = Field( default=\"ParallelAgent\", description=\"The value is used to uniquely identify the ParallelAgent class.\", )", "answer": "This class defines configuration settings for a ParallelAgent, including a strict model configuration and a default identifier for the agent class."}
{"question": "def validate_max_llm_calls(cls, value: int) -> int: if value == sys.maxsize: raise ValueError(f'max_llm_calls should be less than {sys.maxsize}.') elif value <= 0: logger.warning( 'max_llm_calls is less than or equal to 0. This will result in' ' no enforcement on total number of llm calls that will be made for a' ' run. This may not be ideal, as this could result in a never' ' ending communication between the model and the agent in certain' ' cases.', ) return value", "answer": "This function validates the maximum number of LLM calls, raising an error if it equals the system's maximum size and logging a warning if it is zero or negative."}
{"question": "class SequentialAgentConfig(BaseAgentConfig): model_config = ConfigDict( extra=\"forbid\", ) agent_class: str = Field( default=\"SequentialAgent\", description=\"The value is used to uniquely identify the SequentialAgent class.\", )", "answer": "This class defines configuration settings for a SequentialAgent, including a strict model configuration and a default identifier for the agent class."}
{"question": "def __init__( self, llm: BaseLlm, prompt_template: Optional[str] = None, ): self._llm = llm self._prompt_template = prompt_template or self._DEFAULT_PROMPT_TEMPLATE", "answer": "This function initializes an object with a language model instance and a prompt template, using a default template if none is provided."}
{"question": "def _format_events_for_prompt(self, events: list[Event]) -> str: formatted_history = [] for event in events: if event.content and event.content.parts: for part in event.content.parts: if part.text: formatted_history.append(f'{event.author}: {part.text}') return '\\n'.join(formatted_history)", "answer": "This function generates a newline-separated string of author-text pairs from the non-empty text parts of a list of events."}
{"question": "def is_artifact_ref(artifact: types.Part) -> bool: return bool( artifact.file_data and artifact.file_data.file_uri and artifact.file_data.file_uri.startswith(\"artifact://\") )", "answer": "This function checks whether a given artifact has a file URI that starts with \"artifact://\"."}
{"question": "def _iter_artifact_dirs(root: Path) -> list[Path]: if not root.exists(): return [] artifact_dirs: list[Path] = [] for dirpath, dirnames, _ in os.walk(root): current = Path(dirpath) if (current / \"versions\").exists(): artifact_dirs.append(current) dirnames.clear() return artifact_dirs", "answer": "This function returns a list of directories under the given root that contain a \"versions\" subdirectory, stopping further traversal within those directories."}
{"question": "def _strip_user_namespace(filename: str) -> str: if _file_has_user_namespace(filename): return filename[len(_USER_NAMESPACE_PREFIX):] return filename", "answer": "This function removes a predefined user namespace prefix from a filename if it exists."}
{"question": "def _to_posix_path(path_value: str) -> PurePosixPath: if \"\\\\\" in path_value: path_value = PureWindowsPath(path_value).as_posix() return PurePosixPath(path_value)", "answer": "This function converts a given file path string to a POSIX-style path, handling Windows-style backslashes if present."}
{"question": "class FileArtifactVersion(ArtifactVersion): model_config = ConfigDict( alias_generator=alias_generators.to_camel, populate_by_name=True, ) file_name: str = Field( description=\"Original filename supplied by the caller.\" )", "answer": "This class defines a file-based artifact version with configuration for camelCase field aliases and a stored original filename."}
{"question": "def _scope_root( self, app_name: str, user_id: str, session_id: Optional[str], filename: str, ) -> Path: base = self._base_root(app_name, user_id) if _is_user_scoped(session_id, filename): return _user_artifacts_dir(base) if not session_id: raise ValueError( \"Session ID must be provided for session-scoped artifacts.\" ) return _session_artifacts_dir(base, session_id)", "answer": "This function determines and returns the appropriate filesystem path for storing artifacts based on application name, user ID, session ID, and filename, enforcing session ID requirements for session-scoped artifacts."}
{"question": "def _latest_metadata(self, artifact_dir: Path) -> Optional[FileArtifactVersion]: versions = _list_versions_on_disk(artifact_dir) if not versions: return None return _read_metadata(_metadata_path(artifact_dir, versions[-1]))", "answer": "This function retrieves and returns the metadata of the most recent file artifact version from a specified directory, or None if no versions exist."}
{"question": "async def list_artifact_keys( self, *, app_name: str, user_id: str, session_id: Optional[str] = None, ) -> list[str]: return await asyncio.to_thread( self._list_artifact_keys_sync, app_name, user_id, session_id, )", "answer": "This asynchronous function retrieves a list of artifact keys for a given application, user, and optional session by executing a synchronous method in a separate thread."}
{"question": "def _delete_artifact_sync( self, app_name: str, user_id: str, filename: str, session_id: Optional[str], ) -> None: artifact_dir = self._artifact_dir( app_name=app_name, user_id=user_id, session_id=session_id, filename=filename, ) if artifact_dir.exists(): shutil.rmtree(artifact_dir) logger.debug(\"Deleted artifact %s at %s\", filename, artifact_dir)", "answer": "This function deletes the specified artifact directory for a given application, user, and optional session if it exists, and logs the deletion."}
{"question": "def _read_metadata(path: Path) -> Optional[FileArtifactVersion]: if not path.exists(): return None try: return FileArtifactVersion.model_validate_json( path.read_text(encoding=\"utf-8\") ) except ValidationError as exc: logger.warning(\"Failed to parse metadata at %s: %s\", path, exc) return None except ValueError as exc: logger.warning(\"Invalid metadata JSON at %s: %s\", path, exc) return None", "answer": "This function reads and validates JSON metadata from a given file path, returning a `FileArtifactVersion` object if successful or `None` if the file is missing or invalid."}
{"question": "def __init__(self, bucket_name: str, **kwargs): self.bucket_name = bucket_name self.storage_client = storage.Client(**kwargs) self.bucket = self.storage_client.bucket(self.bucket_name)", "answer": "This function initializes an object with a specified Google Cloud Storage bucket by creating a storage client and retrieving the corresponding bucket."}
{"question": "async def list_artifact_keys( self, *, app_name: str, user_id: str, session_id: Optional[str] = None ) -> list[str]: return await asyncio.to_thread( self._list_artifact_keys, app_name, user_id, session_id, )", "answer": "This asynchronous function retrieves a list of artifact keys for a given application, user, and optional session by executing the retrieval in a separate thread."}
{"question": "async def delete_artifact( self, *, app_name: str, user_id: str, filename: str, session_id: Optional[str] = None, ) -> None: path = self._artifact_path(app_name, user_id, filename, session_id) if not self.artifacts.get(path): return None self.artifacts.pop(path, None)", "answer": "This asynchronous function removes a specified artifact from storage if it exists."}
{"question": "async def load_credential( self, auth_config: AuthConfig, callback_context: CallbackContext, ) -> Optional[AuthCredential]: credential_bucket = self._get_bucket_for_current_context(callback_context) return credential_bucket.get(auth_config.credential_key)", "answer": "This function asynchronously retrieves an authentication credential from a context-specific storage bucket using a provided configuration key."}
{"question": "async def save_credential( self, auth_config: AuthConfig, callback_context: CallbackContext, ) -> None: credential_bucket = self._get_bucket_for_current_context(callback_context) credential_bucket[auth_config.credential_key] = ( auth_config.exchanged_auth_credential )", "answer": "This function asynchronously stores an exchanged authentication credential in a context-specific bucket using the provided credential key."}
{"question": "def _get_bucket_for_current_context( self, callback_context: CallbackContext ) -> str: app_name = callback_context._invocation_context.app_name user_id = callback_context._invocation_context.user_id if app_name not in self._credentials: self._credentials[app_name] = {} if user_id not in self._credentials[app_name]: self._credentials[app_name][user_id] = {} return self._credentials[app_name][user_id]", "answer": "This function retrieves or initializes a credentials bucket for the given application's user within the current callback context."}
{"question": "def register( self, credential_type: AuthCredentialTypes, exchanger_instance: BaseCredentialExchanger, ) -> None: self._exchangers[credential_type] = exchanger_instance", "answer": "This function registers a credential exchanger instance for a specified credential type in the object's internal mapping."}
{"question": "def get_exchanger( self, credential_type: AuthCredentialTypes ) -> Optional[BaseCredentialExchanger]: return self._exchangers.get(credential_type)", "answer": "This function retrieves and returns the credential exchanger associated with a given credential type, or None if it does not exist."}
{"question": "def _normalize_auth_uri(self, auth_uri: str | None) -> str | None: if auth_uri and auth_uri.endswith(\"#\"): return auth_uri[:-1]", "answer": "This function removes a trailing \"#\" from the given authentication URI if present."}
{"question": "def from_flow(flow: OAuthFlows) -> \"OAuthGrantType\": if flow.clientCredentials: return OAuthGrantType.CLIENT_CREDENTIALS if flow.authorizationCode: return OAuthGrantType.AUTHORIZATION_CODE if flow.implicit: return OAuthGrantType.IMPLICIT if flow.password: return OAuthGrantType.PASSWORD return None", "answer": "This function determines and returns the appropriate OAuth grant type based on the provided OAuthFlows configuration."}
{"question": "async def _load_from_credential_service( self, callback_context: CallbackContext ) -> Optional[AuthCredential]: credential_service = callback_context._invocation_context.credential_service if credential_service: return await callback_context.load_credential(self._auth_config) return None", "answer": "This function asynchronously retrieves and returns authentication credentials from a credential service if available, otherwise returns None."}
{"question": "async def _load_from_auth_response( self, callback_context: CallbackContext ) -> Optional[AuthCredential]: return callback_context.get_auth_response(self._auth_config)", "answer": "This asynchronous function retrieves and returns authentication credentials from the provided callback context using the stored authentication configuration."}
{"question": "class AuthorizationServerMetadata(BaseModel): issuer: str authorization_endpoint: str token_endpoint: str scopes_supported: Optional[List[str]] = None registration_endpoint: Optional[str] = None", "answer": "This class defines a data model for storing metadata about an authorization server, including its endpoints and supported scopes."}
{"question": "def load_test_case(test_case_dir: Path) -> TestSpec: spec_file = test_case_dir / \"spec.yaml\" with open(spec_file, \"r\", encoding=\"utf-8\") as f: data: dict[str, Any] = yaml.safe_load(f) return TestSpec.model_validate(data)", "answer": "This function reads a YAML specification file from a given directory and returns a validated `TestSpec` object created from its contents."}
{"question": "def load_recorded_session(test_case_dir: Path) -> Optional[Session]: session_file = test_case_dir / \"generated-session.yaml\" if not session_file.exists(): return None with open(session_file, \"r\", encoding=\"utf-8\") as f: session_data = yaml.safe_load(f) if not session_data: return None", "answer": "This function attempts to load and parse a recorded session from a YAML file in the specified directory, returning None if the file is missing or empty."}
{"question": "def _generate_mismatch_message( context: str, actual_value: str, recorded_value: str ) -> str: return ( f\"{context} mismatch - \\nActual: \\n{actual_value} \\nRecorded:\" f\" \\n{recorded_value}\" )", "answer": "This function creates a formatted message indicating a mismatch between an actual value and a recorded value within a given context."}
{"question": "def __init__( self, base_url: str = \"http://127.0.0.1:8000\", timeout: float = 30.0 ): self.base_url = base_url.rstrip(\"/\") self.timeout = timeout self._client: Optional[httpx.AsyncClient] = None", "answer": "This function initializes an object with a base URL, a timeout value, and prepares an asynchronous HTTP client placeholder."}
{"question": "async def _get_client(self) -> AsyncGenerator[httpx.AsyncClient, None]: if self._client is None: self._client = httpx.AsyncClient( base_url=self.base_url, timeout=httpx.Timeout(self.timeout), ) try: yield self._client finally: pass", "answer": "This asynchronous function returns an HTTPX AsyncClient instance, creating it if necessary, and yields it for use."}
{"question": "async def close(self) -> None: if self._client: await self._client.aclose() self._client = None", "answer": "This asynchronous function closes the existing client connection if present and resets the client reference to None."}
{"question": "def success_rate(self) -> float: if self.total_tests == 0: return 0.0 return (self.passed_tests / self.total_tests) * 100", "answer": "This function calculates and returns the percentage of passed tests out of the total tests, or 0.0 if no tests were run."}
{"question": "def _print_test_header(mode: str) -> None: click.echo(\"=\" * 50) click.echo(f\"Running ADK conformance tests in {mode} mode...\") click.echo(\"=\" * 50)", "answer": "This function prints a formatted header indicating that ADK conformance tests are running in the specified mode."}
{"question": "def _print_test_case_result(result: _TestResult) -> None: if result.success: click.secho(\" ✓ PASS\", fg=\"green\") else: click.secho(\" ✗ FAIL\", fg=\"red\") if result.error_message: click.secho(f\"Error: {result.error_message}\", fg=\"red\", err=True)", "answer": "This function displays a colored pass or fail message for a test case, optionally showing an error message if the test fails."}
{"question": "def __init__(self, *, name: str = \"adk_recordings\") -> None: super().__init__(name=name) self._invocation_states: dict[str, _InvocationRecordingState] = {}", "answer": "This constructor initializes the object with a specified name and an empty dictionary for tracking invocation states."}
{"question": "async def before_run_callback( self, *, invocation_context: InvocationContext ) -> Optional[types.Content]: ctx = CallbackContext(invocation_context) if self._is_record_mode_on(ctx): self._create_invocation_state(ctx) return None", "answer": "This asynchronous function initializes invocation state if record mode is enabled before running a process."}
{"question": "class Recordings(BaseModel): model_config = ConfigDict( extra=\"forbid\", ) recordings: list[Recording] = Field(default_factory=list)", "answer": "This class defines a data model that stores a list of `Recording` objects while forbidding any unspecified extra fields."}
{"question": "def __init__(self, *, name: str = \"adk_replay\") -> None: super().__init__(name=name) self._invocation_states: dict[str, _InvocationReplayState] = {}", "answer": "This constructor initializes the object with a specified name and an empty dictionary for tracking invocation states."}
{"question": "async def before_run_callback( self, *, invocation_context: InvocationContext ) -> Optional[types.Content]: ctx = CallbackContext(invocation_context) if self._is_replay_mode_on(ctx): self._load_invocation_state(ctx) return None", "answer": "This function initializes a callback context from the given invocation context, loads invocation state if replay mode is active, and returns no content."}
{"question": "async def after_run_callback( self, *, invocation_context: InvocationContext ) -> None: ctx = CallbackContext(invocation_context) if not self._is_replay_mode_on(ctx): return None self._invocation_states.pop(ctx.invocation_id, None) logger.debug(\"Cleaned up replay state for invocation %s\", ctx.invocation_id)", "answer": "This function checks if replay mode is active for a given invocation context and, if so, removes its state and logs the cleanup."}
{"question": "def get_finished_spans(self, session_id: str): trace_ids = self.trace_dict.get(session_id, None) if trace_ids is None or not trace_ids: return [] return [x for x in self._spans if x.context.trace_id in trace_ids]", "answer": "This function retrieves all spans associated with a given session ID whose trace IDs match those stored for that session."}
{"question": "def _otel_env_vars_enabled() -> bool: return any([ os.getenv(endpoint_var) for endpoint_var in [ otel_env.OTEL_EXPORTER_OTLP_ENDPOINT, otel_env.OTEL_EXPORTER_OTLP_TRACES_ENDPOINT, otel_env.OTEL_EXPORTER_OTLP_METRICS_ENDPOINT, otel_env.OTEL_EXPORTER_OTLP_LOGS_ENDPOINT, ] ])", "answer": "This function checks if any of several OpenTelemetry endpoint environment variables are set and returns True if at least one is found."}
{"question": "def _get_project_id_and_location_from_resource_name( self, resource_name: str, pattern: str ) -> tuple[str, str]: match = re.fullmatch(pattern, resource_name) if not match: raise ValueError(f'resource name {resource_name} is not valid.') return match.groups()[0], match.groups()[1]", "answer": "This function validates a resource name against a given pattern and returns the extracted project ID and location as a tuple."}
{"question": "def get_execution_id(self) -> Optional[str]: if _SESSION_ID_KEY not in self._context: return None return self._context[_SESSION_ID_KEY]", "answer": "This function retrieves and returns the execution ID from the context if it exists, otherwise returns None."}
{"question": "def add_processed_file_names(self, file_names: [str]): if _PROCESSED_FILE_NAMES_KEY not in self._context: self._context[_PROCESSED_FILE_NAMES_KEY] = [] self._context[_PROCESSED_FILE_NAMES_KEY].extend(file_names)", "answer": "This function adds a list of file names to a context entry for processed files, creating the entry if it does not exist."}
{"question": "def increment_error_count(self, invocation_id: str): if _ERROR_COUNT_KEY not in self._session_state: self._session_state[_ERROR_COUNT_KEY] = {} self._session_state[_ERROR_COUNT_KEY][invocation_id] = ( self.get_error_count(invocation_id) + 1 )", "answer": "This function increments the stored error count for a given invocation ID within the session state."}
{"question": "def reset_error_count(self, invocation_id: str): if _ERROR_COUNT_KEY not in self._session_state: return if invocation_id in self._session_state[_ERROR_COUNT_KEY]: del self._session_state[_ERROR_COUNT_KEY][invocation_id]", "answer": "This function removes the stored error count for a given invocation ID from the session state if it exists."}
{"question": "def _get_code_executor_context(self, session_state: State) -> dict[str, Any]: if _CONTEXT_KEY not in session_state: session_state[_CONTEXT_KEY] = {} return session_state[_CONTEXT_KEY]", "answer": "This function retrieves a code executor context dictionary from the given session state, creating and storing an empty one if it does not already exist."}
{"question": "def _build_docker_image(self): if not self.docker_path: raise ValueError('Docker path is not set.') if not os.path.exists(self.docker_path): raise FileNotFoundError(f'Invalid Docker path: {self.docker_path}') logger.info('Building Docker image...') self._client.images.build( path=self.docker_path, tag=self.image, rm=True, ) logger.info('Docker image: %s built.', self.image)", "answer": "This function validates the Docker path and then builds a Docker image using the specified path and tag."}
{"question": "def _verify_python_installation(self): exec_result = self._container.exec_run(['which', 'python3']) if exec_result.exit_code != 0: raise ValueError('python3 is not installed in the container.')", "answer": "This function checks if Python 3 is installed in a container and raises an error if it is not found."}
{"question": "def __init__(self, **data): if 'stateful' in data and data['stateful']: raise ValueError('Cannot set `stateful=True` in UnsafeLocalCodeExecutor.') if 'optimize_data_file' in data and data['optimize_data_file']: raise ValueError( 'Cannot set `optimize_data_file=True` in UnsafeLocalCodeExecutor.' ) super().__init__(**data)", "answer": "This constructor initializes the object while preventing the `stateful` or `optimize_data_file` options from being set to `True` by raising errors if they are."}
{"question": "def __init__(self, message=\"The requested item was not found.\"): self.message = message super().__init__(self.message)", "answer": "This function initializes an object with a customizable error message and passes it to its superclass constructor."}
{"question": "def create_eval_set_result( app_name: str, eval_set_id: str, eval_case_results: list[EvalCaseResult], ) -> EvalSetResult: timestamp = time.time() eval_set_result_id = f\"{app_name}_{eval_set_id}_{timestamp}\" eval_set_result_name = _sanitize_eval_set_result_name(eval_set_result_id) eval_set_result = EvalSetResult( eval_set_result_id=eval_set_result_id, eval_set_result_name=eval_set_result_name, eval_set_id=eval_set_id, eval_case_results=eval_case_results, creation_timestamp=timestamp, ) return eval_set_result", "answer": "This function generates and returns an `EvalSetResult` object with a unique ID, sanitized name, associated evaluation set data, and a creation timestamp."}
{"question": "def get_eval_set_from_app_and_id( eval_sets_manager: EvalSetsManager, app_name: str, eval_set_id: str ) -> EvalSet: eval_set = eval_sets_manager.get_eval_set(app_name, eval_set_id) if not eval_set: raise NotFoundError(f\"Eval set `{eval_set_id}` not found.\") return eval_set", "answer": "This function retrieves an evaluation set by application name and ID from the given manager, raising an error if it does not exist."}
{"question": "def get_eval_case_from_eval_set( eval_set: EvalSet, eval_case_id: str ) -> Optional[EvalCase]: eval_case_to_find = None for eval_case in eval_set.eval_cases: if eval_case.eval_id == eval_case_id: eval_case_to_find = eval_case break return eval_case_to_find", "answer": "This function searches an evaluation set for an evaluation case with a matching ID and returns it if found, otherwise returns None."}
