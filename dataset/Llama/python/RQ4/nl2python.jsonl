{"question": "Write a function that Returns a index of the per code_id positions of Rows in the file: {core_id1: []} TODO: Generalize this so we can create indexes on any field ?", "answer": "def _build_coreid_index(self): index = {} pos = 0 for l in self: tmp = ExtensionRow(l, self.file_descriptor) if tmp.core_id not in index: index[tmp.core_id] = [pos] else: index[tmp.core_id].append(pos) pos = pos + 1 return index"}
{"question": "Write a function that str() and repr() both recurse over their fields with whichever function was used initially. Both are protected from recursive cycles with the help of reprlib.", "answer": "def _fmt_helper(self, fmt): return '{}({})'.format( self.__class__.__name__, ', '.join('{}={}'.format(f.name, fmt(getattr(self, f.name))) for f in self._struct))"}
{"question": "Write a function that decipher a message then check if padding is good with unpad_verifier()", "answer": "def decrypt( enc): decipher = AES.new(KEY, AES.MODE_CBC, IV ) plaintext, signature_2, sig_c = unpad_verifier(decipher.decrypt( enc )) if signature_2 != sig_c: return 0 return plaintext"}
{"question": "Write a function that Utility function to read the README file. Used for the long_description. It's nice, because now 1) we have a top level README file and 2) it's easier to type in the README file than to put a raw string in below ...", "answer": "def read(fname): return open(os.path.join(os.path.dirname(__file__), fname)).read()"}
{"question": "Write a function that in the comments explaining results, X(t) represents a data series in graphite with the \"data_exists_as\" unit, and Y(t) represents the data series we want to graph, in the \"user_asked_for\" unit. the results of run_scenario should give the necessary steps to convert X(t) to Y(t).", "answer": "def test_straightforward_conversion(self): self.assertEqual(run_scenario(user_asked_for='B', data_exists_as='b'), ('b', 'B', 0.125, None, 'si')) # 0.125 * X(t) b = Y(t) B"}
{"question": "Write a function that d(X(t) kb)/dt kb/s * 86400 s/d * 1B/8b * 1000 B/kB = Y(t) B/d 86400 * 1000 / 8 = 10800000", "answer": "def test_unrecognized_unit_derive(self): self.assertEqual(run_scenario(user_asked_for='Cheese/w', data_exists_as='Cheese'), ('Cheese', 'Cheese/w', 604800.0, 'derive', 'si')) # d(604800.0 * X(t) Cheese)/dt = Y(t) Cheese/w"}
{"question": "Write a function that The second pass removes managers that manage no packages, a potential side-effect of the first pass. This step must be applied repeatedly until the blueprint reaches a steady state.", "answer": "def package(manager, package, version): if package not in b.packages: return if 0 == len(b.packages[package]): del b.packages[package] del b.packages[self.managers[package]][package]"}
{"question": "Write a function that If a pk isn't editable, then it won't be on the form, so we need to add it here so we can tell which object is which when we get the data back. Generally, pk.editable should be false, but for some reason, auto_created pk fields and AutoField's editable attribute is True, so check for that as well.", "answer": "def pk_is_not_editable(pk): return ( (not pk.editable) or (pk.auto_created or isinstance(pk, AutoField)) or ( pk.remote_field and pk.remote_field.parent_link and pk_is_not_editable(pk.remote_field.model._meta.pk) ) )"}
{"question": "Write a function that this method will be used to create object labels by the QuerySetIterator. Override it to customize the label.", "answer": "def label_from_instance(self, obj): \"\"\" This method is used to convert objects into strings; it's used to generate the labels for the choices presented by this object. Subclasses can override this method to customize the display of the choices. \"\"\" return smart_text(obj)"}
{"question": "Write a function that Use a timer to stop the subprocess if the timeout is exceeded. This helps prevent very subtle issues with deadlocks on reading subprocess output. See: http://stackoverflow.com/a/10012262", "answer": "def timeout_exceeded(p): # Stop the subprocess and kill the whole program. p.kill() raise AdaLinkError('OpenOCD process exceeded timeout!')"}
{"question": "Write a function that Write a procedure, shift, which takes as its input a lowercase letter, a-z and returns the next letter in the alphabet after it, with 'a' following 'z'.", "answer": "def shift(letter): if letter == 'z': letter = 'a' else: letter = chr(ord(letter) + 1) return letter"}
{"question": "Write a function that Write tests here. If you need extra test classes add them to the test suite in runner/path_to_enlightenment.py", "answer": "def test_extra_credit_task(self): pass"}
{"question": "Write a function that Write an oracle function that uses the private key to answer the question \"is the plaintext of this message even or odd\" (is the last bit of the message 0 or 1). Imagine for instance a server that accepted RSA-encrypted messages and checked the parity of their decryption to validate them, and spat out an error if they were of the wrong parity.", "answer": "def rsa_oracle_isodd(key, cipher): plain = mypow(cipher, key['d'], key['N']); return (plain & 1);"}
{"question": "Write a function that Write out all our subfiles to their disk files. The file data is unencrypted/uncompressed.", "answer": "def write_all_subfiles(self, base_dir): if not self.fileinfo: return assert(len(self.subfile_data) == len(self.fileinfo)) for i in range(len(self.fileinfo)): fi = self.fileinfo[i] filename = os.path.join(base_dir, self.names[fi.ni]) self.write_subfile(i, filename)"}
{"question": "Write a function that Write a function that calculates slope using a 3x3 window. This will be passed to the SciPy filter function below.", "answer": "def slope(data, cell_width, cell_height): \"\"\"Calculates slope using a 3x3 window. data - 1D array containing the 9 pixel values, starting in the upper left and going left to right and down cell_width - pixel width in the same units as the data cell_height - pixel height in the same units as the data \"\"\" rise = ((data[6] + (2 * data[7]) + data[8]) - (data[0] + (2 * data[1]) + data[2])) / \\ (8 * cell_height) run = ((data[2] + (2 * data[5]) + data[8]) - (data[0] + (2 * data[3]) + data[6])) / \\ (8 * cell_width) dist = np.sqrt(np.square(rise) + np.square(run)) return np.arctan(dist) * 180 / np.pi"}
{"question": "Write a function that write changes to database. auto-called by add, update, and delete", "answer": "def write(self): f = open(self.DB_NAME, \"w\") for key, val in self.data.items(): f.write(key + \",\") f.write(val[0] + \",\") f.write(val[1] + \",\") f.write(val[2] + \"\\n\") f.close()"}
{"question": "Write a function that Generates samples of size, sampleSize, from a normal distribution, and plots a probability histogram of each sample & the pdf", "answer": "def plot_normal_hist(alpha, beta, color, fitLineColor, linewidth, sampleSize, numBins): mu, sigma = alpha, beta # mean and standard deviation. usually mu, sigma = 0, 1 sample = np.random.normal(mu, sigma, sampleSize) count, bins, ignored = plt.hist(sample, numBins, normed=True, color=color) plt.plot(bins, 1/(sigma * np.sqrt(2 * np.pi)) * np.exp( - (bins - mu)**2 / (2 * sigma**2) ), linewidth=2, color=fitLineColor) plt.xlabel('x') plt.ylabel('p(x|%s,%s)'% (alpha,beta)) title(\"Normal%s Sample of Size %s\" % ((alpha,beta), sampleSize)) plt.show() return"}
{"question": "Write a function that Generates the BE symbol for the Compute Function class_name::fn_name<templated_type>. Does not handle varargs. TODO: this is a stopgap. ComputeFunctions are being removed and we can use the symbol lookup code in the BE.", "answer": "def symbol(class_name, fn_name, templated_type = None): sym = '_ZN6impala' sym += str(len(class_name)) + class_name sym += str(len(fn_name)) + fn_name if templated_type == None: sym += 'EPNS_4ExprEPNS_8TupleRowE' else: sym += 'I' sym += templated_type_symbol_map[templated_type] sym += 'EEPvPNS_4ExprEPNS_8TupleRowE' return sym"}
{"question": "Write a function that generates data sets to test the continous version of the mixed forest", "answer": "def lin_data_cont_predictors(n=100, m=1): X = SP.random.randn(n,m) beta = SP.random.randn(m,1) beta[1:]=0 y = SP.dot(X,beta) return X, y"}
{"question": "Write a function that generate an ast node for a call to an external function", "answer": "def fmt_reg_for_call(reg, slot, node): '''reg -> slot_ty -> c_ast -> c_ast''' reg_ast = fmt_reg(mnem, reg, slot) return ep_ct.simple_cast(node, reg_ast)"}
{"question": "Write a function that Generate lines from fileiter. If whilematch is true, continue reading while the regexp object pat matches line. If whilematch is false, lines are read so long as pat doesn't match them. In any case, the first line that doesn't match pat (when whilematch is true), or that does match pat (when whilematch is false), is lost, and fileiter will resume at the line following it.", "answer": "def read(fileiter, pat, whilematch): for line in fileiter: if bool(pat.match(line)) == whilematch: yield line else: break"}
{"question": "Write a function that def hotp(self, counter=4): \"\"\"Generate a HOTP code. :param counter: HOTP is a counter based algorithm. \"\"\" # https://tools.ietf.org/html/rfc4226 msg = struct.pack('>Q', counter) digest = hmac.new(to_bytes(self.secret), msg, hashlib.sha1).digest() ob = digest[19] if python_version == 2: ob = ord(ob) pos = ob & 15 base = struct.unpack('>I', digest[pos:pos + 4])[0] & 0x7fffffff token = base % 1000000 return token", "answer": "def hotp(self, counter=4): based_secret = base64.b32decode(self.secret, True) struct_secret = struct.pack(\">Q\", counter) hmac_secret = hmac.new(based_secret, struct_secret, hashlib.sha1).digest() ob = hmac_secret[19] if python_version == 2: ob = ord(ob) ord_secret = ob & 15 token_secret = (struct.unpack(\">I\", hmac_secret[ord_secret:ord_secret+4])[0] & 0x7fffffff) % 1000000 return token_secret"}
{"question": "Write a function that Generate a PortRef for this port on the given SimObject with the given name", "answer": "def makeRef(self, simobj): return PortRef(simobj, self.name, self.role)"}
{"question": "Write a function that generate a list of prefixes for a path root has no prefixes", "answer": "def generate_prefixes( path ): prefixes = [] names = filter( lambda x: len(x) > 0, path.strip(\"/\").split(\"/\") ) p = \"/\" prefixes.append(p) for name in names: p += name + \"/\" prefixes.append(p) return prefixes"}
{"question": "Write a function that Generate all combinations of CombineCases. inTupleList a list of tuples of value-lists combFuncList a list of comb* functions to combine", "answer": "def genComponentCases(inCompLists, combFuncList): res = [] for comps in inCompLists: maxLen = reduce(max, [len(values) for values in comps]) comps = [repeatToLength(values, maxLen) for values in comps] comps = [shuffled(values) for values in comps] for combFunc in combFuncList: res += [CombineCase(comps, combFunc)] return res"}
{"question": "Write a function that generate set of search directions (+- s_i e_i | i = 1, ..., N)", "answer": "def unit(i, N): \"return ith unit vector in R^N\" arr = np.zeros(N) arr[i] = 1.0 return arr"}
{"question": "Write a function that get the outward rates for the first n-1 states the last state has outward rate of 0", "answer": "def symbolic_full_matrix_to_rates(self, x): x = TT.as_tensor_variable(x) flat_x = x.flatten() indexes = TT.arange(flat_x.shape[0], dtype='int64') diagonal_modulo = indexes % (x.shape[0] + 1) outward_rates = flat_x[TT.eq(diagonal_modulo, 1).nonzero()] return outward_rates"}
{"question": "Write a function that Split the list of strings into a list of lists of strings This is used to prevent very wide cols (e.g. when a precise version detection has not been possible and a long list of candidates is shown)", "answer": "def split_string(self, string_list): out, tmp = [], [] while len(string_list): s = string_list.pop(0) if len(' | '.join(tmp + [s])) > self.max_col_width: out.append(' | '.join(tmp)) tmp = [s] else: tmp.append(s) out.append(' | '.join(tmp)) return out"}
{"question": "Write a function that customize VM log output to your needs hint: use 'py.test' with the '-s' option to dump logs to the console", "answer": "def do_test_vm(filename, testname=None, testdata=None, limit=99999999): logger.debug('running test:%r in %r' % (testname, filename)) testutils.check_vm_test(testutils.fixture_to_bytes(testdata))"}
{"question": "Write a function that Override the config from the environment. This is used leverage the LINK capability of docker. It would be far better to use DNS and that can be done in environments like kubernetes. Look for environment variables that match the link pattern and set the appropriate overeides. It is expected that the set of overrides will be expanded with need", "answer": "def overrideDbSettings(v): parsed = urlparse(v) config.db_host = parsed.hostname config.db_port = parsed.port"}
{"question": "Write a function that Use the code you just worked out to build a protocol and an \"echo\" bot. You don't actually have to do the network part of this if you don't want; just simulate that. The protocol is: A->B Send \"p\", \"g\", \"A\"", "answer": "def message1(): a = randrange(2, group5_p-2); A = mypow(group5_g, a, group5_p); state = { \"p\" : group5_p, \"g\" : group5_g, \"a\" : a, \"A\" : A }; return state;"}
{"question": "Write a function that Now implement the following MITM attack: A->M Send \"p\", \"g\", \"A\" M->B Send \"p\", \"g\", \"p\"", "answer": "def message1_5(state): state[\"A\"] = state[\"p\"]; return state;"}
{"question": "Write a function that the concrete class needs to implement: erase, unerase, is_correct_type, wrap, unwrap create_storage needs to be overwritten if an r_dict is needed", "answer": "def get(self, w_dict, w_key, env, cont): from pycket.interpreter import return_value if self.is_correct_type(w_key): w_res = self.unerase(w_dict.hstorage).get(self.unwrap(w_key), w_missing) return return_value(w_res, env, cont) # XXX should not dehomogenize always self.switch_to_object_strategy(w_dict) return w_dict.hash_ref(w_key, env, cont)"}
{"question": "Write a function that We could implement an option that simulates a full featured SQL database. But I think the option should be set explicit or implemented as another library.", "answer": "def ON(self, first, second): raise NotImplementedError(\"This is not possible in NoSQL\" + \" but can be simulated with a wrapper.\") return '%s ON %s' % (self.expand(first), self.expand(second))"}
{"question": "Write a function that Iterators in Python aren't a matter of type but of protocol. A large and changing number of builtin types implement *some* flavor of iterator. Don't check the type! Use hasattr to check for both \"__iter__\" and \"__next__\" attributes instead.", "answer": "def _f(): pass"}
{"question": "Write a function that # # implement IMessageEditorController # this allows our request/response viewers to obtain details about the messages being displayed #", "answer": "def getHttpService(self): return self._currentlyDisplayedItem.getHttpService()"}
{"question": "Write a function that Override these methods to implement other queue organizations (e.g. stack or priority queue). These will only be called with appropriate locks held Initialize the queue representation", "answer": "def _init(self, maxsize): self.maxsize = maxsize self.queue = deque()"}
{"question": "Write a function that The first set of methods here essentially implement pass-through handling of most of the stuff in an SGML file. We're really only concerned with the tags specific to SCons example processing, the methods for which get defined below.", "answer": "def handle_data(self, data): try: f = self.afunclist[-1] except IndexError: self.outfp.write(data) else: f(data)"}
{"question": "Write a function that Tests a gradient for batch_to_space of x which is a four dimensional tensor of shape [b * block_size * block_size, h, w, d].", "answer": "def _compare(self, b, h, w, d, block_size, crop_beg, crop_end): block_size_sq = block_size * block_size x = np.random.normal( 0, 1, b * h * w * d * block_size_sq).astype(np.float32).reshape( [b * block_size * block_size, h, w, d]) crops = np.array([[crop_beg, crop_end], [crop_beg, crop_end]], dtype=np.int32) self._checkGrad(x, crops, block_size)"}
{"question": "Write a function that printarr(mi) fit arc to pts (0, 0), (x, y), and (1, 0), return th tangent to arc at (x, y)", "answer": "def fit_arc(x, y): th = atan2(y - 2 * x * y, y * y + x - x * x) return th"}
{"question": "Write a function that implement truth value testing for Bool parameters so that these params evaluate correctly during the python configuration phase", "answer": "def __nonzero__(self): return bool(self.value)"}
{"question": "Write a function that The following methods form the public API for storage systems, but with no default implementations. Subclasses must implement *all* of these.", "answer": "def delete(self, name): \"\"\" Deletes the specified file from the storage system. \"\"\" raise NotImplementedError('subclasses of Storage must provide a delete() method')"}
{"question": "Write a function that Uncommon methods the user should implement. These have intentionally uglier method names, which reflects just how much harder they are to get right.", "answer": "def update_list(self, *args, **kwargs): \"\"\" Updates the entire collection for a PUT on a list-style endpoint. Uncommonly implemented due to the complexity & (varying) busines-logic involved. **MUST BE OVERRIDDEN BY THE USER** - By default, this returns ``MethodNotImplemented``. :returns: A collection of data :rtype: list or iterable \"\"\" raise MethodNotImplemented()"}
{"question": "Write a function that The following two methods are used to allocate the port source for various types of test servers. Because some net-related tests can be run on shards at same time, it's important to have a mechanism to allocate the port process-safe. In here, we implement the safe port allocation by leveraging flock.", "answer": "def ResetTestServerPortAllocation(): \"\"\"Resets the port allocation to start from TEST_SERVER_PORT_FIRST. Returns: Returns True if reset successes. Otherwise returns False. \"\"\" try: with open(constants.TEST_SERVER_PORT_FILE, 'w') as fp: fp.write('%d' % constants.TEST_SERVER_PORT_FIRST) if os.path.exists(constants.TEST_SERVER_PORT_LOCKFILE): os.unlink(constants.TEST_SERVER_PORT_LOCKFILE) return True except Exception as e: logging.error(e) return False"}
{"question": "Write a function that The following are methods that are called depending on the type of a member. The entry point is _proc_member() which can be overridden in a subclass to add custom _proc_*() methods. A _proc_*() method MUST implement the following operations: 1. Set self.offset_data to the position where the data blocks begin, if there is data that follows. 2. Set tarfile.offset to the position where the next member's header will begin. 3. Return self or another valid TarInfo object.", "answer": "def _proc_member(self, tarfile): \"\"\"Choose the right processing method depending on the type and call it. \"\"\" if self.type in (GNUTYPE_LONGNAME, GNUTYPE_LONGLINK): return self._proc_gnulong(tarfile) elif self.type == GNUTYPE_SPARSE: return self._proc_sparse(tarfile) elif self.type in (XHDTYPE, XGLTYPE, SOLARIS_XHDTYPE): return self._proc_pax(tarfile) else: return self._proc_builtin(tarfile)"}
{"question": "Write a function that Below are the different file methods. They are called via _extract_member() when extract() is called. They can be replaced in a subclass to implement other functionality.", "answer": "def makedir(self, tarinfo, targetpath): \"\"\"Make a directory called targetpath. \"\"\" try: # Use a safe mode for the directory, the real mode is set # later in _extract_member(). os.mkdir(targetpath, 0o700) except FileExistsError: pass"}
{"question": "Write a function that TODO: reenable test. def test_classify(self): self.query_options['device_id'] = 5 self.retrieve_args[0] = 5 self.query_options['classify'] = True self.query_options['device'] = 'Panel1' self.retrieve_args[7] = 'Panel1' self.query_options['start_time'] = 6 self.retrieve_args[1] = 6 self.query_options['end_time'] = 7 self.retrieve_args[2] = 7 query_db.retrieve_within_filters = self.retrieve_factory() Analysis_3.run = self.classify_factory() self.assertEqual(query_db.query(self.query_options), 'classify called')", "answer": "def test_classify_missing_start_time(self): self.query_options['device_id'] = 10 self.query_options['device'] = \"Panel1\" self.retrieve_args[0] = 10 self.query_options['classify'] = True query_db.retrieve_within_filters = self.retrieve_factory() try: query_db.query(self.query_options) self.assertFail() except Exception as e: self.assertEqual(str(e), 'Received malformed URL data: missing start_time')"}
{"question": "Write a function that At the moment, Windows doesn't implement spawnvp[e], so it won't have spawnlp[e] either.", "answer": "def spawnlp(mode, file, *args): \"\"\"spawnlp(mode, file, *args) -> integer Execute file (which is looked for along $PATH) with arguments from args in a subprocess with the supplied environment. If mode == P_NOWAIT return the pid of the process. If mode == P_WAIT return the process's exit code if it exits normally; otherwise return -SIG, where SIG is the signal that killed it. \"\"\" return spawnvp(mode, file, args)"}
{"question": "Write a function that We could implement an option that simulates a full featured SQL database. But I think the option should be set explicit or implemented as another library.", "answer": "def on(self, first, second): raise NotOnNOSQLError()"}
{"question": "Write a function that The remaining methods partially implement the file-like object interface. See http://docs.python.org/lib/bltin-file-objects.html", "answer": "def write(self, content): if not self._is_str_iter: raise IOError(\"This %s instance's content is not writable: (content \" 'is an iterator)' % self.__class__.__name__) self.content.append(content)"}
{"question": "Write a function that dynamic collection cannot implement __len__() (at least one that returns a live database result), else additional count() queries are issued when evaluating in a list context", "answer": "def go(): eq_( q.filter(User.id == 7).all(), [ User( id=7, addresses=[ Address(id=1, email_address='jack@bean.com')])])"}
{"question": "Write a function that test with the large value hidden: disabled so far, doesn't work # for hidden_value, expected_size, expected_minus1 in cases: # ffi = FFI() # ffi.cdef(\"enum foo_e { AA, BB, ... };\") # lib = ffi.verify(\"enum foo_e { AA, BB=%s };\" % hidden_value) # assert lib.AA == 0 # assert ffi.sizeof(\"enum foo_e\") == expected_size # assert int(ffi.cast(\"enum foo_e\", -1)) == expected_minus1", "answer": "def test_enum_bug118(): maxulong = 256 ** FFI().sizeof(\"unsigned long\") - 1 for c2, c2c in [(-1, ''), (-1, ''), (0xffffffff, 'U'), (maxulong, 'UL'), (-int(maxulong / 3), 'L')]: if c2c and sys.platform == 'win32': continue # enums may always be signed with MSVC ffi = FFI() ffi.cdef(\"enum foo_e { AA };\") lib = ffi.verify(\"enum foo_e { AA=%s%s };\" % (c2, c2c)) assert lib.AA == c2"}
{"question": "Write a function that temporarily change warnings to exceptions for the purposes of testing", "answer": "def setUp(self): self.tempdir = tempfile.mkdtemp(dir=HOME) self.subtempdir = tempfile.mkdtemp(dir=os.path.join(HOME, self.tempdir)) self.tempfile = touch(os.path.join(self.tempdir, TESTFN)) self.subtempfile = touch(os.path.join(self.subtempdir, TESTFN)) warnings.filterwarnings(\"error\")"}
{"question": "Write a function that utility function which used for extracting the MLST \"facts\" string from the FEAT response", "answer": "def mlst(): resp = self.client.sendcmd('feat') return re.search(r'^\\s*MLST\\s+(\\S+)$', resp, re.MULTILINE).group(1)"}
{"question": "Write a function that Test that no extra extra carriage returns are added to the file in ASCII mode in case CRLF gets truncated in two chunks (issue 116)", "answer": "def store(cmd, fp, blocksize=8192): # like storbinary() except it sends \"type a\" instead of # \"type i\" before starting the transfer self.client.voidcmd('type a') conn = self.client.transfercmd(cmd) conn.settimeout(TIMEOUT) while 1: buf = fp.read(blocksize) if not buf: break conn.sendall(buf) conn.close() return self.client.voidresp()"}
{"question": "Write a function that overridden so that the \"awake\" callback is executed immediately; this way we won't introduce any slowdown and still test the code of interest", "answer": "def _throttle_bandwidth(self, *args, **kwargs): ThrottledDTPHandler._throttle_bandwidth(self, *args, **kwargs) if self._throttler is not None and not self._throttler.cancelled: self._throttler.call() self._throttler = None"}
{"question": "Write a function that A complete implementation of current DST rules for major US time zones.", "answer": "def first_sunday_on_or_after(dt): days_to_go = 6 - dt.weekday() if days_to_go: dt += timedelta(days_to_go) return dt"}
{"question": "Write a function that This is an exclude selector so it can override the (include) selectors. It may not provide uniform distribution (in time or count), but is a determanistic partition of the tests which is important.", "answer": "def __init__(self, shard_num, shard_count): self.shard_num = shard_num self.shard_count = shard_count"}
{"question": "Write a function that This ReplacePackage mechanism allows modulefinder to work around the way the _xmlplus package injects itself under the name \"xml\" into sys.modules at runtime by calling ReplacePackage(\"_xmlplus\", \"xml\") before running ModuleFinder.", "answer": "def ReplacePackage(oldname, newname): replacePackageMap[oldname] = newname"}
{"question": "Write a function that Currently the bytes containment testing uses a single integer value. This may not be the final design, but until then the bytes section with in a bytes containment not valid", "answer": "def test_contains(self): pass"}
{"question": "Write a function that create a separate file with the name Account.txt in this files location and type the id in the first line and password in the second line", "answer": "def check(name , passw): fr = open('Account.txt','r') text = str(fr.read()) lines = text.split(\"\\n\") if name == lines[0]: if passw == lines[1]: print('Welcome',name) else: print('Invalid Entry') else: print('Invalid Entry') fr.close()"}
{"question": "Write a function that Create a function for callable dists that returns the node value and the parents via a dict.", "answer": "def get_values(rv, outcome): node_val = outcome[rv_index[rv]] parents = parents_index[rv] parent_vals = [outcome[rv_index[parent]] for parent in parents] parents = dict(zip(parents, parent_vals)) return node_val, parents"}
{"question": "Write a function that Create a wrapper to pass the handler to the servlet", "answer": "def wrapper(): \"\"\" Wrapped servlet call \"\"\" try: # Handle the request return getattr(servlet, name)(request, response) except: # Send a 500 error page on error return self.send_exception(response)"}
{"question": "Write a function that define status transition when server resize ACTIVE(initial) -> ACTIVE -> RESIZE -> VERIFY_RESIZE", "answer": "def set_status(status): server.status = status return server"}
{"question": "Write a function that create a list of VMs in the scale set by fault domain and update domain", "answer": "def set_domain_lists(self): self.fd_dict = {f: [] for f in range(5)} self.ud_dict = {u: [] for u in range(5)} for instance in self.vm_instance_view['value']: try: instanceId = instance['instanceId'] ud = instance['properties']['instanceView']['platformUpdateDomain'] fd = instance['properties']['instanceView']['platformFaultDomain'] power_state = self.get_power_state(instance['properties']['instanceView']['statuses']) self.ud_dict[ud].append([instanceId, power_state]) self.fd_dict[fd].append([instanceId, power_state]) except KeyError: print('KeyError - UD/FD may not be assigned yet. Instance view: ' + json.dumps(instance)) break"}
{"question": "Write a function that Create an instance I. Then gc hasn't happened again so long as I.gc_happened is false.", "answer": "def __init__(self): self.gc_happened = False def it_happened(ignored): self.gc_happened = True # Create a piece of cyclic trash that triggers it_happened when # gc collects it. self.wr = weakref.ref(C1055820(666), it_happened)"}
{"question": "Write a function that Create an empty database before we start our tests for this module", "answer": "def setup(): \"\"\"Function called by nose on module load\"\"\" setup_db()"}
{"question": "Write a function that create a database connection and return an instance all drivers parse a db string in the form: [[user[:password]@]host/]database", "answer": "def connect(db, driver=None, **kw): driver = __get_driver(driver) dbh = driver(db) assert(dbh.connect(**kw)) return dbh"}
{"question": "Write a function that Create a parallel python job server, to use for fast motif comparison", "answer": "def _load_scores(self): self.scoredist = {} for metric in self.metrics: self.scoredist[metric] = {\"total\": {}, \"subtotal\": {}} for match in [\"total\", \"subtotal\"]: for combine in [\"mean\"]: self.scoredist[metric][\"%s_%s\" % (match, combine)] = {} score_file = os.path.join(self.config.get_score_dir(), \"%s_%s_%s_score_dist.txt\" % (match, metric, combine)) if os.path.exists(score_file): for line in open(score_file): l1, l2, m, sd = line.strip().split(\"\\t\")[:4] self.scoredist[metric][\"%s_%s\" % (match, combine)].setdefault(int(l1), {})[int(l2)] = [float(m), float(sd)]"}
{"question": "Write a function that Returns True if the name can be used to call this command", "answer": "def called_by(self, name): return name in self.command_name_list"}
{"question": "Write a function that Returns true if the command is \"recognized\" in the given channel", "answer": "def recognized_channel(self, channel): return True"}
{"question": "Write a function that Patch AbstractTTSEngine.play to record its params Really need to make this loosely connected", "answer": "def fakeplay(self, filename, translate=False): global LAST_PLAY output = subprocess.check_output(['file', filename], universal_newlines=True) LAST_PLAY = (self, filename, output)"}
{"question": "Write a function that Extracts the unique portion of results.test_id and populates extra_data.bigquery_test_id which will be used to associate both the S2C and C2S records in results with a single row in the extra_data table", "answer": "def associate(config): engine = create_engine(config.database_uri) metadata = MetaData() records = config.make_cache_table(metadata) extra_data = config.make_extra_data_table(metadata) metadata.create_all(engine) joining = join(records, extra_data, and_(extra_data.c.bigquery_key == records.c.bigquery_key)) query = select([joining, extra_data.c.id.label('extra_data_id')]) results = engine.execute(query) p = re.compile('^(.*):[0-9]{4,5}\\.[cs]2[cs]_snaplog\\.gz$') for result in results.fetchall(): test_id = p.match(result.test_id).group(1) query = extra_data.update().where(extra_data.c.id == result.extra_data_id).values(bigquery_test_id = test_id) engine.execute(query)"}
{"question": "Write a function that Utilities for reading and writing the beets progress file, which allows long tagging tasks to be resumed when they pause (or crash).", "answer": "def progress_read(): state = _open_state() return state.setdefault(PROGRESS_KEY, {})"}
{"question": "Write a function that Similarly, utilities for manipulating the \"incremental\" import log. This keeps track of all directories that were ever imported, which allows the importer to only import new stuff.", "answer": "def history_add(paths): \"\"\"Indicate that the import of the album in `paths` is completed and should not be repeated in incremental imports. \"\"\" state = _open_state() if HISTORY_KEY not in state: state[HISTORY_KEY] = set() state[HISTORY_KEY].add(tuple(paths)) _save_state(state)"}
{"question": "Write a function that Performs substitution of per-node parameters. command - may be either string or array of strings containing commands with substitution string host - the host the command will be run on user - the user to run as index - the index of the node in the cluster deployment config user_params - a dict of user specified substitutions return value - same type and form as command (string or array), with substitutions performed", "answer": "def ClusterSubstitute(command, host, user, index=0, user_params=None): # Construct substitution dictionary subs = {'host' : host, 'user' : user, 'node' : index} if (user_params != None): for key,value in user_params.items(): subs[key] = value[index-1] # Perform substition. We do this twice because some user_params items might have host, user and node in them if (isinstance(command, str)): return (command % subs) % subs elif (isinstance(command, list)): return [((x % subs) % subs) for x in command] return None"}
{"question": "Write a function that Create a temporary file that will be removed at exit Returns a path to the file", "answer": "def create_temp(suffix='', prefix='tmp', dir=None): _f, path = tempfile.mkstemp(suffix, prefix, dir) os.close(_f) # remove_at_exit(path) # make comment for execute example by imsukmin return path"}
{"question": "Write a function that Create a function to move the selection window across the data set.", "answer": "def MoveWindow(): for y in range(100, 300, 25): for x in range(100, 300, 25): PlaceWindow(x, y)"}
{"question": "Write a function that Dynamic credentials implies admin so only one test case for True", "answer": "def test__dynamic_creds__accounts_file__no_admin(self): self.run_test(dynamic_creds=True, use_accounts_file=True, admin_creds=None)"}
{"question": "Write a function that Create volume name from docker image name and instance domain", "answer": "def gui_files_volume_name(image_name, instance_domain): volume_name = image_name.split('/')[-1].replace( ':', '-').replace('_', '-').replace('.', '-') return '{0}-{1}'.format(volume_name, instance_domain)"}
{"question": "Write a function that Comparison methods to sort by deadline, with object id as a tiebreaker to guarantee a consistent ordering. The heapq module uses __le__ in python2.5, and __lt__ in 2.6+ (sort() and most other comparisons use __lt__).", "answer": "def __lt__(self, other): return ((self.deadline, id(self)) < (other.deadline, id(other)))"}
{"question": "Write a function that Create all classes in the class hierarchies of the classes in the special objects array.", "answer": "def create_metaclass(cls_nm, supercls_nm): meta_nm = cls_nm + \"Class\" meta_super_nm = supercls_nm + \"Class\" w_meta_cls = self.bootstrap_class(0, # XXX self.classtable[meta_super_nm], self.w_Metaclass, name=meta_nm[2:]) self.add_bootstrap_class(meta_nm, w_meta_cls) return w_meta_cls"}
{"question": "Write a function that Create one or more panels from a description file (S-expressions) generated by the Panel Editor.", "answer": "def defpanellist(file): import panelparser descrlist = panelparser.parse_file(open(file, 'r')) panellist = [] for descr in descrlist: panellist.append(build_panel(descr)) return panellist"}
{"question": "Write a function that Accepts strings consisting of 1 or more characters in [a-z'] (the apostrophe is so that contraction words such as don't are accepted)", "answer": "def is_alphabetic(s): return len(s) > 0 and not bool(non_english_character_pattern.search(s))"}
{"question": "Write a function that Let's consider a slightly less silly function, that implements a linear relationship between inputs and outputs:", "answer": "def not_so_silly_func(x, a, b): return x * a + b"}
{"question": "Write a function that This is based on ExcelWriterBase Base class for test cases to run with different Excel readers. To add a reader test, define the following: 1. A check_skip function that skips your tests if your reader isn't installed. 2. Add a property ext, which is the file extension that your reader reades from. (needs to start with '.' so it's a valid path) 3. Add a property engine_name, which is the name of the reader class. For the reader this is not used for anything at the moment.", "answer": "def setUp(self): self.check_skip() super(ReadingTestsBase, self).setUp()"}
{"question": "Write a function that We can't say this yet because we don't have enough infrastructure in place. implements(IElement)", "answer": "def __init__(self, __name__, __doc__=''): \"\"\"Create an 'attribute' description \"\"\" if not __doc__ and __name__.find(' ') >= 0: __doc__ = __name__ __name__ = None self.__name__=__name__ self.__doc__=__doc__ self.__tagged_values = {}"}
{"question": "Write a function that Usage of this function is discouraged. Clients shouldn't care which implementation of the API is in use. Note that there is no guarantee that differences between APIs will be maintained. Please don't use this function if possible.", "answer": "def Type(): return _implementation_type"}
{"question": "Write a function that this returns a callable which, when invoked with an integer N, will return N pseudorandom bytes. Note: this is a short-term PRNG, meant primarily for the needs of randrange_from_seed__trytryagain(), which only needs to run it a few times per seed. It does not provide protection against state compromise (forward security).", "answer": "def __init__(self, seed): self.generator = self.block_generator(seed)"}
{"question": "Write a function that the following randrange_from_seed__METHOD() functions take an arbitrarily-sized secret seed and turn it into a number that obeys the same range limits as randrange() above. They are meant for deriving consistent signing keys from a secret rather than generating them randomly, for example a protocol in which three signing keys are derived from a master secret. You should use a uniformly-distributed unguessable seed with about curve.baselen bytes of entropy. To use one, do this: seed = os.urandom(curve.baselen) # or other starting point secexp = ecdsa.util.randrange_from_seed__trytryagain(sed, curve.order) sk = SigningKey.from_secret_exponent(secexp, curve)", "answer": "def randrange_from_seed__truncate_bytes(seed, order, hashmod=sha256): # hash the seed, then turn the digest into a number in [1,order), but # don't worry about trying to uniformly fill the range. This will lose, # on average, four bits of entropy. bits, bytes, extrabits = bits_and_bytes(order) if extrabits: bytes += 1 base = hashmod(seed).digest()[:bytes] base = \"\\x00\"*(bytes-len(base)) + base number = 1+int(binascii.hexlify(base), 16) assert 1 <= number < order return number"}
{"question": "Write a function that these methods are useful for the sigencode= argument to SK.sign() and the sigdecode= argument to VK.verify(), and control how the signature is packed or unpacked.", "answer": "def sigencode_strings(r, s, order): r_str = number_to_string(r, order) s_str = number_to_string(s, order) return (r_str, s_str)"}
{"question": "Write a function that canonical versions of sigencode methods these enforce low S values, by negating the value (modulo the order) if above order/2 see CECKey::Sign() https://github.com/bitcoin/bitcoin/blob/master/src/key.cpp#L214", "answer": "def sigencode_strings_canonize(r, s, order): if s > order / 2: s = order - s return sigencode_strings(r, s, order)"}
{"question": "Write a function that The reason this returns true if start_time or end_time are None is because filtering by time is optional, and it allows us to simply do if not check_timestamp_in_range(...): return False The default arguments for start_time and end_time are None when we aren't filtering by time", "answer": "def check_timestamp_in_range(timestamp, start_time, end_time): \"\"\"A convenience function to check if a datetime.datetime timestamp is within the given start and end times, returns true if start_time or end_time is None :param timestamp: The timestamp to check :param start_time: The start of the interval :param end_time: The end of the interval :return: True if timestamp is within start_time and end_time range, False otherwise \"\"\" if timestamp is not None and start_time is not None and end_time is not None: if timestamp.tzinfo is None: timestamp = pytz.utc.localize(timestamp) return start_time < timestamp < end_time else: return True"}
{"question": "Write a function that In some circumstances (`devel` set to true) client library wants to skip caching altogether. That is achieved by supplying a random query string.", "answer": "def test_queriedUrl(self): for suffix in ['/iframe-a.html?t=1234', '/iframe-0.1.2.html?t=123414', '/iframe-0.1.2abc-dirty.2144.html?t=qweqweq123']: self.verify(base_url + suffix)"}
{"question": "Write a function that Show that without the changes in 5557 brentq and brenth might only achieve a tolerance of 2*(xtol + rtol*|res|). f linearly interpolates (0, -0.1), (0.5, -0.1), and (1, 0.4). The important parts are that |f(0)| < |f(1)| (so that brent takes 0 as the initial guess), |f(0)| < atol (so that brent accepts 0 as the root), and that the exact root of f lies more than atol away from 0 (so that brent doesn't achieve the desired tolerance).", "answer": "def f(x): if x < 0.5: return -0.1 else: return x - 0.6"}
{"question": "Write a function that XXX this function is too long and its interaction with the formatter steps is not very clear NOTE mutation in a few places we cannot rely simply on IDA's disassembly when generating C. e.g.: .text:100052F4 lwc1 $f12, (square - 0x10008E50)($s1) THIS means f12 = square[0] (square is declared as an array). but... .text:100041A4 lw $a1, (seqList - 0x1000BF78)($a1) THIS means a1 = seqList--NOT *seqList or seqList[0]. GetOperand and similar functions are thus useless for our purposes. unfortunately, we have no choice but to handle C's type system in order to emit C from disassembly. we don't COMPLETELY handle it (patches welcome!!!1), but we do achieve enough that with minor database annotations we have a POC in our chosen target.", "answer": "def labelize(ea, stmt): if from_delay is False: label = ida.name(ea) if label != '': return c_ast.Label(label, stmt) else: return stmt else: return stmt"}
{"question": "Write a function that class RelativeRegionPositioner: \"\"\"Class method to compute the relative positions of neighbours respect the main element. It visualizes position of element i and we can produce heterogeneous and anisotropic metric measures. TODO: it is only a preliminary version. \"\"\" def __init__(self, funct, info_pos={}): self.funct = funct self.info_pos = info_pos def compute(self, loc_i, loc_neighs, reg_i, reg_neighs): return self.funct(loc_i, loc_neighs, reg_i, reg_neighs) ########################## Collection of functions ########################### ##############################################################################", "answer": "def metric_distances(loc_i, loc_neighs, info_pos={}): dist_metric = [] for i in range(len(loc_i)): dist_metric.append(cdist(loc_i[[i]], loc_neighs[i], **info_pos).T) return dist_metric"}
{"question": "Write a function that # For debugging and analysis: summarise the file's BIFF records. I.e. produce a sorted file of (record_name, count). @param filename The path to the file to be summarised. @param outfile An open file, to which the summary is written.", "answer": "def count_records(filename, outfile=sys.stdout): bk = Book() bk.biff2_8_load(filename=filename, logfile=outfile, ) biff_count_records(bk.mem, bk.base, bk.stream_len, outfile)"}
{"question": "Write a function that The following are tests that verify that the CPU and GPU implementations produce the same resuts.", "answer": "def _CompareMaxPoolingFwd(self, input_shape, ksize, strides, padding): tensor_input = np.random.rand(*input_shape).astype(np.float32) with self.test_session(use_gpu=True): t = tf.constant(tensor_input, shape=input_shape) out_op, _ = tf.nn.max_pool_with_argmax(t, ksize, strides, padding) gpu_val = out_op.eval() with self.test_session(use_gpu=False): t = tf.constant(tensor_input, shape=input_shape) out_op = tf.nn.max_pool(t, ksize, strides, padding) cpu_val = out_op.eval() self.assertAllClose(cpu_val, gpu_val, rtol=1e-5, atol=1e-5)"}
{"question": "Write a function that Since 3.2 tarfile is supposed to accurately restore sparse members and produce files with holes. This is what we actually want to test here. Unfortunately, not all platforms/filesystems support sparse files, and even on platforms that do it is non-trivial to make reliable assertions about holes in files. Therefore, we first do one basic test which works an all platforms, and after that a test that will work only on platforms/filesystems that prove to support sparse files.", "answer": "def _test_sparse_file(self, name): self.tar.extract(name, TEMPDIR) filename = os.path.join(TEMPDIR, name) with open(filename, \"rb\") as fobj: data = fobj.read() self.assertEqual(md5sum(data), md5_sparse, \"wrong md5sum for %s\" % name) if self._fs_supports_holes(): s = os.stat(filename) self.assertLess(s.st_blocks * 512, s.st_size)"}
