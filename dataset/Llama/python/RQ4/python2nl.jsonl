{"question": "def is_number(s): try: float(s) return True except ValueError: return False", "answer": "This function Check if given var is / can be converted to float"}
{"question": "def is_int(s): try: float(s) if float(s) - int(s) == 0: return True else: return False except ValueError: return False", "answer": "This function Check if given var is / can be converted to int"}
{"question": "def check_results_availability(): # The HTML content of the url will be stored in this file fname = \"Output.txt\" # UPDATE (01/07/2018) # Right now, performs check on default roll number - 14CS10008 url_to_scrape = 'https://erp.iitkgp.ernet.in/StudentPerformance/view_performance.jsp?rollno=14CS10008' content = connect(fname, url_to_scrape) for line in content: # VULNERABLE # Change to other HTML conditions if line.find(\"Students Performance will be enabled after SENATE Approval\") != -1 or line.find(\"HTTP Status 500\") != -1: return False return True", "answer": "This function Check if results are available at the moment (Eg-Not available before senate). Return status bool."}
{"question": "def take_roll_num(): # Taking roll_num input roll_num = raw_input(\"Enter Roll Number : \") # Converting user inp to upper (14cs10008 - 14CS10008) and checking validity while True: flag, content = check_roll_num_validity(roll_num.upper()) if not flag: roll_num = raw_input(\"Roll Number Invalid / Not currently supported. Please enter valid Roll Number : \") else: break return [roll_num.upper(), content]", "answer": "This function Take a roll number input from user until it is valid, then return it. Return type : str"}
{"question": "def take_year(): # Currently, software supports students with starting years as 2012, 2013, 2014, 2015 # UPDATE : Annual years = [\"11\",\"12\", \"13\", \"14\", \"15\"] year = raw_input(\"Enter start year for the batch (Choices : 11, 12, 13, 14, 15) : \") while year not in years: year = raw_input(\"Please enter valid year : \") return year", "answer": "This function Take user input for batch start year, validate and return year. Return type : str"}
{"question": "def take_dep(): # List storing available departments in IIT Kharagpur. departments = [\"AE\", \"AG\", \"AR\", \"BT\", \"CE\", \"CH\", \"CS\", \"CY\", \"EC\", \"EE\", \"EX\", \"GG\", \"HS\", \"IE\", \"IM\", \"MA\", \"ME\", \"MF\", \"MI\", \"MT\", \"NA\", \"PH\", \"QD\"] dep = raw_input(\"Enter Department (e.g \\\"CE\\\" for civil) : \") # Converting user entered input to uppercase, in case it isn't. dep = dep.upper() while dep not in departments: print \"Please enter a valid department!\" dep = raw_input(\"Enter Valid Department again : \") dep = dep.upper() return dep", "answer": "This function Take user input for department, validate and return department. Return type : str"}
{"question": "def take_sem_num(): # Right now, software only supports semester 1 to 8 # EXTEND : Make Semester Physics and Chemistry instead of 1 and 2 # EXTEND : Introduce semesters 9 and 10 sem_num = raw_input(\"Enter Semester Number [3-8] : \") while not is_int(sem_num) or int(sem_num) < 3 or int(sem_num) > 8: sem_num = raw_input(\"Please enter valid Semester Number : \") return int(sem_num)", "answer": "This function Take user input for semester number, validate and return. Return type : int"}
{"question": "def is_msc_dep(dep): msc_dep_list = [\"GG\", \"EX\", \"MA\", \"CY\", \"HS\", \"PH\"] if dep in msc_dep_list: return True return False", "answer": "This function Given dep str, check if it's one of the Msc dep offered by IIT KGP. Return bool"}
{"question": "def get_prev_year(sem_num): today = datetime.date.today() current_year = float(today.year) current_month = int(today.month) if current_month >= 5: current_year += 0.6 # For sem num between 1 to 8, year always takes values between 12 to 15 prev_year = int(math.floor(current_year - (sem_num + 1)/float(2))) prev_year -= 2000 return str(prev_year)", "answer": "This function Given semester number, find the year of the batch which most recently completed that semester number"}
{"question": "def find_name(roll_num, content=''): if content == '': url_to_scrape = 'https://erp.iitkgp.ernet.in/StudentPerformance/view_performance.jsp?rollno=' + str(roll_num) fname = \"Output.txt\" content = connect(fname, url_to_scrape) name = '' for line in content: if line.find(\"Name\") != -1: # TODO : Replace with regex logic - (.*)<td>(.*)</td> - group(2) idx = 24 while line[idx] != '<': idx += 1 name = line[24:idx] break return name", "answer": "This function Find name for the given roll number. Returns '' if record doesn't exist."}
{"question": "def find_sum(alist): csum = 0 factor = 0 for item in alist: csum += item*factor factor += 1 return csum", "answer": "This function Find normalised difficulty score from a particular subject's grade list and return it. No. of Ex are multiplied by 0, A's by 1, B's by 2 and so on. And final sum is returned."}
{"question": "def find_subjects_by_difficulty_level(grade_dict): sum_dict = {} for item in grade_dict: csum = find_sum(grade_dict[item]) sum_dict[item] = csum sorted_sum_dict = sorted(sum_dict.items(), key = operator.itemgetter(1), reverse = True) print '\\nFollowing subjects have been sorted in decreasing level of difficulty according to their previous yr. grade distribution.' table = PrettyTable(['Subject Name', 'Difficulty Score']) table.align = 'l' table.align['Difficulty Score'] = 'c' for item in sorted_sum_dict: table.add_row([item[0].replace(\"&amp;\", \"&\"), item[1]]) print table", "answer": "This function Prints difficlulty scores (as computed by find_sum) for subjects in grade_dict"}
{"question": "def find_sub_most_a_ex(grade_dict): maxim = 0 for item in grade_dict: if grade_dict[item][0] + grade_dict[item][1] > maxim: maxim = grade_dict[item][0] + grade_dict[item][1] list_sub = [] for item in grade_dict: if grade_dict[item][0] + grade_dict[item][1] == maxim: list_sub.append(item) print 'Depth Subject(s) with most A\\'s + Ex\\'s : ', for item in list_sub: print item, print ''", "answer": "This function Given subjects with their grade lists, prints subj with most A's + Ex's."}
{"question": "def working_chronos(context): if not hasattr(context, 'client'): chronos_connection_string = get_chronos_connection_string() context.client = chronos.connect(chronos_connection_string)", "answer": "This function Adds a working chronos client as context.client for the purposes of interacting with it in the test."}
{"question": "def atomic(hub): yield AtomicHub(hub)", "answer": "This function Raises an :exc:`AssertionError` when a gevent blocking function called in the context."}
{"question": "def parse_html(fileobj, encoding): parser = HTMLParser(encoding=encoding, remove_blank_text=True) return parse(fileobj, parser)", "answer": "This function Given a file object *fileobj*, get an ElementTree instance. The *encoding* is assumed to be utf8."}
{"question": "def get_context_data(self, **kwargs): context = super(ConfirmUsers, self).get_context_data(**kwargs) json_valid_users = self.request.GET.get('valid_users', {}) valid_users = json.loads(json_valid_users) conflicting_users = json.loads(self.request.GET.get('conflicting_users', {})) context['valid_users'] = valid_users context['conflicting_users'] = conflicting_users context['confirmation_url'] = urlresolvers.reverse('save_bulkcreated_users', kwargs={'userdata': json_valid_users}) context['cancel_url'] = urlresolvers.reverse('bulkcreate_users_by_email') print context return context", "answer": "This function fetch json-encoded validationresult from queryparams and pass them along to the view"}
{"question": "def __generate_character(self): self.player_character = None self.player_character = self.generator(self.class_names[self.selected_index])", "answer": "This function Generate player character based on selected settings"}
{"question": "def hash_seq(seq): return reduce(lambda x, y: x ^ y, seq, 0)", "answer": "This function Given a sequence of hash values, return a combined xor'd hash."}
{"question": "def eq(self, val1, val2): return val1 == val2", "answer": "This function Compare two values for this field."}
{"question": "def hash(self, val): return hash(val)", "answer": "This function Hash a value for this field."}
{"question": "def emitCacheHeaders(self): self.response.headers['Cache-Control'] = \"public, max-age=600\" # 10m #self.response.headers['Cache-Control'] = \"public, max-age=43200\" # 12h self.response.headers['Vary'] = \"Accept, Accept-Encoding\"", "answer": "This function Send cache-related headers via HTTP."}
{"question": "def write(self, str): self.outputStrings.append(str)", "answer": "This function Write some text to Web server's output stream."}
{"question": "def emitSimplePropertiesPerType(self, cl, layers=\"core\", out=None, hashorslash=\"/\"): if not out: out = self out.write(\"<ul class='props4type'>\") for prop in sorted(GetSources( Unit.GetUnit(\"domainIncludes\"), cl, layers=layers), key=lambda u: u.id): if (prop.superseded(layers=layers)): continue out.write(\"<li><a href='%s%s'>%s</a></li>\" % ( hashorslash, prop.id, prop.id )) out.write(\"</ul>\\n\\n\")", "answer": "This function Emits a simple list of properties applicable to the specified type."}
{"question": "def emitSimplePropertiesIntoType(self, cl, layers=\"core\", out=None, hashorslash=\"/\"): if not out: out = self out.write(\"<ul class='props2type'>\") for prop in sorted(GetSources( Unit.GetUnit(\"rangeIncludes\"), cl, layers=layers), key=lambda u: u.id): if (prop.superseded(layers=layers)): continue out.write(\"<li><a href='%s%s'>%s</a></li>\" % ( hashorslash, prop.id, prop.id )) out.write(\"</ul>\\n\\n\")", "answer": "This function Emits a simple list of properties whose values are the specified type."}
{"question": "def emitRangeTypesForProperty(self, node, layers=\"core\", out=None, hashorslash=\"/\"): if not out: out = self out.write(\"<ul class='attrrangesummary'>\") for rt in sorted(GetTargets(Unit.GetUnit(\"rangeIncludes\"), node, layers=layers), key=lambda u: u.id): out.write(\"<li><a href='%s%s'>%s</a></li>\" % ( hashorslash, rt.id, rt.id )) out.write(\"</ul>\\n\\n\")", "answer": "This function Write out simple HTML summary of this property's expected types."}
{"question": "def emitDomainTypesForProperty(self, node, layers=\"core\", out=None, hashorslash=\"/\"): if not out: out = self out.write(\"<ul class='attrdomainsummary'>\") for dt in sorted(GetTargets(Unit.GetUnit(\"domainIncludes\"), node, layers=layers), key=lambda u: u.id): out.write(\"<li><a href='%s%s'>%s</a></li>\" % ( hashorslash, dt.id, dt.id )) out.write(\"</ul>\\n\\n\")", "answer": "This function Write out simple HTML summary of types that expect this property."}
{"question": "def rep(self, markup): m1 = re.sub(\"<\", \"&lt;\", markup) m2 = re.sub(\">\", \"&gt;\", m1) # TODO: Ampersand? Check usage with examples. return m2", "answer": "This function Replace < and > with HTML escape chars."}
{"question": "def unlock(self): self.wrappresenter.unlock()", "answer": "This function Manually unlock the presenter (always succeeds)."}
{"question": "def remove_logs(topology_name=None, env_name=None, pattern=None): topology_name = get_topology_definition(topology_name)[0] activate_env(env_name) execute(_remove_logs, topology_name, pattern, hosts=env.storm_workers)", "answer": "This function Remove all Python logs on Storm workers in the log.path directory."}
{"question": "def only_on_master(function): @wraps(function) def inner_function(self, *args, **kwargs): \"\"\"Master checking inner function.\"\"\" if not self.is_coordinator: message = 'The method or property \"{0}\" can only be called/used '\\ 'on the coordinator in a group'.format(function.__name__) raise SoCoSlaveException(message) return function(self, *args, **kwargs) return inner_function", "answer": "This function Decorator that raises SoCoSlaveException on master call on slave."}
{"question": "def is_coordinator(self): # We could do this: # invisible = self.deviceProperties.GetInvisible()['CurrentInvisible'] # but it is better to do it in the following way, which uses the # zone group topology, to capitalise on any caching. self._parse_zone_group_state() return self._is_coordinator", "answer": "This function Return True if this zone is a group coordinator, otherwise False. return True or False"}
{"question": "def mute(self): response = self.renderingControl.GetMute([ ('InstanceID', 0), ('Channel', 'Master') ]) mute_state = response['CurrentMute'] return True if int(mute_state) else False", "answer": "This function The speaker's mute state. True if muted, False otherwise"}
{"question": "def all_groups(self): self._parse_zone_group_state() return self._groups", "answer": "This function Return a set of all the available groups."}
{"question": "def get_item_album_art_uri(self, item): if getattr(item, 'album_art_uri', False): return self._build_album_art_full_uri(item.album_art_uri) else: return None", "answer": "This function Get an item's Album Art absolute URI."}
{"question": "def bulk_load(self, table, tmp_file): conn = self.get_conn() cur = conn.cursor() cur.execute(\"\"\" LOAD DATA LOCAL INFILE '{tmp_file}' INTO TABLE {table} \"\"\".format(**locals())) conn.commit()", "answer": "This function Loads a tab-delimited file into a database table"}
{"question": "def difference (b, a): result = [] for element in b: if not element in a: result.append (element) return result", "answer": "This function Returns the elements of B that are not in A."}
{"question": "def intersection (set1, set2): result = [] for v in set1: if v in set2: result.append (v) return result", "answer": "This function Removes from set1 any items which don't appear in set2 and returns the result."}
{"question": "def contains (small, large): small = to_seq (small) large = to_seq (large) for s in small: if not s in large: return False return True", "answer": "This function Returns true iff all elements of 'small' exist in 'large'."}
{"question": "def android_package_name(self): return self._android_package_name", "answer": "This function Returns the name of the Opera package"}
{"question": "def getconfig(ctx, config_output_dir): config_dir = config_output_dir if not ctx.init_with_checks(): print(\"Failed cursory checks, exiting.\") exit(1) if not ctx.consider_openshift_deployed: print(\"I think OpenShift is not yet deployed. Use deploy first to create it.\") exit(1) ctx.fetch_config_to_dir(config_dir)", "answer": "This function Writes the entire openshift config to a directory for inspection."}
{"question": "def uniquifyList(items): seen = set() for i in xrange(len(items)-1, -1, -1): it = items[i] if it in seen: del items[i] else: seen.add(it) return items", "answer": "This function Removes duplicate elements in list 'items', while keeping order intact."}
{"question": "def match( type ): type = intrusive_ptr_traits._strip_type( type ) if not isinstance( type, ( declarations.class_declaration.class_declaration_t, declarations.class_declaration.class_t ) ): return False if not declarations.type_traits.impl_details.is_defined_in_xxx( 'boost', type ): return False return type.decl_string.startswith( '::boost::intrusive_ptr<' )", "answer": "This function returns True, if type represents instantiation of C{boost::intrusive_ptr}, False otherwise"}
{"question": "def GenerationCheckGenerator(url_strs): for url_str in url_strs: if StorageUrlFromString(url_str).generation is not None: raise CommandException( '\"rewrite\" called on URL with generation (%s).' % url_str) yield url_str", "answer": "This function Generator function that ensures generation-less (live) arguments."}
{"question": "def get_main_version(version=None): version = get_complete_version(version) parts = 2 if version[2] == 0 else 3 return '.'.join(str(x) for x in version[:parts])", "answer": "This function Returns main version (X.Y[.Z]) from VERSION."}
{"question": "def gaussian(input, mu, sigma2): return (1/ (2*numpy.sqrt(3.14*sigma2))) * \\ numpy.exp( - ((input-mu)**2)/(2*sigma2))", "answer": "This function Calculates gaussian value for each input in the array"}
{"question": "def calculate_size(name, data_list): data_size = 0 data_size += calculate_size_str(name) data_size += INT_SIZE_IN_BYTES for data_list_item in data_list: data_size += calculate_size_data(data_list_item) return data_size", "answer": "This function Calculates the request payload size"}
{"question": "def set_name(self, name): if name is not None and re.search(r'^$|^-$|[/ \\t\\r\\n]', name): raise NameError('invalid blueprint name') self._name = name", "answer": "This function Validate and set the blueprint name."}
{"question": "def add_service(self, manager, service): # AWS cfn-init respects the enable and ensure parameters like Puppet # does. Blueprint provides these parameters for interoperability. self.services[manager].setdefault(service, {'enable': True, 'ensureRunning': True})", "answer": "This function Create a service resource which depends on given files and packages."}
{"question": "def add_service_file(self, manager, service, *args): if 0 == len(args): return s = self.services[manager][service].setdefault('files', set()) for dirname in args: s.add(dirname)", "answer": "This function Add file dependencies to a service resource."}
{"question": "def add_service_package(self, manager, service, package_manager, *args): if 0 == len(args): return d = self.services[manager][service].setdefault('packages', defaultdict(set)) for package in args: d[package_manager].add(package)", "answer": "This function Add package dependencies to a service resource."}
{"question": "def add_service_source(self, manager, service, *args): if 0 == len(args): return s = self.services[manager][service].setdefault('sources', set()) for dirname in args: s.add(dirname)", "answer": "This function Add source tarball dependencies to a service resource."}
{"question": "def add_source(self, dirname, filename): self.sources[dirname] = filename", "answer": "This function Create a source tarball resource."}
{"question": "def normalize(self): if 'arch' in self and self['arch'] is None: del self['arch'] for key in ['files', 'packages', 'sources']: if key in self and 0 == len(self[key]): del self[key]", "answer": "This function Remove superfluous empty keys to reduce variance in serialized JSON."}
{"question": "def testDecodeDateTime(self): for datetime_string, datetime_vals in ( ('2012-09-30T15:31:50.262', (2012, 9, 30, 15, 31, 50, 262000)), ('2012-09-30T15:31:50', (2012, 9, 30, 15, 31, 50, 0))): decoded = util.decode_datetime(datetime_string) expected = datetime.datetime(*datetime_vals) self.assertEquals(expected, decoded)", "answer": "This function Test that a RFC 3339 datetime string is decoded properly."}
{"question": "def map_init(interface, params): import random random.seed(params['seed']) return params", "answer": "This function Intialize random number generator with given seed `params.seed`."}
{"question": "def random_init_map(interface, state, label, inp): import random out = interface.output(0) for e in inp: out.add(random.randint(0, state['k']-1), state['create'](e[1],1.0))", "answer": "This function Assign datapoint `e` randomly to one of the `k` clusters."}
{"question": "def save_new(self, form, commit=True): return form.save(commit=commit)", "answer": "This function Saves and returns a new model instance for the given form."}
{"question": "def save_existing(self, form, instance, commit=True): return form.save(commit=commit)", "answer": "This function Saves and returns an existing model instance for the given form."}
{"question": "def delete_existing(self, obj, commit=True): if commit: obj.delete()", "answer": "This function Deletes an existing model instance."}
{"question": "def test_for_tag_unpack09(self): output = self.engine.render_to_string('for-tag-unpack09', {'items': (('one', 1), ('two', 2))}) self.assertEqual(output, 'one:1/two:2/')", "answer": "This function Ensure that a single loopvar doesn't truncate the list in val."}
{"question": "def is_connected(self): output = self.run_commands(['init', 'exit']) return output.find('Error:') == -1", "answer": "This function Return true if the device is connected to the programmer."}
{"question": "def enableCleanString(self): self._cleanStringEnabled=True", "answer": "This function All output will be cleaned from ANSI code and other unwanted garbage"}
{"question": "def setIgnoreStdError(self): self._ignoreStdError=True", "answer": "This function Disable display of stderr error messages to the standard output"}
{"question": "def addWaitToken(self,token): self._waitTokens.append(token)", "answer": "This function Adds a token that we will wait for when using C{self.wait()}"}
{"question": "def resetWaitTokens(self,token): self._waitTokens=[]", "answer": "This function Remove all tokens we'd wait for in self.wait()"}
{"question": "def logout(self): self.send('logout')", "answer": "This function This sends exit. If there are stopped jobs then this sends exit twice."}
{"question": "def pprint(self): out=self._ignoreLinesBasedOnFilter(self._lastOutput) error=self._lastError if(error!=\"\"): j.tools.console.echo(\"%s/nerror:%s\" % (out,error)) else: j.tools.console.echo(out)", "answer": "This function Print the result of all send & receive operations till now on local C{stdout}."}
{"question": "def serialize(self, obj): return self.encode(obj)", "answer": "This function This function performs the serialization on the given object."}
{"question": "def create_parser(cls, parser_class_name): module_name, class_name = parser_class_name.rsplit('.', 1) module = importlib.import_module(module_name) clss = getattr(module, class_name) if not issubclass(clss, cls): raise TypeError( \"Class {class_name!r} of module {module_name!r} doesn't \" \"implement 'NetworkTopologyParser' interface.\".format( class_name=class_name, module_name=module_name)) return clss()", "answer": "This function Creates a 'NetworkTopologyParser' of given class name."}
{"question": "def valid_vif_types(self):", "answer": "This function Returns a tuple listing VIF types supported by the compute node"}
{"question": "def run_time_limit(self, desired_result, default=3600.0 * 24 * 365 * 10): best = self.results_query(objective_ordered=True).first() if best is None: if desired_result.limit: return desired_result.limit else: return default if desired_result.limit: return min(desired_result.limit, self.upper_limit_multiplier * best.time) else: return self.default_limit_multiplier * best.time", "answer": "This function return a time limit to apply to a test run (in seconds)"}
{"question": "def fix_schemes_in_windows(): from sublime import windows for window in windows(): for view in window.views(): if syntax(view) in settings().get('supported_syntax'): fix_scheme_in_view(view)", "answer": "This function Change color schemes for all current views in the supported syntax list"}
{"question": "def fix_scheme_in_settings(settings_file,current_scheme, new_scheme, regenerate=False): from os.path import join, normpath, isfile settings = load_settings(settings_file) settings_scheme = settings.get(\"color_scheme\") if current_scheme == settings_scheme: new_scheme_path = join(packages_path(), normpath(new_scheme[len(\"Packages/\"):])) if isfile(new_scheme_path) and not regenerate: settings.set(\"color_scheme\", new_scheme) else: generate_scheme_fix(current_scheme, new_scheme_path) settings.set(\"color_scheme\", new_scheme) save_settings(settings_file) return True return False", "answer": "This function Change the color scheme in the given Settings to a background-corrected one"}
{"question": "def post(self): return self.get()", "answer": "This function A POST request to this endpoint does the same thing as a GET request."}
{"question": "def _GetConfigName(self, test): if test.overridden_anomaly_config: return test.overridden_anomaly_config.string_id() if self.request.get('config'): return 'Custom config' return 'Default config'", "answer": "This function Gets the name of the custom anomaly threshold, just for display."}
{"question": "def _GetConfigDict(self, test): input_config_json = self.request.get('config') if not input_config_json: return anomaly_config.GetAnomalyConfigDict(test) try: return json.loads(input_config_json) except ValueError: raise QueryParameterError('Invalid JSON.')", "answer": "This function Gets the name of the anomaly threshold dict to use."}
{"question": "def _ChartSeries(rows): return [(i, r.value) for i, r in enumerate(rows)]", "answer": "This function Returns a data series and index to revision map."}
{"question": "def _FetchStoredAnomalies(test, revisions): stored_anomalies = anomaly.Anomaly.GetAlertsForTest(test.key) stored_anomaly_dicts = [] for a in stored_anomalies: if a.end_revision > revisions[0]: stored_anomaly_dicts.append({ 'revision': a.end_revision, 'median_before': a.median_before_anomaly, 'median_after': a.median_after_anomaly, 'percent_changed': a.percent_changed, 'bug_id': _GetDisplayBugId(a.bug_id), 'timestamp': a.timestamp, }) return stored_anomaly_dicts", "answer": "This function Makes a list of data about Anomaly entities for a Test."}
{"question": "def _GraphUrl(test, revision): params = [ ('masters', test.master_name), ('bots', test.bot_name), ('tests', '/'.join(test.test_path.split('/')[2:])), ] if revision: params.append(('rev', revision)) return '/report?%s' % urllib.urlencode(params)", "answer": "This function Constructs an URL for requesting data from /graph_csv for |rows|."}
{"question": "def _GetDisplayBugId(bug_id): special_ids = {-1: 'INVALID', -2: 'IGNORE', None: 'NONE'} return special_ids.get(bug_id, str(bug_id))", "answer": "This function Returns a display string for the given bug ID property of an anomaly."}
{"question": "def get(self, k, d=None): try: return self.lookup(k) except KeyError: return d", "answer": "This function Dictionary-like `get` method with a default value"}
{"question": "def _handle_view(self, name, **kwargs): if not self.is_accessible(): if current_user.is_authenticated(): # permission denied abort(403) else: # login return redirect(url_for('security.login', next=request.url))", "answer": "This function Override builtin _handle_view in order to redirect users when a view is not accessible."}
{"question": "def _check_patch_operation(operation): valid_ops = ['add', 'remove', 'replace', 'move', 'copy', 'test'] if operation not in valid_ops: raise GenieError('Invalid operation [%s]. Must be in: %s' % ( operation, valid_ops))", "answer": "This function Helper function for checking HTTP patch methods"}
{"question": "def _assign_cart(request): try: if 'cart' in request.session: existing_cart = Cart.objects.from_request(request, create=False) contact = Contact.objects.from_request(request) if existing_cart.customer == None: # No currently assigned contact: Up for grabs! log.debug(\"Assigning Cart (id: %r) to %r (id: %r)\" % (existing_cart.id, contact.full_name, contact.id)) existing_cart.customer = contact existing_cart.save() else: log.debug(\"The user has no cart in the current session.\") except: log.debug(\"Unable to assign cart user during login\")", "answer": "This function If there is a current cart and it is unassigned, assign it to this user."}
{"question": "def login_signup_address(request, template_name=\"contact/login_signup_address.html\"): return login_signup(request, template_name=template_name, registration_handler=register_handle_address_form)", "answer": "This function View which allows a user to login or else fill out a full address form."}
{"question": "def cmd_to_string(cmd): return subprocess.Popen(cmd,shell=True,stdout=subprocess.PIPE).communicate()[0]", "answer": "This function Run a system command as in os.system(), but capture the stdout and return it as a string."}
{"question": "def topsize(): import os top_line=cmd_to_string(\"top -n 1 -b -p %d | grep '^[ ]*%d '\" % (os.getpid(),os.getpid())) return top_line.split()[5]", "answer": "This function Return the RES size of this process as reported by the top(1) command."}
{"question": "def default_memuse_analysis_fn(prefix=\"\"): import topo print \"%st%s: %s\" % (prefix,topo.sim.timestr(),allsizes_mb())", "answer": "This function Basic memuse function for use with memuse_batch()"}
{"question": "def plotting_and_saving_analysis_fn(prefix=\"\"): import topo from topo.command import save_snapshot from topo.command.analysis import measure_sine_pref,save_plotgroup print \"%sMemuse at time %s: %s\" % (prefix,topo.sim.timestr(),allsizes_mb()) measure_sine_pref() print \"%sAfter measure_sine_pref: %s\" % (prefix,allsizes_mb()) save_plotgroup(\"Orientation Preference\") print \"%sAfter save_plotgroup: %s\" % (prefix,allsizes_mb()) save_snapshot(\"/tmp/tmp.typ\") print \"%sAfter save_snapshot: %s\" % (prefix,allsizes_mb())", "answer": "This function For use with memuse_batch() to test snapshot and plotting memory usage."}
{"question": "def DiffAnys(obj1, obj2, looseMatch=False, ignoreArrayOrder=True): differ = Differ(looseMatch = looseMatch, ignoreArrayOrder = ignoreArrayOrder) return differ.DiffAnyObjects(obj1, obj2)", "answer": "This function Diff any two objects. Objects can either be primitive type or DataObjects"}
{"question": "def update(self): try: state = template.render(self.hass, self._template).lower() if state in _VALID_STATES: self._state = state in ('true', STATE_ON) else: _LOGGER.error( 'Received invalid switch is_on state: %s. Expected: %s', state, ', '.join(_VALID_STATES)) self._state = None except TemplateError as ex: _LOGGER.error(ex) self._state = None", "answer": "This function Update the state from the template."}
{"question": "def save_model(self, request, obj, form, change): super(TweetableAdminMixin, self).save_model(request, obj, form, change) if Api and request.POST.get(\"send_tweet\", False): auth_settings = get_auth_settings() obj.set_short_url() message = truncatechars(obj, 140 - len(obj.short_url) - 1) api = Api(*auth_settings) api.PostUpdate(\"%s %s\" % (message, obj.short_url))", "answer": "This function Sends a tweet with the title/short_url if applicable."}
{"question": "def _dpath(path=''): return os.path.realpath(os.path.join(os.path.dirname(__file__), path))", "answer": "This function get path to a data file (relative to the directory this test lives in)"}
{"question": "def test_addHeader(): reader = vcf.Reader(open(os.path.join(_dpath(),TESTFILE))) SDST.strelka.addStrelkaHeaders(reader) assert reader.infos['TUMREF']", "answer": "This function Make sure that addStrelkaHeaders adds at least one header to vcf reader"}
{"question": "def linestring(self, node): if node == self.edge.orientation_neg: return self.linestring_negative elif node == self.edge.orientation_pos: return self.linestring_positive else: raise AttributeError(\"Specified node is not one of the terminal edge nodes\")", "answer": "This function Partial edge linestring from/to the specified node. Direction is always neg to pos."}
{"question": "def extent(self): xmin = np.inf ymin = np.inf xmax = -np.inf ymax = -np.inf for l in self.lines_iter(): a, b, c, d = l.bounds xmin = min(xmin, a) ymin = min(ymin, b) xmax = max(xmax, c) ymax = max(ymax, d) return xmin, ymin, xmax, ymax", "answer": "This function Compute the rectangular bounding coordinates of the edges"}
{"question": "def datetime_to_synergy(time_qualifier, dt): if time_qualifier == QUALIFIER_HOURLY: date_format = SYNERGY_HOURLY_PATTERN elif time_qualifier == QUALIFIER_DAILY: date_format = SYNERGY_DAILY_PATTERN elif time_qualifier == QUALIFIER_MONTHLY: date_format = SYNERGY_MONTHLY_PATTERN elif time_qualifier == QUALIFIER_YEARLY: date_format = SYNERGY_YEARLY_PATTERN elif time_qualifier == QUALIFIER_REAL_TIME: date_format = SYNERGY_SESSION_PATTERN else: raise ValueError('unknown time qualifier: {0}'.format(time_qualifier)) return dt.strftime(date_format)", "answer": "This function method parses datetime and returns Synergy Date"}
{"question": "def session_to_epoch(timestamp): utc_timetuple = datetime.strptime(timestamp, SYNERGY_SESSION_PATTERN).replace(tzinfo=None).utctimetuple() return calendar.timegm(utc_timetuple)", "answer": "This function converts Synergy Timestamp for session to UTC zone seconds since epoch"}
{"question": "def _maximize_font_size(font, text, max_size): font_size = max_size fontobj = ImageFont.truetype(font, font_size) text_size = fontobj.getsize(text) while text_size[0] > max_size and font_size > 1: font_size = font_size - 1 fontobj = ImageFont.truetype(font, font_size) text_size = fontobj.getsize(text) return font_size", "answer": "This function Find the biggest font size that will fit."}
