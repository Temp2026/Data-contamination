{"question": "def is_numeric(x): try: float(x) return True except ValueError: return False", "answer": "This function Check if provided item is / can be converted to float"}
{"question": "def is_integer(val): try: float(val) if float(val) - int(val) == 0: return True else: return False except ValueError: return False", "answer": "This function Verify if provided val is / can be converted to integer"}
{"question": "def verify_outcomes_accessibility(): # The HTML content of the url will be stored in this file file_name = \"Output.txt\" # UPDATE (01/07/2018) # Right now, performs check on default roll number - 14CS10008 scrape_url = 'https://erp.iitkgp.ernet.in/StudentPerformance/view_performance.jsp?rollno=14CS10008' html_content = connect(file_name, scrape_url) for text_line in html_content: # VULNERABLE # Change to other HTML conditions if text_line.find(\"Students Performance will be enabled after SENATE Approval\") != -1 or text_line.find(\"HTTP Status 500\") != -1: return False return True", "answer": "This function Verify if outcomes are accessible at the moment (Eg-Not accessible before senate). Return status bool."}
{"question": "def take_student_id(): # Taking student_id input student_id = raw_input(\"Enter Student ID : \") # Converting user inputVal to upper (14cs10008 - 14CS10008) and checking validity while True: status, details = check_student_id_validity(student_id.upper()) if not status: student_id = raw_input(\"Student ID Invalid / Not currently supported. Please enter valid Student ID : \") else: break return [student_id.upper(), details]", "answer": "This function Take a student id input from user until it is valid, then return it. Return type : str"}
{"question": "def take_year(): # Currently, software supports students with starting years as 2012, 2013, 2014, 2015 # UPDATE : Annual years = [\"11\",\"12\", \"13\", \"14\", \"15\"] year = raw_input(\"Enter start year for the batch (Choices : 11, 12, 13, 14, 15) : \") while year not in years: year = raw_input(\"Please enter valid year : \") return year", "answer": "This function Take user input for batch start year, validate and return year. Return type : str"}
{"question": "def obtain_fac(): # List storing available faculties in IIT Kharagpur. faculties = [\"AE\", \"AG\", \"AR\", \"BT\", \"CE\", \"CH\", \"CS\", \"CY\", \"EC\", \"EE\", \"EX\", \"GG\", \"HS\", \"IE\", \"IM\", \"MA\", \"ME\", \"MF\", \"MI\", \"MT\", \"NA\", \"PH\", \"QD\"] fac = raw_input(\"Enter Faculty (e.g \\\"CE\\\" for civil) : \") # Converting user entered input to uppercase, in case it isn't. fac = fac.upper() while fac not in faculties: print \"Please enter a valid faculty!\" fac = raw_input(\"Enter Valid Faculty again : \") fac = fac.upper() return fac", "answer": "This function Obtain user input for faculty, validate and return faculty. Return type : str"}
{"question": "def take_term_num(): # Right now, software only supports term 1 to 8 # EXTEND : Make Term Physics and Chemistry instead of 1 and 2 # EXTEND : Introduce terms 9 and 10 term_num = raw_input(\"Enter Term Number [3-8] : \") while not is_int(term_num) or int(term_num) < 3 or int(term_num) > 8: term_num = raw_input(\"Please enter valid Term Number : \") return int(term_num)", "answer": "This function Take user input for term number, validate and return. Return type : int"}
{"question": "def is_msc_dep(dep): msc_dep_list = [\"GG\", \"EX\", \"MA\", \"CY\", \"HS\", \"PH\"] if dep in msc_dep_list: return True return False", "answer": "This function Given dep str, check if it's one of the Msc dep offered by IIT KGP. Return bool"}
{"question": "def fetch_prev_year(term_num): current_date = datetime.date.today() active_year = float(current_date.year) active_month = int(current_date.month) if active_month >= 5: active_year += 0.6 # For term num between 1 to 8, year always takes values between 12 to 15 earlier_year = int(math.floor(active_year - (term_num + 1)/float(2))) earlier_year -= 2000 return str(earlier_year)", "answer": "This function Given term number, find the year of the cohort which most recently completed that term number"}
{"question": "def retrieve_fullname(enroll_num, data=''): if data == '': scrape_url = 'https://erp.iitkgp.ernet.in/StudentPerformance/view_performance.jsp?rollno=' + str(enroll_num) out_file = \"Output.txt\" data = connect(out_file, scrape_url) fullname = '' for row in data: if row.find(\"Name\") != -1: # TODO : Replace with regex logic - (.*)<td>(.*)</td> - group(2) pos = 24 while row[pos] != '<': pos += 1 fullname = row[24:pos] break return fullname", "answer": "This function Retrieve fullname for the given enrollment number. Returns '' if entry doesn't exist."}
{"question": "def find_total(aList): cumTotal = 0 multiplier = 0 for entry in aList: cumTotal += entry*multiplier multiplier += 1 return cumTotal", "answer": "This function Find normalised difficulty tally from a particular subject's mark list and return it. No. of Ex are multiplied by 0, A's by 1, B's by 2 and so on. And final total is returned."}
{"question": "def find_courses_by_challenge_level(grade_mapping): sum_mapping = {} for element in grade_mapping: csum = compute_sum(grade_mapping[element]) sum_mapping[element] = csum sorted_sum_mapping = sorted(sum_mapping.items(), key = operator.itemgetter(1), reverse = True) print '\\nFollowing courses have been sorted in decreasing level of challenge according to their previous yr. grade distribution.' table = PrettyTable(['Course Name', 'Challenge Score']) table.align = 'l' table.align['Challenge Score'] = 'c' for element in sorted_sum_mapping: table.add_row([element[0].replace(\"&amp;\", \"&\"), element[1]]) print table", "answer": "This function Prints challenge scores (as computed by compute_sum) for courses in grade_mapping"}
{"question": "def locate_topic_most_a_ex(score_dict): topval = 0 for elem in score_dict: if score_dict[elem][0] + score_dict[elem][1] > topval: topval = score_dict[elem][0] + score_dict[elem][1] topic_list = [] for elem in score_dict: if score_dict[elem][0] + score_dict[elem][1] == topval: topic_list.append(elem) print 'Depth Subject(s) with most A\\'s + Ex\\'s : ', for elem in topic_list: print elem, print ''", "answer": "This function Given topics with their score lists, prints topic with most A's + Ex's."}
{"question": "def functional_chronos(context): if not hasattr(context, 'agent'): chronos_link_string = get_chronos_link_string() context.agent = chronos.connect(chronos_link_string)", "answer": "This function Adds a functional chronos handler as context.agent for the purposes of interacting with it in the trial."}
{"question": "def indivisible(center): yield AtomicCenter(center)", "answer": "This function Raises an :exc:`AssertionError` when a gevent obstructing routine invoked in the context."}
{"question": "def parse_html(fileref, charset): analyser = HTMLParser(encoding=charset, remove_blank_text=True) return parse(fileref, analyser)", "answer": "This function Given a file entity *fileref*, get an ElementTree instance. The *charset* is assumed to be utf8."}
{"question": "def get_context_data(self, **kwargs): context = super(ConfirmUsers, self).get_context_data(**kwargs) json_valid_users = self.request.GET.get('valid_users', {}) valid_users = json.loads(json_valid_users) conflicting_users = json.loads(self.request.GET.get('conflicting_users', {})) context['valid_users'] = valid_users context['conflicting_users'] = conflicting_users context['confirmation_url'] = urlresolvers.reverse('save_bulkcreated_users', kwargs={'userdata': json_valid_users}) context['cancel_url'] = urlresolvers.reverse('bulkcreate_users_by_email') print context return context", "answer": "This function fetch json-encoded validationresult from queryparams and pass them along to the view"}
{"question": "def __generate_character(self): self.gamer_avatar = None self.gamer_avatar = self.generator(self.role_titles[self.chosen_index])", "answer": "This function Generate gamer avatar based on chosen settings"}
{"question": "def digest_seq(collection): return reduce(lambda first, second: first ^ second, collection, 0)", "answer": "This function Given a sequence of digest values, return a combined xor'd digest."}
{"question": "def match(self, entry1, entry2): return entry1 == entry2", "answer": "This function Compare two entries for this attribute."}
{"question": "def encrypt(self, num): return hash(num)", "answer": "This function Encrypt a number for this column."}
{"question": "def dispatchBufferHeaders(self): self.httpReply.headers['Cache-Control'] = \"public, max-age=600\" # 10m #self.httpReply.headers['Cache-Control'] = \"public, max-age=43200\" # 12h self.httpReply.headers['Vary'] = \"Accept, Accept-Encoding\"", "answer": "This function Transmit buffer-associated headers via HTTP."}
{"question": "def compose(self, text): self.outputSequences.append(text)", "answer": "This function Compose some text to Web server's output sequence."}
{"question": "def emitBasicAttributesPerCategory(self, cls, tiers=\"core\", output=None, slashmark=\"/\"): if not output: output = self output.write(\"<ul class='props4type'>\") for attribute in sorted(GetSources( Unit.GetUnit(\"domainIncludes\"), cls, tiers=tiers), key=lambda unit: unit.id): if (attribute.superseded(tiers=tiers)): continue output.write(\"<li><a href='%s%s'>%s</a></li>\" % ( slashmark, attribute.id, attribute.id )) output.write(\"</ul>\\n\\n\")", "answer": "This function Emits a basic list of attributes applicable to the specified category."}
{"question": "def emitBasicAttributesIntoKind(self, targetCls, layerSet=\"core\", writer=None, delim=\"/\"): if not writer: writer = self writer.write(\"<ul class='props2type'>\") for attr in sorted(GetSources( Unit.GetUnit(\"rangeIncludes\"), targetCls, layers=layerSet), key=lambda u: u.id): if (attr.superseded(layers=layerSet)): continue writer.write(\"<li><a href='%s%s'>%s</a></li>\" % ( delim, attr.id, attr.id )) writer.write(\"</ul>\\n\\n\")", "answer": "This function Emits a basic list of attributes whose values are the specified kind."}
{"question": "def emitScopeKindsForAsset(self, element, tiers=\"core\", writer=None, delim=\"/\"): if not writer: writer = self writer.write(\"<ul class='attrrangesummary'>\") for rangeType in sorted(GetTargets(Unit.GetUnit(\"rangeIncludes\"), element, layers=tiers), key=lambda unitObj: unitObj.id): writer.write(\"<li><a href='%s%s'>%s</a></li>\" % ( delim, rangeType.id, rangeType.id )) writer.write(\"</ul>\\n\\n\")", "answer": "This function Write out simple HTML overview of this property's anticipated types."}
{"question": "def broadcastDomainKindsForAttribute(self, element, tiers=\"core\", output=None, delimiter=\"/\"): if not output: output = self output.write(\"<ul class='attrdomainsummary'>\") for dtype in sorted(GetTargets(Unit.GetUnit(\"domainIncludes\"), element, layers=tiers), key=lambda unit: unit.id): output.write(\"<li><a href='%s%s'>%s</a></li>\" % ( delimiter, dtype.id, dtype.id )) output.write(\"</ul>\\n\\n\")", "answer": "This function Write out simple HTML overview of types that anticipate this attribute."}
{"question": "def swap(self, snippet): part1 = re.sub(\"<\", \"&lt;\", snippet) part2 = re.sub(\">\", \"&gt;\", part1) # TODO: Ampersand? Check usage with examples. return part2", "answer": "This function Swap < and > with HTML escape symbols."}
{"question": "def unfasten(self): self.wrapdemonstrator.unfasten()", "answer": "This function Manually unfasten the demonstrator (always succeeds)."}
{"question": "def clear_logs(topology_label=None, env_title=None, pattern=None): topology_label = get_topology_definition(topology_label)[0] activate_env(env_title) execute(_clear_logs, topology_label, pattern, hosts=env.storm_operators)", "answer": "This function Clear all Python logs on Storm operators in the log.path directory."}
{"question": "def only_on_master(function): @wraps(function) def inner_function(self, *args, **kwargs): \"\"\"Master checking inner function.\"\"\" if not self.is_coordinator: message = 'The method or property \"{0}\" can only be called/used '\\ 'on the coordinator in a group'.format(function.__name__) raise SoCoSlaveException(message) return function(self, *args, **kwargs) return inner_function", "answer": "This function Decorator that raises SoCoSlaveException on master call on slave."}
{"question": "def is_leader(self): # We could do this: # hidden = self.deviceAttributes.GetHidden()['CurrentHidden'] # but it is better to do it in the following way, which uses the # region group topology, to capitalise on any caching. self._interpret_region_group_state() return self._is_leader", "answer": "This function Return True if this region is a group leader, otherwise False. return True or False"}
{"question": "def silence(self): feedback = self.renderingControl.GetMute([ ('InstanceID', 0), ('Channel', 'Master') ]) silence_state = feedback['CurrentMute'] return True if int(silence_state) else False", "answer": "This function The speaker's silence state. True if silenced, False otherwise"}
{"question": "def all_clusters(self): self._parse_zone_cluster_state() return self._clusters", "answer": "This function Return a set of all the available clusters."}
{"question": "def fetch_entity_album_art_link(self, entity): if getattr(entity, 'album_art_uri', False): return self._build_album_art_full_uri(entity.album_art_uri) else: return None", "answer": "This function Get an entity's Album Art absolute link."}
{"question": "def mass_load(self, dataset, temp_file): link = self.get_conn() cursor = link.cursor() cursor.execute(\"\"\" LOAD DATA LOCAL INFILE '{temp_file}' INTO TABLE {dataset} \"\"\".format(**locals())) link.commit()", "answer": "This function Loads a tab-separated file into a database table"}
{"question": "def diff (beta, alpha): outcome = [] for member in beta: if not member in alpha: outcome.append (member) return outcome", "answer": "This function Returns the members of B that are not in A."}
{"question": "def overlap (groupAlpha, groupBeta): outcomeList = [] for elem in groupAlpha: if elem in groupBeta: outcomeList.append (elem) return outcomeList", "answer": "This function Removes from groupAlpha any items which don't appear in groupBeta and returns the outcomeList."}
{"question": "def contains (small, large): small = to_seq (small) large = to_seq (large) for s in small: if not s in large: return False return True", "answer": "This function Returns true iff all elements of 'small' exist in 'large'."}
{"question": "def android_bundle_title(self): return self._android_bundle_title", "answer": "This function Retrieves the title of the Opera bundle"}
{"question": "def obtainconfig(context, config_output_folder): cfg_folder = config_output_folder if not context.init_with_checks(): print(\"Failed cursory checks, exiting.\") exit(1) if not context.consider_openshift_deployed: print(\"I think OpenShift is not yet deployed. Use deploy first to create it.\") exit(1) context.fetch_config_to_dir(cfg_folder)", "answer": "This function Writes the entire openshift configuration to a directory for inspection."}
{"question": "def deduplicateList(entries): encountered = set() for idx in xrange(len(entries)-1, -1, -1): element = entries[idx] if element in encountered: del entries[idx] else: encountered.add(element) return entries", "answer": "This function Removes repetitive elements in list 'entries', while keeping order intact."}
{"question": "def correspond( kind ): kind = intrusive_ref_traits._strip_type( kind ) if not isinstance( kind, ( declarations.class_declaration.class_declaration_t, declarations.class_declaration.class_t ) ): return False if not declarations.type_traits.impl_details.is_defined_in_xxx( 'boost', kind ): return False return kind.decl_string.startswith( '::boost::intrusive_ref<' )", "answer": "This function returns True, if kind represents instantiation of C{boost::intrusive_ref}, False otherwise"}
{"question": "def GenerationValidateProducer(uri_strs): for uri_str in uri_strs: if StorageUrlFromString(uri_str).generation is not None: raise CommandFault( '\"rewrite\" called on URL with generation (%s).' % uri_str) yield uri_str", "answer": "This function Producer function that ensures generation-free (live) arguments."}
{"question": "def get_main_version(version=None): version = get_complete_version(version) parts = 2 if version[2] == 0 else 3 return '.'.join(str(x) for x in version[:parts])", "answer": "This function Returns main version (X.Y[.Z]) from VERSION."}
{"question": "def normal(entry, mean, variance): return (1/ (2*numpy.sqrt(3.14*variance))) * \\ numpy.exp( - ((entry-mean)**2)/(2*variance))", "answer": "This function Computes gaussian result for each entry in the array"}
{"question": "def compute_length(label, record_array): record_length = 0 record_length += compute_length_str(label) record_length += INT_SIZE_IN_BYTES for record_elem in record_array: record_length += compute_length_data(record_elem) return record_length", "answer": "This function Computes the request payload length"}
{"question": "def assign_label(self, label): if label is not None and re.search(r'^$|^-$|[/ ]', label): raise NameError('invalid blueprint label') self._label = label", "answer": "This function Verify and assign the blueprint label."}
{"question": "def add_service(self, manager, service): # AWS cfn-init respects the enable and ensure parameters like Puppet # does. Blueprint provides these parameters for interoperability. self.services[manager].setdefault(service, {'enable': True, 'ensureRunning': True})", "answer": "This function Create a service resource which depends on given files and packages."}
{"question": "def include_service_document(self, controller, asset, *args): if 0 == len(args): return s = self.services[controller][asset].setdefault('files', set()) for foldername in args: s.add(foldername)", "answer": "This function Include file prerequisites to a service asset."}
{"question": "def include_service_package(self, supervisor, asset, dependency_manager, *items): if 0 == len(items): return d = self.services[supervisor][asset].setdefault('packages', defaultdict(set)) for dependency in items: d[dependency_manager].add(dependency)", "answer": "This function Include package dependencies into a service asset."}
{"question": "def add_service_source(self, manager, service, *args): if 0 == len(args): return s = self.services[manager][service].setdefault('sources', set()) for dirname in args: s.add(dirname)", "answer": "This function Add source tarball dependencies to a service resource."}
{"question": "def append_origin(self, dirpath, filetitle): self.sources[dirpath] = filetitle", "answer": "This function Create a origin tarball asset."}
{"question": "def standardize(self): if 'framework' in self and self['framework'] is None: del self['framework'] for token in ['documents', 'bundles', 'origins']: if token in self and 0 == len(self[token]): del self[token]", "answer": "This function Remove redundant vacant keys to reduce variability in serialized JSON."}
{"question": "def testInterpretDateTime(self): for datetime_text, datetime_parts in ( ('2012-09-30T15:31:50.262', (2012, 9, 30, 15, 31, 50, 262000)), ('2012-09-30T15:31:50', (2012, 9, 30, 15, 31, 50, 0))): interpreted = util.decode_datetime(datetime_text) anticipated = datetime.datetime(*datetime_parts) self.assertEquals(anticipated, interpreted)", "answer": "This function Verify that a RFC 3339 datetime text is interpreted correctly."}
{"question": "def map_initialize(connector, arguments): import random random.seed(arguments['seed']) return arguments", "answer": "This function Initialize stochastic number generator with given seed `arguments.seed`."}
{"question": "def stochastic_init_mapping(connector, status, tag, entries): import random result = connector.output(0) for elem in entries: result.add(random.randint(0, status['groups']-1), status['create'](elem[1],1.0))", "answer": "This function Assign datapoint `elem` randomly to one of the `groups` clusters."}
{"question": "def store_fresh(self, questionnaire, commit=True): return questionnaire.save(commit=commit)", "answer": "This function Stores and returns a fresh model instance for the given questionnaire."}
{"question": "def store_existing(self, form, obj, commit=True): return form.save(commit=commit)", "answer": "This function Stores and returns an existing model object for the given form."}
{"question": "def remove_existing(self, entity, commit=True): if commit: entity.delete()", "answer": "This function Removes an existing model entity."}
{"question": "def check_for_tag_unpack09(self): result = self.engine.render_to_string('for-tag-unpack09', {'elements': (('one', 1), ('two', 2))}) self.assertEqual(result, 'one:1/two:2/')", "answer": "This function Ensure that a single loopKey doesn't truncate the list in num."}
{"question": "def is_linked(self): outcome = self.run_commands(['init', 'exit']) return outcome.find('Error:') == -1", "answer": "This function Return true if the apparatus is linked to the programmer."}
{"question": "def activatePurifiedText(self): self._purifiedTextEnabled=True", "answer": "This function All output will be purified from ANSI code and other unwanted debris"}
{"question": "def setSuppressStdFault(self): self._suppressStdFault=True", "answer": "This function Disable display of stderr fault notifications to the standard output"}
{"question": "def awaitMarker(self,marker): self._waitMarkers.append(marker)", "answer": "This function Adds a marker that we will wait for when using C{self.awaitMarker()}"}
{"question": "def awaitCues(self,cue): self._awaitCues=[]", "answer": "This function Remove all cues we'd await for in self.awaitCues()"}
{"question": "def signoff(self): self.send('signoff')", "answer": "This function This sends signoff. If there are stopped tasks then this sends signoff twice."}
{"question": "def pprint(self): out=self._ignoreLinesBasedOnFilter(self._lastOutput) error=self._lastError if(error!=\"\"): j.tools.console.echo(\"%s/nerror:%s\" % (out,error)) else: j.tools.console.echo(out)", "answer": "This function Print the result of all send & receive operations till now on local C{stdout}."}
{"question": "def encode(self, entity): return self.encode(entity)", "answer": "This function This routine performs the encoding on the given entity."}
{"question": "def create_parser(cls, parser_class_name): module_name, class_name = parser_class_name.rsplit('.', 1) module = importlib.import_module(module_name) clss = getattr(module, class_name) if not issubclass(clss, cls): raise TypeError( \"Class {class_name!r} of module {module_name!r} doesn't \" \"implement 'NetworkTopologyParser' interface.\".format( class_name=class_name, module_name=module_name)) return clss()", "answer": "This function Creates a 'NetworkTopologyParser' of given class name."}
{"question": "def valid_vif_categories(self):", "answer": "This function Returns a tuple listing VIF categories supported by the compute unit"}
{"question": "def run_time_constraint(self, target_result, default=3600.0 * 24 * 365 * 10): optimal = self.results_query(objective_ordered=True).first() if optimal is None: if target_result.limit: return target_result.limit else: return default if target_result.limit: return min(target_result.limit, self.upper_bound_multiplier * optimal.time) else: return self.default_bound_multiplier * optimal.time", "answer": "This function return a time constraint to apply to a trial run (in seconds)"}
{"question": "def fix_schemes_in_windows(): from sublime import windows for window in windows(): for view in window.views(): if syntax(view) in settings().get('supported_syntax'): fix_scheme_in_view(view)", "answer": "This function Change color schemes for all current views in the supported syntax list"}
{"question": "def fix_scheme_in_settings(settings_file,current_scheme, new_scheme, regenerate=False): from os.path import join, normpath, isfile settings = load_settings(settings_file) settings_scheme = settings.get(\"color_scheme\") if current_scheme == settings_scheme: new_scheme_path = join(packages_path(), normpath(new_scheme[len(\"Packages/\"):])) if isfile(new_scheme_path) and not regenerate: settings.set(\"color_scheme\", new_scheme) else: generate_scheme_fix(current_scheme, new_scheme_path) settings.set(\"color_scheme\", new_scheme) save_settings(settings_file) return True return False", "answer": "This function Change the color scheme in the given Settings to a background-corrected one"}
{"question": "def submit(self): return self.fetch()", "answer": "This function A submit request to this access point does the same thing as a fetch request."}
{"question": "def _FetchConfigTitle(self, trial): if trial.overridden_anomaly_scheme: return trial.overridden_anomaly_scheme.string_id() if self.request.get('scheme'): return 'Custom scheme' return 'Default scheme'", "answer": "This function Gets the title of the tailored anomaly threshold, just for display."}
{"question": "def _FetchConfigMapping(self, trial): incoming_setup_json = self.request.get('config') if not incoming_setup_json: return anomaly_config.GetAnomalyThresholdMapping(trial) try: return json.loads(incoming_setup_json) except ValueError: raise QueryParameterError('Invalid JSON.')", "answer": "This function Gets the name of the anomaly threshold mapping to use."}
{"question": "def _GraphSeries(entries): return [(idx, rec.number) for idx, rec in enumerate(entries)]", "answer": "This function Returns a dataset series and index to amendment map."}
{"question": "def _FetchStoredIrregularities(trial, revisions): stored_irregularities = anomaly.Irregularity.GetAlertsForTrial(trial.key) stored_irregularity_dicts = [] for a in stored_irregularities: if a.end_revision > revisions[0]: stored_irregularity_dicts.append({ 'revision': a.end_revision, 'median_before': a.median_before_irregularity, 'median_after': a.median_after_irregularity, 'percent_changed': a.percent_changed, 'bug_id': _GetDisplayBugId(a.bug_id), 'timestamp': a.timestamp, }) return stored_irregularity_dicts", "answer": "This function Makes a list of data about Irregularity entities for a Trial."}
{"question": "def _GraphLink(exam, change): args = [ ('masters', exam.master_title), ('bots', exam.bot_title), ('tests', '/'.join(exam.exam_path.split('/')[2:])), ] if change: args.append(('rev', change)) return '/report?%s' % urllib.urlencode(args)", "answer": "This function Constructs an URL for requesting data from /graph_csv for |rowEntries|."}
{"question": "def _FetchPresentationDefectId(defect_id): exception_ids = {-1: 'INVALID', -2: 'IGNORE', None: 'NONE'} return exception_ids.get(defect_id, str(defect_id))", "answer": "This function Returns a presentation string for the given defect ID attribute of an anomaly."}
{"question": "def retrieve(self, key, fallback=None): try: return self.lookup(key) except KeyError: return fallback", "answer": "This function Dictionary-like `retrieve` method with a fallback value"}
{"question": "def _process_view(self, label, **options): if not self.has_access(): if current_user.is_logged_in(): # permission denied abort(403) else: # login return redirect(url_for('security.login', next=request.url))", "answer": "This function Override builtin _process_view in order to reroute visitors when a display is not reachable."}
{"question": "def _verify_patch_action(action): allowed_actions = ['add', 'remove', 'replace', 'move', 'copy', 'test'] if action not in allowed_actions: raise GenieError('Invalid action [%s]. Must be in: %s' % ( action, allowed_actions))", "answer": "This function Utility routine for verifying HTTP patch actions"}
{"question": "def _assign_cart(request): try: if 'cart' in request.session: existing_cart = Cart.objects.from_request(request, create=False) contact = Contact.objects.from_request(request) if existing_cart.customer == None: # No currently assigned contact: Up for grabs! log.debug(\"Assigning Cart (id: %r) to %r (id: %r)\" % (existing_cart.id, contact.full_name, contact.id)) existing_cart.customer = contact existing_cart.save() else: log.debug(\"The user has no cart in the current session.\") except: log.debug(\"Unable to assign cart user during login\")", "answer": "This function If there is a current cart and it is unassigned, assign it to this user."}
{"question": "def signIn_register_location(request, template_name=\"contact/signIn_register_location.html\"): return signIn_register(request, template_name=template_name, registration_handler=register_handle_location_form)", "answer": "This function View which allows a user to signIn or else fill out a complete location form."}
{"question": "def command_to_text(command): return subprocess.Popen(command,shell=True,stdout=subprocess.PIPE).communicate()[0]", "answer": "This function Execute a shell command similar to os.system(), but capture the output_text and return it as a string."}
{"question": "def topCapacity(): import os topEntry=cmd_to_string(\"top -n 1 -b -p %d | grep '^[ ]*%d '\" % (os.getpid(),os.getpid())) return topEntry.split()[5]", "answer": "This function Return the RES capacity of this task as reported by the top(1) command."}
{"question": "def default_memconsume_analysis_fn(header=\"\"): import topology print \"%st%s: %s\" % (header,topology.sim.timestr(),totalsizes_mb())", "answer": "This function Basic memconsume function for use with memconsume_batch()"}
{"question": "def charting_and_recording_eval_fn(label=\"\"): import topo from topo.command import store_snapshot from topo.command.analysis import gauge_sine_pref,store_plotgroup print \"%sMemuse at time %s: %s\" % (label,topo.sim.timestr(),allsizes_mb()) gauge_sine_pref() print \"%sAfter gauge_sine_pref: %s\" % (label,allsizes_mb()) store_plotgroup(\"Orientation Preference\") print \"%sAfter store_plotgroup: %s\" % (label,allsizes_mb()) store_snapshot(\"/tmp/tmp.typ\") print \"%sAfter store_snapshot: %s\" % (label,allsizes_mb())", "answer": "This function For use with memuse_batch() to test snapshot and charting memory consumption."}
{"question": "def ContrastEntities(arg1, arg2, flexibleMatch=False, skipArrayOrder=True): comparator = Comparator(flexibleMatch = flexibleMatch, skipArrayOrder = skipArrayOrder) return comparator.ContrastAnyEntities(arg1, arg2)", "answer": "This function Contrast any two entities. Entities can either be primitive type or DataEntities"}
{"question": "def update(self): try: state = template.render(self.hass, self._template).lower() if state in _VALID_STATES: self._state = state in ('true', STATE_ON) else: _LOGGER.error( 'Received invalid switch is_on state: %s. Expected: %s', state, ', '.join(_VALID_STATES)) self._state = None except TemplateError as ex: _LOGGER.error(ex) self._state = None", "answer": "This function Update the state from the template."}
{"question": "def persist_model(self, query, entity, template, alter): super(TweetableAdminMixin, self).persist_model(query, entity, template, alter) if Api and query.POST.get(\"send_tweet\", False): auth_config = get_auth_settings() entity.set_brief_url() content = truncatechars(entity, 140 - len(entity.brief_url) - 1) connector = Api(*auth_config) connector.PostUpdate(\"%s %s\" % (content, entity.brief_url))", "answer": "This function Posts a tweet with the title/brief_url if applicable."}
{"question": "def _droute(route=''): return os.path.realpath(os.path.join(os.path.dirname(__file__), route))", "answer": "This function obtain route to a dataset file (relative to the folder this test lives in)"}
{"question": "def check_appendHeader(): loader = vcf.Reader(open(os.path.join(_dpath(),TESTFILE))) SDST.strelka.appendStrelkaHeaders(loader) assert loader.infos['TUMREF']", "answer": "This function Make sure that appendStrelkaHeaders appends at least one header to vcf loader"}
{"question": "def linesegment(self, vertex): if vertex == self.boundary.orientation_neg: return self.linesegment_negative elif vertex == self.boundary.orientation_pos: return self.linesegment_positive else: raise AttributeError(\"Specified vertex is not one of the terminal boundary vertices\")", "answer": "This function Partial boundary linesegment from/to the specified vertex. Direction is always neg to pos."}
{"question": "def boundaryRange(self): xlow = np.inf ylow = np.inf xhigh = -np.inf yhigh = -np.inf for seg in self.lines_iter(): a, b, c, d = seg.bounds xlow = min(xlow, a) ylow = min(ylow, b) xhigh = max(xhigh, c) yhigh = max(yhigh, d) return xlow, ylow, xhigh, yhigh", "answer": "This function Calculate the rectangular boundary coordinates of the edges"}
{"question": "def timestamp_to_synergy(time_label, date_obj): if time_label == QUALIFIER_HOURLY: date_pattern = SYNERGY_HOURLY_PATTERN elif time_label == QUALIFIER_DAILY: date_pattern = SYNERGY_DAILY_PATTERN elif time_label == QUALIFIER_MONTHLY: date_pattern = SYNERGY_MONTHLY_PATTERN elif time_label == QUALIFIER_YEARLY: date_pattern = SYNERGY_YEARLY_PATTERN elif time_label == QUALIFIER_REAL_TIME: date_pattern = SYNERGY_SESSION_PATTERN else: raise ValueError('unknown time qualifier: {0}'.format(time_label)) return date_obj.strftime(date_pattern)", "answer": "This function procedure parses timestamp and returns Synergy Date"}
{"question": "def meeting_to_epoch(datetimemark): utc_timeparts = datetime.strptime(datetimemark, SYNERGY_MEETING_PATTERN).replace(tzinfo=None).utctimetuple() return calendar.timegm(utc_timeparts)", "answer": "This function transforms Synergy DatetimeMark for meeting to UTC zone seconds since epoch"}
{"question": "def _maximize_font_size(font, text, max_size): font_size = max_size fontobj = ImageFont.truetype(font, font_size) text_size = fontobj.getsize(text) while text_size[0] > max_size and font_size > 1: font_size = font_size - 1 fontobj = ImageFont.truetype(font, font_size) text_size = fontobj.getsize(text) return font_size", "answer": "This function Find the biggest font size that will fit."}
