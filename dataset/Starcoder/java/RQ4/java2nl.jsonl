{"question": "public String getFirstName() { return FirstName; }", "answer": "This function Returns the first name of the user"}
{"question": "public boolean isSurfaceValid(SpenTrayBarOptions mOptions, Context context) { if (isValidHeight(mOptions, context) && isValidWidth(mOptions, context)) { return true; } return false; }", "answer": "This function Check if the parameters for surface are valid."}
{"question": "static public int getMaxHeight(Context context) { if (context.getResources().getConfiguration().orientation == Configuration.ORIENTATION_PORTRAIT) { return (int) (Utils.PORTRAIT_Y_FACTOR * context.getResources() .getDisplayMetrics().heightPixels); } else { return (int) (Utils.LANDSCAPE_Y_FACTOR * context.getResources() .getDisplayMetrics().heightPixels); } }", "answer": "This function Get the maximum height of the surface that can be created."}
{"question": "boolean isValidWidth(SpenTrayBarOptions mOptions, Context context) { if (mWidth < mOptions.getMinWidth() || mWidth >= (long) Integer.MAX_VALUE || (mWidth > getMaxWidth(context))) { return false; } return true; }", "answer": "This function Check if the provided width of the surface is valid."}
{"question": "public CommandBuilder setStdoutLineSelector(Function<String, String> selector) { this.stdoutSelector = selector; return this; }", "answer": "This function Set a selector to accumulate lines that are selected from the standard output stream."}
{"question": "public CommandBuilder setTimeout(long timeoutMS) { this.timeoutMS = timeoutMS; return this; }", "answer": "This function Provide an optional timeout for the command (in milliseconds)."}
{"question": "private String toIndentedString(Object o) { if (o == null) { return \"null\"; } return o.toString().replace(\"\\n\", \"\\n \"); }", "answer": "This function Convert the given object to string with each line indented by 4 spaces (except the first line)."}
{"question": "static boolean tryMove(Direction dir) throws GameActionException { return tryMove(dir,20,3); }", "answer": "This function Attempts to move in a given direction, while avoiding small obstacles directly in the path."}
{"question": "public static File getPathRelativeToZimbraHome(String path) { char first = path.charAt(0); if (first == File.separatorChar || first == '/') return new File(path); String home = LC.zimbra_home.value(); return new File(home, path); }", "answer": "This function Returns a File object representing the path relative to the Zimbra home directory."}
{"question": "public StandaloneBMinHash(final ImmutableGraph g, int numSeeds, double threshold, boolean centrality) { this(g, numSeeds, threshold, null, centrality); this.mMinHashNodeIDs = CreateSeeds.genNodes(mNumSeeds, mGraph.numNodes()); }", "answer": "This function Creates a new BooleanMinHasOptimized instance with default values"}
{"question": "static X64Register[] preservedRegisters() { return isMicrosoft ? preservedMicrosoft : preservedSystemV; }", "answer": "This function returns the array of registers whose values must be preserved (not including the stack pointer)"}
{"question": "@ApiModelProperty(value = \"Indicates whether the discount is a fixed amount or percentage, or entered at the time of sale. See [CatalogDiscountType](#type-catalogdiscounttype) for possible values\") public String getDiscountType() { return discountType; }", "answer": "This function Indicates whether the discount is a fixed amount or percentage, or entered at the time of sale."}
{"question": "@ApiModelProperty(value = \"Indicates whether a mobile staff member needs to enter their PIN to apply the discount to a payment in the Square Point of Sale app.\") public Boolean getPinRequired() { return pinRequired; }", "answer": "This function Indicates whether a mobile staff member needs to enter their PIN to apply the discount to a payment in the Square Point of Sale app."}
{"question": "private String toIndentedString(java.lang.Object o) { if (o == null) { return \"null\"; } return o.toString().replace(\"\\n\", \"\\n \"); }", "answer": "This function Convert the given object to string with each line indented by 4 spaces (except the first line)."}
{"question": "@SuppressWarnings({ \"rawtypes\", \"unchecked\" }) public static Set<Map.Entry> crossWith(Object key, Set vals) { Set<Map.Entry> ret = SetRepUtility.emptySet(); Iterator i = vals.iterator(); while (i.hasNext()) { ret.add(new Pair(key, i.next())); } return ret; }", "answer": "This function Form the set of Map.Entry pairs that is the cross product of the given key with the set of values."}
{"question": "public static <T, L> Set<T> map(Fun<L,T> f, Set<L> args) { Set<T> ret = new HashSet<T>(); for (L e : args) { ret.add(f.run(e)); } return ret; }", "answer": "This function Map a computation over a set to produce another set."}
{"question": "protected void paintText(Graphics graphics, AbstractButton button, Rectangle textRect, String text) { Font temp = graphics.getFont(); if (usePlainFont) { Font f = new Font(temp.getName(), Font.PLAIN, temp.getSize()); graphics.setFont(f); } textRect.width=graphics.getFontMetrics().stringWidth(text); super.paintText(graphics, button, textRect, text); paintUnderline(graphics, textRect); graphics.setFont(temp); }", "answer": "This function Paints the given Text with given color"}
{"question": "public NValues(Problem pb, Variable[] scp, Variable[] list) { super(pb, scp); this.list = list; this.fixedVals = new HashSet<>(Variable.setOfvaluesIn(list).size()); this.relevantUnfixedVars = new SetDense(list.length); this.sentinels = new int[list.length]; }", "answer": "This function Builds a constraint NValues for the specified problem, and with the specified scope and list where to count"}
{"question": "TimelineWriteResponse write(String clusterId, String userId, String flowName, String flowVersion, long flowRunId, String appId, TimelineEntities data) throws IOException;", "answer": "This function Stores the entire information in {@link TimelineEntities} to the timeline store."}
{"question": "public TaggedComponent(int a_tag, byte[] a_component_data) { this.tag = a_tag; this.component_data = a_component_data; }", "answer": "This function Create the instance, initialising the fields to the given values."}
{"question": "private final boolean serializeTopicToCTM(final Topic topic, final ICTMWriter buffer) throws SerializerException, IOException { try { /* * generate only for non TMDM types */ writer.getCtmIdentity().getIdentity(writer.getProperties(), topic); TopicSerializer.serialize(writer, constructMatchings.get(topic), topic, buffer); buffer.appendLine(); return true; } catch (NoIdentityException e) { return false; } }", "answer": "This function Internal method to export the given topic to CTM if topic is not a TMDM type."}
{"question": "protected MicrosoftOAuth2Client(@NotNull String clientId, @NotNull String clientSecret, @NotNull String redirectUri) { super(clientId, clientSecret, redirectUri); }", "answer": "This function Construct an instance with given client ID, client secret (associated with the client ID) and redirection URI."}
{"question": "public CallbackResult<ValueType> getPatiently(KeyType key, long maxWaitMillis) { CallbackResult<ValueType> result = getCallback(key); if (result.getError() instanceof LockUnavailableException) { result = getFromCacheOrWait(key, maxWaitMillis); } return result; }", "answer": "This function Attempts to get cached data normally, but if another thread has a refresh lock, wait up to maxWaitMillis for the refresh."}
{"question": "@Override public final ValidationGroup getValidationGroup() { return group; }", "answer": "This function Get this panel's built-in validation group, which drives its display of error messages."}
{"question": "@Override public final void setLayout(LayoutManager mgr) { if (initialized) { throw new IllegalStateException(\"Use setInnerComponent, do not set\" + //NOI18N \" the layout\"); //NOI18N } super.setLayout(mgr); }", "answer": "This function Overridden to disallow setting the layout manager."}
{"question": "public final boolean isFatalProblem() { return problem != null && problem.isFatal(); }", "answer": "This function Determine if there currently is a fatal problem"}
{"question": "private String toIndentedString(java.lang.Object o) { if (o == null) { return \"null\"; } return o.toString().replace(\"\\n\", \"\\n \"); }", "answer": "This function Convert the given object to string with each line indented by 4 spaces (except the first line)."}
{"question": "public void fill( NamedNodeMap list ){ Node node; for( int i=0; i<list.getLength(); i++ ){ node = list.item( i ); String key = node.getNodeName(); if( !ITemplateProperty.Attributes.contains( key )) continue; ITemplateProperty.Attributes attr = ITemplateProperty.Attributes.valueOf( key.toUpperCase() ); String value = node.getTextContent(); super.setAttribute( attr, value ); } }", "answer": "This function Fill the attributes with the given list"}
{"question": "default double distance(Point3DReadOnly other) { return Math.sqrt(distanceSquared(other)); }", "answer": "This function Calculates and returns the distance between this point and {@code other}."}
{"question": "default double distanceSquared(Point3DReadOnly other) { double dx = getX() - other.getX(); double dy = getY() - other.getY(); double dz = getZ() - other.getZ(); return EuclidCoreTools.normSquared(dx, dy, dz); }", "answer": "This function Calculates and returns the square of the distance between this point and {@code other}."}
{"question": "default double distanceXY(Point3DReadOnly other) { return Math.sqrt(distanceXYSquared(other)); }", "answer": "This function Calculates and returns the distance between this point and {@code other} in the XY-plane."}
{"question": "default boolean geometricallyEquals(Point3DReadOnly other, double epsilon) { return distance(other) <= epsilon; }", "answer": "This function Tests if {@code this} and {@code other} represent the same point 3D to an {@code epsilon}."}
{"question": "public double constantValue() throws MathCalculateException{ if(isConstant()) { return calculate(0.0); }else { throw new MathCalculateException(\"This object has no constant value\"); } }", "answer": "This function Gets the constant value of this object in case it is constant"}
{"question": "public static boolean isEmpty(Object[] array) { if (array == null || array.length == 0) { return true; } else { return false; } }", "answer": "This function Returns true if the array is null or 0-length."}
{"question": "public Sheet createSheet(T pojo) { Sheet result = Sheet.createDefault(); populateSheet (result, pojo); return result; }", "answer": "This function Create a Sheet object with all the properties for the passed pojo."}
{"question": "public void populateSheet (Sheet sheet, T pojo) { Sheet.Set set = sheet.get(Sheet.PROPERTIES); for (String nm : propertyNames) { P p = new P(nm, pojo); set.put(p); } sheet.put (set); }", "answer": "This function Populate an existing sheet with properties looked up on the passed bean"}
{"question": "public Sheet createPleaseWaitSheet() { Sheet result = Sheet.createDefault(); Sheet.Set set = result.get(Sheet.PROPERTIES); set.put (new WaitProperty()); return result; }", "answer": "This function Create a Sheet object that shows a single <i>please wait</i> property while loading in the background."}
{"question": "public Property createPleaseWaitProperty() { return new WaitProperty(); }", "answer": "This function Create a property that shows <i>please wait</i> feedback"}
{"question": "protected String filterListToString(NavigableSet<IMatFilter> lCurFilters) { StringBuffer sb = new StringBuffer(); for (IMatFilter bfCur : lCurFilters) sb.append(bfCur.toString()).append(\",\"); return sb.toString(); }", "answer": "This function Creates a string representation of a list of IBitmapFilters"}
{"question": "public String nextSingleFilter() { if (!liCurFilter.hasNext()) { // We reset the filter iterator liCurFilter = lFilters.listIterator(); } IMatFilter ibNext = liCurFilter.next(); nsCurFilters.clear(); nsCurFilters.add(ibNext); return filterListToString(nsCurFilters); }", "answer": "This function selects the next sub filter, but without generating permutations of filters."}
{"question": "public List<Object> getInterchangeNodeAndInterchangeLink() { if (interchangeNodeAndInterchangeLink == null) { interchangeNodeAndInterchangeLink = new ArrayList<Object>(); } return this.interchangeNodeAndInterchangeLink; }", "answer": "This function Gets the value of the interchangeNodeAndInterchangeLink property."}
{"question": "public boolean writeLargeFile(String filePath, long position, String data) { try { // Create file FileWriter fstream = new FileWriter(filePath); BufferedWriter out = new BufferedWriter(fstream); out.write(data); // Close the output stream out.close(); return true; } catch (Exception e) { e.printStackTrace(); } return false; }", "answer": "This function Write in a file from the beginning of file."}
{"question": "@Override public void addSelectedMember(Member member) { addPlayerToTeam(member); }", "answer": "This function Adds the Member, member, to the current fragment's team of players."}
{"question": "@Override public void removeSelectedMember(Member member) { removePlayerFromTeam(member); }", "answer": "This function Removes the Member, member, from the current fragment's team of players."}
{"question": "private ArrayAdapter<Integer> createPositionSpinnerAdapter() { List<Integer> positionList = new ArrayList<Integer>(); for (int i = 1; i <= noOfTeams; i++) { positionList.add(i); } ArrayAdapter<Integer> positionsAdapter = new ArrayAdapter<Integer>(getContext(), android.R.layout.simple_spinner_item, positionList); return positionsAdapter; }", "answer": "This function Creates a list of integers representing the finishing positions teams can take in the game record being created."}
{"question": "private Puzzle(Puzzle source) { this.nbAssignedValues = source.nbAssignedValues; for (int i = 0; i < SIZE; i++) { for (int j = 0; j < SIZE; j++) { for (int k = 0; k < SIZE; k++) { if (source.options[i][j][k]) this.options[i][j][k] = true; } if (source.values[i][j] != 0) this.values[i][j] = source.values[i][j]; } } }", "answer": "This function Use this copy constructor to copy values and options to create search branches"}
{"question": "private boolean assignAll() { for (int i = 0; i < SIZE * SIZE; i++) { if (initValues[i] > 0) if (!assignOne(i / SIZE, i % SIZE, initValues[i])) return false; } return true; }", "answer": "This function Assign all values in initValues which is: values in initial input for the root branch, or the asserted value for a search branch."}
{"question": "public int[][] getValues() { if (nbAssignedValues == SIZE * SIZE) return values; return null; }", "answer": "This function Get the values when puzzle solved (solve() returns true)."}
{"question": "public boolean isLayoutVisible() { return VISIBLE == findViewById(R.id.keyboard_layout_id).getVisibility(); }", "answer": "This function judge whether keyboard layout is show"}
{"question": "public void popKeyboard() { showLayout(); openSoftKeyboard(mEtInputFrame); showAutoView(); }", "answer": "This function pop soft keyboard, if the layout is hidden, it will show layout first"}
{"question": "default LTable<K, V> filter(SPredicate<Pair<K, V>> predicate) { return parallelDo(ctx -> { if (predicate.test(ctx.element())) ctx.emit(ctx.element());}, pType()); }", "answer": "This function Filter the rows of the table using the supplied predicate."}
{"question": "default <T> LTable<T, V> mapKeys(SFunction<K, T> fn, PType<T> pType) { return parallelDo( ctx -> ctx.emit(Pair.of(fn.apply(ctx.element().first()), ctx.element().second())), ptf().tableOf(pType, valueType())); }", "answer": "This function Transform the keys of this table using the given function"}
{"question": "default LTable<K, V> filterByValue(SPredicate<V> predicate) { return parallelDo(ctx -> { if (predicate.test(ctx.element().second())) ctx.emit(ctx.element());}, pType()); }", "answer": "This function Filter the rows of the table using the supplied predicate applied to the value part of each record."}
{"question": "default <U> LTable<K, Pair<V, U>> join(LTable<K, U> other, JoinType joinType, JoinStrategy<K, V, U> joinStrategy) { return factory().wrap(joinStrategy.join(underlying(), other.underlying(), joinType)); }", "answer": "This function Join this table to another {@link LTable} which has the same key type using the provided {@link JoinType} and {@link JoinStrategy}"}
{"question": "public static boolean isJavadocComment(String commentContent) { boolean result = false; if (!commentContent.isEmpty()) { final char docCommentIdentifier = commentContent.charAt(0); result = docCommentIdentifier == '*'; } return result; }", "answer": "This function Checks that commentContent starts with '*' javadoc comment identifier."}
{"question": "public static DetailNode findFirstToken(DetailNode detailNode, int type) { DetailNode returnValue = null; DetailNode node = getFirstChild(detailNode); while (node != null) { if (node.getType() == type) { returnValue = node; break; } node = getNextSibling(node); } return returnValue; }", "answer": "This function Returns the first child token that has a specified type."}
{"question": "public static DetailNode getPreviousSibling(DetailNode node) { DetailNode previousSibling = null; final int previousSiblingIndex = node.getIndex() - 1; if (previousSiblingIndex >= 0) { final DetailNode parent = node.getParent(); final DetailNode[] children = parent.getChildren(); previousSibling = children[previousSiblingIndex]; } return previousSibling; }", "answer": "This function Gets previous sibling of specified node."}
{"question": "public static String getTokenName(int id) { final String name; if (id == JavadocTokenTypes.EOF) { name = \"EOF\"; } else if (id > TOKEN_VALUE_TO_NAME.length - 1) { throw new IllegalArgumentException(UNKNOWN_JAVADOC_TOKEN_ID_EXCEPTION_MESSAGE + id); } else { name = TOKEN_VALUE_TO_NAME[id]; if (name == null) { throw new IllegalArgumentException(UNKNOWN_JAVADOC_TOKEN_ID_EXCEPTION_MESSAGE + id); } } return name; }", "answer": "This function Returns the name of a token for a given ID."}
{"question": "public static String escapeAllControlChars(String text) { final String textWithoutNewlines = NEWLINE.matcher(text).replaceAll(\"\\\\\\\\n\"); final String textWithoutReturns = RETURN.matcher(textWithoutNewlines).replaceAll(\"\\\\\\\\r\"); return TAB.matcher(textWithoutReturns).replaceAll(\"\\\\\\\\t\"); }", "answer": "This function Replace all control chars with escaped symbols."}
{"question": "public void applyChangesToModel(Model destinationModel) { Iterator<Flow> iterator = model.flowIterator(); while (iterator.hasNext()) { destinationModel.updateControlPointAndShortening(iterator.next()); } }", "answer": "This function Apply new control point locations to a model."}
{"question": "private double computeSpringConstant(Flow flow, double maxFlowLength) { double flowBaseLength = flow.getBaselineLength(); double relativeFlowLength = flowBaseLength / maxFlowLength; double flowSpringConstant = (-model.getMinFlowLengthSpringConstant() + model.getMaxFlowLengthSpringConstant()) * relativeFlowLength + model.getMinFlowLengthSpringConstant(); return flowSpringConstant; }", "answer": "This function Calculates the stiffness of the spring based on the distance between the start and end nodes."}
{"question": "private Force computeAntiTorsionForce(Flow flow) { Point basePt = flow.getBaseLineMidPoint(); double dx = basePt.x - flow.cPtX(); double dy = basePt.y - flow.cPtY(); double l = Math.sqrt(dx * dx + dy * dy); double alpha = FastMath.atan2(dy, dx); double baseLineAzimuth = flow.getBaselineOrientation(); double diffToBaseNormal = Math.PI / 2 - baseLineAzimuth + alpha; double torsionF = FastMath.sin(diffToBaseNormal) * l; double antiTorsionW = model.getAntiTorsionWeight(); double torsionFx = FastMath.cos(baseLineAzimuth) * torsionF * antiTorsionW; double torsionFy = FastMath.sin(baseLineAzimuth) * torsionF * antiTorsionW; return new Force(torsionFx, torsionFy); }", "answer": "This function Computes the anti-torsion force for a quadratic BÃ©zier flow."}
{"question": "private double angularW(double angleDiff) { //FIXME hard-coded parameter final double K = 4; double w = FastMath.exp(-K * angleDiff * angleDiff); return angleDiff < 0 ? -w : w; }", "answer": "This function Convert an angular difference to an angular force."}
{"question": "private boolean flowIntersectsObstacles(Flow flow, List<Obstacle> obstacles, int minObstacleDistPx) { for (Obstacle obstacle : obstacles) { if (flow.isOverlappingObstacle(obstacle, model, minObstacleDistPx)) { return true; } } return false; }", "answer": "This function Tests whether a flow overlaps any obstacle."}
{"question": "public int countIntersectingObstacles(Flow flow, List<Obstacle> obstacles, int minObstacleDistPx) { return (int) Math.round(intersectionIndex(flow, obstacles, minObstacleDistPx, 1d)); }", "answer": "This function Returns the number of overlaps between a flow and a list of obstacles."}
{"question": "public double intersectionIndex(Flow flow, List<Obstacle> obstacles, int minObstacleDistPx, double arrowheadWeight) { double nbrIntersections = 0; for (Obstacle obstacle : obstacles) { if (flow.isOverlappingObstacle(obstacle, model, minObstacleDistPx)) { if (obstacle.isArrowObstacle()) { nbrIntersections += arrowheadWeight; } else { ++nbrIntersections; } } } return nbrIntersections; }", "answer": "This function Computes an index quantifying the number of intersections of a flow with obstacles."}
{"question": "public ArrayList<Flow> getFlowsOverlappingObstacles() { model.invalidateCachedValues(); List<Obstacle> obstacles = getObstaclesFromCachedCurves(model); return getFlowsOverlappingObstacles(obstacles); }", "answer": "This function Returns a list of all flows that intersect obstacles."}
{"question": "private boolean findControlPointWithoutOverlapsInsideRangeBoxWithFlexibleMinDistance(Flow flow, List<Obstacle> obstacles) { // int minObstacleDistPx = model.getMinObstacleDistPx(); while (true) { boolean foundPosition = findControlPointWithoutOverlapsInsideRangeBox( flow, obstacles, minObstacleDistPx); if (foundPosition) { return true; } if (minObstacleDistPx == 0) { return false; } // half minimum distance between flow and obstacles minObstacleDistPx /= 2; } }", "answer": "This function Searches for position inside range box such that the flow does overlap a any obstacles."}
{"question": "public void symmetrizeFlows() { // nodes and arrowheads are obstacles List<Obstacle> obstacles = getObstaclesFromCachedCurves(model); RangeboxEnforcer rangeboxEnforcer = new RangeboxEnforcer(model); Iterator<Flow> flowIterator = model.flowIterator(); while (flowIterator.hasNext()) { Flow flow = flowIterator.next(); if (flow.isLocked()) { continue; } symmetrizeFlow(flow, obstacles, rangeboxEnforcer); } }", "answer": "This function Makes skewed flows more symmetric and makes flows with long arrowheads more straight."}
{"question": "private static HashMap<String, Object> createDefaultConfigMap() { HashMap<String, Object> map = new HashMap<>(); map.put(SPAWN_ATTEMPT_CHANCE_PER_TICK, SPAWN_ATTEMPT_CHANCE_PER_TICK_DEFAULT); map.put(SPAWN_MIN_AMOUNT_PER_SUCCESSFUL_ATTEMPT, SPAWN_MIN_AMOUNT_PER_SUCCESSFUL_ATTEMPT_DEFAULT); map.put(SPAWN_MAX_AMOUNT_PER_SUCCESSFUL_ATTEMPT, SPAWN_MAX_AMOUNT_PER_SUCCESSFUL_ATTEMPT_DEFAULT); return map; }", "answer": "This function Create config hashmap initialised with default values"}
{"question": "public void setConfigDefaults() { for (String val : mConfigMap.keySet()) { mConfig.addDefault(val, mConfigMap.get(val)); } }", "answer": "This function Set default configuration values if they don't exist yet"}
{"question": "public void retrieveConfigFromFile() { for (String val : mConfigMap.keySet()) { mConfigMap.put(val, mConfig.get(val)); } }", "answer": "This function Get configuration values from config file and put it into the config map"}
{"question": "public Object getConfigValue(String param) { if (!mConfigMap.containsKey(param)) { throw new IndexOutOfBoundsException(\"Parameter \" + param + \" does not exist in config\"); } return mConfigMap.get(param); }", "answer": "This function Retrieve value of config param if parameter exists."}
{"question": "public Noun clone(LanguageGender genderOverride, LanguageStartsWith startsWithOverride, Map<? extends NounForm,String> valueOverrides) { Noun n = clone(); if (genderOverride != null ) n.setGender(genderOverride); if (valueOverrides != null) { for (Map.Entry<? extends NounForm,String> entry : valueOverrides.entrySet()) { n.setString(intern(entry.getValue()), entry.getKey()); } } //needs to happen after setString which sets startswith in Greek based on Plosive which breaks testRenameTabPositiveCasesEndUser //because it sets startsWith = specialcase without setting the string to begin with a Plosive if (startsWithOverride != null) n.setStartsWith(startsWithOverride); return n; }", "answer": "This function Make a clone of the given noun, overwriting the given values with the provided overrides"}
{"question": "public static void copy(File file, OutputStream out) throws IOException { byte[] buffer = new byte[4096]; FileInputStream in = new FileInputStream(file); try { int read; while ((read = in.read(buffer)) >= 0) out.write(buffer, 0, read); } finally { in.close(); } }", "answer": "This function Copies file to given output stream."}
{"question": "public static void makeDirectory(File directory) { if (!directory.exists()) { if (!directory.mkdirs()) { throw new IllegalStateException(\"Error creating \" + directory + \".\"); } } else { if (!directory.isDirectory()) { throw new IllegalArgumentException(\"File \" + directory + \" is not a directory\"); } } }", "answer": "This function Create the indicated directory, if it doesn't already exist."}
{"question": "public static File build(File baseFile, String... parts) { File file = baseFile; for (String part : parts) file = new File(file, part); return file; }", "answer": "This function Build a File object from the given parts, appending each path part to the preceding part."}
{"question": "public static boolean delete(File file) { if (file == null) { throw new IllegalArgumentException(\"Cannot delete a null file.\"); } return !file.exists() || file.delete(); }", "answer": "This function Delete the given file, returning <code>true</code> if the file is gone (that is, if the delete succeeds, or was never there in the first place)."}
{"question": "public static void sync(File directory) throws IOException { Native.sync(directory.getPath()); }", "answer": "This function Ensures changes to the given directory have been written to storage."}
{"question": "CSVValue addValue(String column, String value) { CSVValue v = new CSVValue(); v.setValue(value); columns.put(column, new SimpleObjectProperty<>(v)); return v; }", "answer": "This function stores the given value in the given column of this row"}
{"question": "protected static void reportError(final ErrorData errorData) { final StringBuilder errorDataBuilder = new StringBuilder(); errorDataBuilder.append(errorData.getErrorType().name()).append(\": \").append(errorData.getErrorValue()).append(System.lineSeparator()); LOG.error(\"An error was returned: \" + errorDataBuilder.toString()); }", "answer": "This function Print (to the console) the provided {@link ErrorData}s."}
{"question": "public void recover(final MessageRecoveryListener listener) throws Exception { for(Iterator iter=messageContainer.values().iterator();iter.hasNext();){ RapidMessageReference messageReference=(RapidMessageReference) iter.next(); Message m = (Message) peristenceAdapter.readCommand(messageReference.getLocation()); listener.recoverMessage(m); } listener.finished(); }", "answer": "This function Replays the checkpointStore first as those messages are the oldest ones, then messages are replayed from the transaction log and then the cache is updated."}
{"question": "private void populateEnemyMap() { int numDestroyer = this.getFleet().getNumDestroyerLeft(); int numCruiser = this.getFleet().getNumCruiserLeft(); logger.info(String.format(\"~~~~~~~~~~~~~~~~~~++++++++this.getFleet().getNumDestroyerLeft(): \" + numDestroyer)); logger.info(String.format(\"~~~~~~~~~~~~~~~~~~++++++++this.getFleet().getNumCruiserLeft(): \" + numCruiser)); placeAirCraftCarrier(); placeMultipleDestroyerAndCruiser(numDestroyer, \"Destroyer\", 3); placeMultipleDestroyerAndCruiser(numCruiser, \"Cruiser\", 2); }", "answer": "This function initialises the enemy mapGrid with its own ships randomly is part of enemy constructor"}
{"question": "private ArrayList<Battleship> generateBattleships (int numShips, String battleshipType, int shipSize) { ArrayList<Battleship> preppedFleet = new ArrayList<>(); for (int i = 1; i <= numShips; i++) { Name currentBattleshipName = new Name(\"enemy\" + battleshipType + i); Battleship currentBattleship = new Battleship(currentBattleshipName, shipSize, shipSize); preppedFleet.add(currentBattleship); } logger.info(String.format(\"++++++++GENERATED: \" + preppedFleet.toString())); return preppedFleet; }", "answer": "This function creates list of a certain battleship type to be put on map"}
{"question": "private Orientation generateOrientation() { int seed = randGen2.nextInt(); int decision = seed % 2; if (decision == 0) { return new Orientation(\"horizontal\"); } else { return new Orientation(\"vertical\"); } }", "answer": "This function randomly generates either a horizontal or vertical orientation"}
{"question": "private void addCardinal(Coordinates updatedCoord) { if (isValidCardinal(updatedCoord)) { watchlist.push(updatedCoord); modeCleanup(updatedCoord); } }", "answer": "This function Adds the North South East West coordinates into the watchlist, if valid"}
{"question": "private boolean isValidCardinal(Coordinates useCoord) { if (!this.getTargetHistory().contains(useCoord)) { //logger.info(String.format(\"++++++++CHECKING ISVALID(): \" + useCoord.toString())); //logger.info(String.format(\"++++++++allPossibleTargets: \" + allPossibleTargets.toString())); //logger.info(String.format(\"++++++++allParityTargets: \" + allParityTargets.toString())); return allPossibleTargets.contains(useCoord) || allParityTargets.contains(useCoord); //return true } else { return false; } }", "answer": "This function Checks that the cardinal coordinate has never been hit before"}
{"question": "private void modeCleanup(Coordinates usedCoord) { // logger.info(String.format(\"++++++++BEFORE allParityTargets: \" + allParityTargets.toString())); allParityTargets.remove(usedCoord); // logger.info(String.format(\"++++++++AFTER allParityTargets: \" + allParityTargets.toString())); // logger.info(String.format(\"++++++++BEFORE allPossibleTargets: \" + allPossibleTargets.toString())); allPossibleTargets.remove(usedCoord); // logger.info(String.format(\"++++++++AFTER allPossibleTargets: \" + allPossibleTargets.toString())); lastCoordAttacked = usedCoord; }", "answer": "This function Remove the last used coord from allParityTargets and allPossibleTargets"}
{"question": "public static FileOutputStream writeBytes(int[] data, String filename) throws IOException { FileOutputStream out = new FileOutputStream(filename, false); writeBytes(data, out); return out; }", "answer": "This function Writes data from the integer array to disk as raw bytes, overwriting the old file if present."}
{"question": "static public String dirname(String fileName) { if (fileName.indexOf(File.separator) != -1) return fileName.substring(0, fileName.lastIndexOf(File.separator)); return \".\"; }", "answer": "This function Returns the base directory of the file."}
{"question": "@DispatchMode public final int getDispatchMode() { return mDispatchMode; }", "answer": "This function Retrieves the dispatch mode of this listener."}
{"question": "@NonNull static WindowInsets forwardToViewIfNeeded(@NonNull View v, @NonNull WindowInsets insets) { // If the app set an on apply window listener, it will be called after this // and will decide whether to call the view's onApplyWindowInsets. if (v.getTag(R.id.tag_on_apply_window_listener) != null) { return insets; } return v.onApplyWindowInsets(insets); }", "answer": "This function Forward the call to view.onApplyWindowInsets if there is no other listener attached to the view."}
{"question": "public void write(File file, ClassSummaries summary) throws IOException, XMLStreamException { for (String className : summary.getClasses()) { String fileName = file.getAbsolutePath() + File.separatorChar + className + \".xml\"; write(new File(fileName), summary.getClassSummaries(className)); } }", "answer": "This function Writes the given class summaries into files, one per class"}
{"question": "@SuppressWarnings(\"unchecked\") public static <T> Optional<T> empty() { return (Optional<T>) EMPTY; }", "answer": "This function Returns an empty optional instance."}
{"question": "private Optional(T value) { if (value == null) { throw new IllegalArgumentException(\"Value cannot be null.\"); } this.value = value; }", "answer": "This function Creates the optional with the specified non-null value."}
{"question": "public T get() { if (value == null) { throw new NoSuchElementException(\"No value present.\"); } return value; }", "answer": "This function Returns the value of this optional."}
{"question": "public String sendAsyncCommand( Channel channel, final String command ) { /* * Send synchronously to get the Job-UUID to return, the results of the actual * job request will be returned by the server as an async event. */ EslMessage response = sendSyncSingleLineCommand( channel, command ); if ( response.hasHeader( Name.JOB_UUID ) ) { return response.getHeaderValue( Name.JOB_UUID ); } else { throw new IllegalStateException( \"Missing Job-UUID header in bgapi response\" ); } }", "answer": "This function Returns the Job UUID of that the response event will have."}
{"question": "@Test public void getSubjectCommonName() { X509Certificate cert = TestCertUtil.getProducer().certChain[0]; String commonName = CertHelper.getSubjectCommonName(cert); assertEquals(\"producer\", commonName); }", "answer": "This function Tests that the name extractor returns correct name from certificate."}
{"question": "public void sendMessageDelayed(int what, long delayMillis) { // mSmHandler can be null if the state machine has quit. SmHandler smh = mSmHandler; if (smh == null) return; smh.sendMessageDelayed(obtainMessage(what), delayMillis); }", "answer": "This function Enqueue a message to this state machine after a delay."}
{"question": "protected final boolean hasMessages(int what) { SmHandler smh = mSmHandler; if (smh == null) return false; return smh.hasMessages(what); }", "answer": "This function Check if there are any pending posts of messages with code 'what' in the message queue."}
