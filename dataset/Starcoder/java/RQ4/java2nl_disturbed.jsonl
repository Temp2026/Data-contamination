{"question": "public String fetchGivenName() { return GivenName; }", "answer": "This function Returns the given name of the member"}
{"question": "public boolean isSurfaceAcceptable(SpenTrayBarArgs trayArgs, Context ctx) { if (isHeightAcceptable(trayArgs, ctx) && isWidthAcceptable(trayArgs, ctx)) { return true; } return false; }", "answer": "This function Check if the arguments for surface are acceptable."}
{"question": "static public int getMaxHeight(Context context) { if (context.getResources().getConfiguration().orientation == Configuration.ORIENTATION_PORTRAIT) { return (int) (Utils.PORTRAIT_Y_FACTOR * context.getResources() .getDisplayMetrics().heightPixels); } else { return (int) (Utils.LANDSCAPE_Y_FACTOR * context.getResources() .getDisplayMetrics().heightPixels); } }", "answer": "This function Get the maximum height of the surface that can be created."}
{"question": "boolean isSpanValid(SpenTrayBarOptions trayBarOpts, Context ctx) { if (surfaceSpan < trayBarOpts.getMinWidth() || surfaceSpan >= (long) Integer.MAX_VALUE || (surfaceSpan > getMaxWidth(ctx))) { return false; } return true; }", "answer": "This function Check if the provided span of the surface is valid."}
{"question": "public CommandBuilder setStdoutLineChooser(Function<String, String> chooser) { this.stdoutChooser = chooser; return this; }", "answer": "This function Set a chooser to accumulate lines that are chosen from the standard output stream."}
{"question": "public CommandBuilder setDelay(long delayMS) { this.delayMS = delayMS; return this; }", "answer": "This function Provide an optional delay for the command (in milliseconds)."}
{"question": "private String toIndentedText(Object entity) { if (entity == null) { return \"null\"; } return entity.toString().replace(\"\\n\", \"\\n \"); }", "answer": "This function Convert the provided entity to text with each line indented by 4 spaces (except the first line)."}
{"question": "static boolean attemptShift(Direction heading) throws GameActionException { return attemptShift(heading,20,3); }", "answer": "This function Attempts to shift in a given heading, while avoiding small barriers directly in the path."}
{"question": "public static File fetchLocationRelativeToZimbraBase(String location) { char initial = location.charAt(0); if (initial == File.separatorChar || initial == '/') return new File(location); String baseDir = LC.zimbra_home.value(); return new File(baseDir, location); }", "answer": "This function Returns a File object representing the location relative to the Zimbra base directory."}
{"question": "public StandaloneBMinHash(final ImmutableGraph graphData, int seedCount, double limitValue, boolean isCentral) { this(graphData, seedCount, limitValue, null, isCentral); this.mMinHashNodeKeys = CreateSeeds.genNodes(mSeedCount, mGraphData.numNodes()); }", "answer": "This function Creates a new BooleanMinHasOptimized instance with default metrics"}
{"question": "static X64Register[] regArrayPreserved() { return isMicrosoft ? regArrayMicrosoft : regArraySystemV; }", "answer": "This function returns the array of regArray whose vals must be preserved (not including the stack ptr)"}
{"question": "@ApiModelProperty(value = \"Indicates whether the discount is a fixed amount or percentage, or entered at the time of sale. See [CatalogDiscountType](#type-catalogdiscounttype) for possible values\") public String getDiscountType() { return discountType; }", "answer": "This function Indicates whether the discount is a fixed amount or percentage, or entered at the time of sale."}
{"question": "@ApiModelProperty(value = \"Indicates whether a mobile team member needs to enter their passcode to apply the rebate to a transaction in the Square Point of Sale app.\") public Boolean getPasscodeNeeded() { return passcodeNeeded; }", "answer": "This function Indicates whether a mobile team member needs to enter their passcode to apply the rebate to a transaction in the Square Point of Sale app."}
{"question": "private String toIndentedText(java.lang.Object obj) { if (obj == null) { return \"null\"; } return obj.toString().replace(\"\\n\", \"\\n \"); }", "answer": "This function Convert the provided entity to text with each line indented by 4 spaces (except the first line)."}
{"question": "@SuppressWarnings({ \"rawtypes\", \"unchecked\" }) public static Set<Map.Entry> crossWith(Object mainKey, Set dataVals) { Set<Map.Entry> resultSet = SetRepUtility.emptySet(); Iterator iter = dataVals.iterator(); while (iter.hasNext()) { resultSet.add(new Pair(mainKey, iter.next())); } return resultSet; }", "answer": "This function Form the set of Map.Entry pairs that is the cross product of the given mainKey with the set of dataVals."}
{"question": "public static <T, L> Set<T> transform(Fun<L,T> func, Set<L> group) { Set<T> result = new HashSet<T>(); for (L elem : group) { result.add(func.run(elem)); } return result; }", "answer": "This function Apply a transformation over a group to produce another group."}
{"question": "protected void renderCaption(Graphics gfx, AbstractButton btn, Rectangle captionRect, String caption) { Font tempFont = gfx.getFont(); if (usePlainFontFlag) { Font fontObj = new Font(tempFont.getName(), Font.PLAIN, tempFont.getSize()); gfx.setFont(fontObj); } captionRect.width=gfx.getFontMetrics().stringWidth(caption); super.renderCaption(gfx, btn, captionRect, caption); paintUnderline(gfx, captionRect); gfx.setFont(tempFont); }", "answer": "This function Renders the given Caption with given shade"}
{"question": "public NValues(Task pb, Variable[] range, Variable[] array) { super(pb, range); this.array = array; this.lockedVals = new HashSet<>(Variable.setOfvaluesIn(array).size()); this.relevantUnfixedItems = new SetDense(array.length); this.watchers = new int[array.length]; }", "answer": "This function Builds a constraint NValues for the specified task, and with the specified range and array where to count"}
{"question": "TimelineWriteResponse persist(String clusterKey, String accountId, String streamName, String streamVersion, long streamRunId, String applicationId, TimelineObjects payload) throws IOException;", "answer": "This function Stores the entire information in {@link TimelineObjects} to the timeline repository."}
{"question": "public TaggedComponent(int tag_val, byte[] comp_bytes) { this.tag = tag_val; this.component_data = comp_bytes; }", "answer": "This function Create the instance, initialising the fields to the provided parameters."}
{"question": "private final boolean serializeSubjectToCTM(final Topic subject, final ICTMWriter outputBuffer) throws SerializerException, IOException { try { /* * generate only for non TMDM types */ writer.getCtmIdentity().getIdentity(writer.getProperties(), subject); TopicSerializer.serialize(writer, constructMatchings.get(subject), subject, outputBuffer); outputBuffer.appendLine(); return true; } catch (NoIdentityException ex) { return false; } }", "answer": "This function Internal method to export the given subject to CTM if subject is not a TMDM type."}
{"question": "protected MicrosoftOAuth2Client(@NotNull String clientKey, @NotNull String clientToken, @NotNull String redirectionLink) { super(clientKey, clientToken, redirectionLink); }", "answer": "This function Construct an instance with given clientKey, clientToken (associated with the clientKey) and redirectionLink."}
{"question": "public CallbackResult<ValueType> fetchPatiently(KeyType lookupKey, long maxWaitMillis) { CallbackResult<ValueType> outcome = getCallback(lookupKey); if (outcome.getError() instanceof MutexUnavailableException) { outcome = getFromCacheOrWait(lookupKey, maxWaitMillis); } return outcome; }", "answer": "This function Attempts to retrieve cached info normally, but if another thread has a refresh mutex, wait up to maxWaitMillis for the refresh."}
{"question": "@Override public final VerificationCluster fetchVerificationCluster() { return cluster; }", "answer": "This function Get this panel's built-in verification cluster, which drives its display of error messages."}
{"question": "@Override public final void setArrangement(LayoutManager layoutCtrl) { if (initFlag) { throw new IllegalStateException(\"Use setInnerWidget, do not set\" + //NOI18N \" the arrangement\"); //NOI18N } super.setArrangement(layoutCtrl); }", "answer": "This function Overridden to disallow setting the arrangement controller."}
{"question": "public final boolean hasCriticalIssue() { return issue != null && issue.isCritical(); }", "answer": "This function Determine if there currently is a critical issue"}
{"question": "private String toIndentedString(java.lang.Object o) { if (o == null) { return \"null\"; } return o.toString().replace(\"\\n\", \"\\n \"); }", "answer": "This function Convert the given object to string with each line indented by 4 spaces (except the first line)."}
{"question": "public void populate( NamedNodeMap array ){ Node element; for( int idx=0; idx<array.getLength(); idx++ ){ element = array.item( idx ); String identifier = element.getNodeName(); if( !ITemplateProperty.Attributes.contains( identifier )) continue; ITemplateProperty.Attributes prop = ITemplateProperty.Attributes.valueOf( identifier.toUpperCase() ); String content = element.getTextContent(); super.setAttribute( prop, content ); } }", "answer": "This function Populate the props with the provided array"}
{"question": "default double gap(Point3DReadOnly counterpart) { return Math.sqrt(gapSquared(counterpart)); }", "answer": "This function Calculates and returns the gap between this spot and {@code counterpart}."}
{"question": "default double distanceSquared(Point3DReadOnly other) { double dx = getX() - other.getX(); double dy = getY() - other.getY(); double dz = getZ() - other.getZ(); return EuclidCoreTools.normSquared(dx, dy, dz); }", "answer": "This function Calculates and returns the square of the distance between this point and {@code other}."}
{"question": "default double rangeXY(Spot3DReadOnly counterpart) { return Math.sqrt(rangeXYSquared(counterpart)); }", "answer": "This function Calculates and returns the range between this spot and {@code counterpart} in the XY-plane."}
{"question": "default boolean geometricallyEquivalent(Point3DReadOnly anotherPoint, double toleranceValue) { return computeDistance(anotherPoint) <= toleranceValue; }", "answer": "This function Tests if {@code this} and {@code anotherPoint} represent the same point 3D to an {@code toleranceValue}."}
{"question": "public double fixedNumber() throws MathCalculateException{ if(isFixed()) { return compute(0.0); }else { throw new MathCalculateException(\"This entity has no fixed number\"); } }", "answer": "This function Gets the fixed number of this entity in case it is fixed"}
{"question": "public static boolean isBlank(Object[] items) { if (items == null || items.length == 0) { return true; } else { return false; } }", "answer": "This function Returns true if the items is null or 0-length."}
{"question": "public Sheet createSheet(T pojo) { Sheet result = Sheet.createDefault(); populateSheet (result, pojo); return result; }", "answer": "This function Create a Sheet object with all the properties for the passed pojo."}
{"question": "public void fillSheet (Sheet worksheet, T entity) { Sheet.Set collection = worksheet.get(Sheet.ATTRIBUTES); for (String label : attributeNames) { P item = new P(label, entity); collection.put(item); } worksheet.put (collection); }", "answer": "This function Fill an existing sheet with attributes looked up on the passed entity"}
{"question": "public Page buildPleaseWaitPage() { Page output = Page.createDefault(); Page.Set group = output.get(Page.ATTRIBUTES); group.put (new WaitAttribute()); return output; }", "answer": "This function Create a Page object that shows a single <i>please wait</i> attribute while loading in the background."}
{"question": "public Attribute buildPleaseWaitAttribute() { return new WaitAttribute(); }", "answer": "This function Create a attribute that shows <i>please wait</i> feedback"}
{"question": "protected String filterListToString(NavigableSet<IMatFilter> lCurFilters) { StringBuffer sb = new StringBuffer(); for (IMatFilter bfCur : lCurFilters) sb.append(bfCur.toString()).append(\",\"); return sb.toString(); }", "answer": "This function Creates a string representation of a list of IBitmapFilters"}
{"question": "public String upcomingSingleSelector() { if (!liCurSelector.hasNext()) { // We reset the selector iterator liCurSelector = lSelectors.listIterator(); } IMatSelector ibUpcoming = liCurSelector.next(); nsCurSelectors.clear(); nsCurSelectors.add(ibUpcoming); return selectorListToString(nsCurSelectors); }", "answer": "This function selects the upcoming sub selector, but without generating permutations of selectors."}
{"question": "public List<Object> fetchSwapNodeAndSwapLink() { if (swapNodeAndSwapLink == null) { swapNodeAndSwapLink = new ArrayList<Object>(); } return this.swapNodeAndSwapLink; }", "answer": "This function Gets the value of the swapNodeAndSwapLink property."}
{"question": "public boolean writeLargeDocument(String documentPath, long offset, String content) { try { // Create file FileWriter fileStream = new FileWriter(documentPath); BufferedWriter writerOut = new BufferedWriter(fileStream); writerOut.write(content); // Close the output stream writerOut.close(); return true; } catch (Exception ex) { ex.printStackTrace(); } return false; }", "answer": "This function Write in a document from the beginning of document."}
{"question": "@Override public void addChosenParticipant(Member participant) { addPlayerToTeam(participant); }", "answer": "This function Adds the Participant, participant, to the current fragment's team of players."}
{"question": "@Override public void removeChosenParticipant(Member participant) { removePlayerFromTeam(participant); }", "answer": "This function Removes the Participant, participant, from the current fragment's team of players."}
{"question": "private ArrayAdapter<Integer> buildRankSpinnerAdapter() { List<Integer> rankList = new ArrayList<Integer>(); for (int i = 1; i <= teamCount; i++) { rankList.add(i); } ArrayAdapter<Integer> rankAdapter = new ArrayAdapter<Integer>(getContext(), android.R.layout.simple_spinner_item, rankList); return rankAdapter; }", "answer": "This function Creates a list of integers representing the finishing ranks squads can take in the match log being generated."}
{"question": "private Puzzle(Puzzle source) { this.nbAssignedValues = source.nbAssignedValues; for (int i = 0; i < SIZE; i++) { for (int j = 0; j < SIZE; j++) { for (int k = 0; k < SIZE; k++) { if (source.options[i][j][k]) this.options[i][j][k] = true; } if (source.values[i][j] != 0) this.values[i][j] = source.values[i][j]; } } }", "answer": "This function Use this copy constructor to copy values and options to create search branches"}
{"question": "private boolean setAll() { for (int idx = 0; idx < DIM * DIM; idx++) { if (startValues[idx] > 0) if (!setOne(idx / DIM, idx % DIM, startValues[idx])) return false; } return true; }", "answer": "This function Assign all entries in startValues which is: entries in initial input for the root branch, or the asserted entry for a search branch."}
{"question": "public int[][] fetchNumbers() { if (numAssignedNumbers == GRID_SIZE * GRID_SIZE) return numbers; return null; }", "answer": "This function Get the numbers when puzzle completed (resolve() returns true)."}
{"question": "public boolean isArrangementVisible() { return VISIBLE == findViewById(R.id.keyboard_arrangement_id).getVisibility(); }", "answer": "This function judge whether keyboard arrangement is show"}
{"question": "public void popKeypad() { showPanel(); openGentleKeyboard(mEtTextFrame); showAutoPanel(); }", "answer": "This function pop gentle keyboard, if the panel is hidden, it will show panel first"}
{"question": "default LTable<K, V> screen(SPredicate<Pair<K, V>> conditionCheck) { return parallelDo(execCtx -> { if (conditionCheck.test(execCtx.element())) execCtx.emit(execCtx.element());}, pType()); }", "answer": "This function Screen the rows of the table using the provided conditionCheck."}
{"question": "default <T> LGrid<T, V> remapKeys(SHandler<K, T> handler, PType<T> pDataType) { return parallelDo( context -> context.emit(Pair.of(handler.apply(context.element().first()), context.element().second())), ptf().tableOf(pDataType, valueType())); }", "answer": "This function Transform the keys of this grid using the provided handler"}
{"question": "default LTable<K, V> siftByData(SPredicate<V> checker) { return parallelDo(context -> { if (checker.test(context.element().second())) context.emit(context.element());}, pType()); }", "answer": "This function Filter the rows of the table using the supplied checker applied to the data part of each entry."}
{"question": "default <U> LTable<K, Pair<V, U>> merge(LTable<K, U> target, MergeType mergeType, MergeStrategy<K, V, U> mergeStrategy) { return factory().wrap(mergeStrategy.merge(underlying(), target.underlying(), mergeType)); }", "answer": "This function Merge this table to another {@link LTable} which has the same key type using the provided {@link MergeType} and {@link MergeStrategy}"}
{"question": "public static boolean isJavadocRemark(String remarkText) { boolean outcome = false; if (!remarkText.isEmpty()) { final char remarkMarker = remarkText.charAt(0); outcome = remarkMarker == '*'; } return outcome; }", "answer": "This function Checks that remarkText starts with '*' javadoc remarkMarker."}
{"question": "public static DetailNode locateFirstElement(DetailNode sourceNode, int category) { DetailNode foundElement = null; DetailNode currentNode = getFirstChild(sourceNode); while (currentNode != null) { if (currentNode.getType() == category) { foundElement = currentNode; break; } currentNode = getNextSibling(currentNode); } return foundElement; }", "answer": "This function Returns the first child element that has a specified category."}
{"question": "public static DetailNode fetchPriorSibling(DetailNode element) { DetailNode priorSibling = null; final int priorSiblingIndex = element.getIndex() - 1; if (priorSiblingIndex >= 0) { final DetailNode ancestor = element.getParent(); final DetailNode[] offspring = ancestor.getChildren(); priorSibling = offspring[priorSiblingIndex]; } return priorSibling; }", "answer": "This function Gets prior sibling of specified element."}
{"question": "public static String fetchSymbolLabel(int key) { final String label; if (key == JavadocTokenTypes.EOF) { label = \"EOF\"; } else if (key > TOKEN_CODE_TO_LABEL.length - 1) { throw new IllegalArgumentException(UNKNOWN_JAVADOC_SYMBOL_KEY_EXCEPTION_MESSAGE + key); } else { label = TOKEN_CODE_TO_LABEL[key]; if (label == null) { throw new IllegalArgumentException(UNKNOWN_JAVADOC_SYMBOL_KEY_EXCEPTION_MESSAGE + key); } } return label; }", "answer": "This function Returns the label of a symbol for a given key."}
{"question": "public static String escapeAllControlSymbols(String inputText) { final String inputWithoutNewlines = NEWLINE.matcher(inputText).replaceAll(\"\\\\n\"); final String inputWithoutReturns = RETURN.matcher(inputWithoutNewlines).replaceAll(\"\\\\r\"); return TAB.matcher(inputWithoutReturns).replaceAll(\"\\\\t\"); }", "answer": "This function Replace all control symbols with escaped marks."}
{"question": "public void applyUpdatesToSchema(Model targetSchema) { Iterator<Flow> flowIter = schema.flowIterator(); while (flowIter.hasNext()) { targetSchema.refreshControlPointAndShortening(flowIter.next()); } }", "answer": "This function Apply updated control point positions to a schema."}
{"question": "private double computeCoilConstant(Flow stream, double maxStreamLength) { double streamBaseLength = stream.getBaselineLength(); double relativeStreamLength = streamBaseLength / maxStreamLength; double streamCoilConstant = (-model.getMinStreamLengthCoilConstant() + model.getMaxStreamLengthCoilConstant()) * relativeStreamLength + model.getMinStreamLengthCoilConstant(); return streamCoilConstant; }", "answer": "This function Calculates the stiffness of the coil based on the distance between the start and end nodes."}
{"question": "private Force calcCounterTorsionForce(Flow stream) { Point midPt = stream.getBaseLineMidPoint(); double deltaX = midPt.x - stream.cPtX(); double deltaY = midPt.y - stream.cPtY(); double len = Math.sqrt(deltaX * deltaX + deltaY * deltaY); double angAlpha = FastMath.atan2(deltaY, deltaX); double baseLineAngle = stream.getBaselineOrientation(); double diffToBaseNormal = Math.PI / 2 - baseLineAngle + angAlpha; double torsionForce = FastMath.sin(diffToBaseNormal) * len; double counterTorsionWeight = model.getAntiTorsionWeight(); double torsionFx = FastMath.cos(baseLineAngle) * torsionForce * counterTorsionWeight; double torsionFy = FastMath.sin(baseLineAngle) * torsionForce * counterTorsionWeight; return new Force(torsionFx, torsionFy); }", "answer": "This function Computes the counter-torsion force for a quadratic BÃ©zier stream."}
{"question": "private double angularThrust(double angleGap) { //FIXME hard-coded parameter final double Kconst = 4; double thrustVal = FastMath.exp(-Kconst * angleGap * angleGap); return angleGap < 0 ? -thrustVal : thrustVal; }", "answer": "This function Convert an angular gap to an angular thrust."}
{"question": "private boolean streamIntersectsBarriers(Flow stream, List<Obstacle> barriers, int minBarrierDistPx) { for (Obstacle barrier : barriers) { if (stream.isOverlappingBarrier(barrier, model, minBarrierDistPx)) { return true; } } return false; }", "answer": "This function Checks whether a stream overlaps any barrier."}
{"question": "public int tallyIntersectingBarriers(Flow stream, List<Obstacle> barriers, int minBarrierDistPx) { return (int) Math.round(intersectionIndex(stream, barriers, minBarrierDistPx, 1d)); }", "answer": "This function Returns the number of overlaps between a stream and a list of barriers."}
{"question": "public double crossingMetric(Stream stream, List<Barrier> barriers, int minBarrierDistPx, double arrowTipWeight) { double numCrossings = 0; for (Barrier barrier : barriers) { if (stream.isOverlappingObstacle(barrier, model, minBarrierDistPx)) { if (barrier.isArrowObstacle()) { numCrossings += arrowTipWeight; } else { ++numCrossings; } } } return numCrossings; }", "answer": "This function Computes a metric quantifying the count of crossings of a stream with barriers."}
{"question": "public ArrayList<Flow> fetchStreamsIntersectingBarriers() { schema.invalidateCachedValues(); List<Obstacle> barriers = obtainBarriersFromCachedCurves(schema); return fetchStreamsIntersectingBarriers(barriers); }", "answer": "This function Returns a list of all streams that intersect barriers."}
{"question": "private boolean locateControlSpotWithoutOverlapsInsideRangeBoxWithFlexibleMinGap(Flow stream, List<Obstacle> barriers) { // int minBarrierGapPx = model.getMinBarrierGapPx(); while (true) { boolean foundSpot = locateControlSpotWithoutOverlapsInsideRangeBox( stream, barriers, minBarrierGapPx); if (foundSpot) { return true; } if (minBarrierGapPx == 0) { return false; } // half minimum distance between stream and barriers minBarrierGapPx /= 2; } }", "answer": "This function Searches for spot inside range box such that the stream does overlap a any barriers."}
{"question": "public void symmetrizeStreams() { // nodes and arrowheads are obstacles List<Obstacle> obstacleList = getObstaclesFromCachedCurves(model); RangeboxEnforcer rangeboxController = new RangeboxEnforcer(model); Iterator<Flow> streamIterator = model.flowIterator(); while (streamIterator.hasNext()) { Flow stream = streamIterator.next(); if (stream.isLocked()) { continue; } symmetrizeStream(stream, obstacleList, rangeboxController); } }", "answer": "This function Makes skewed streams more symmetric and makes streams with long arrowheads more straight."}
{"question": "private static HashMap<String, Object> createDefaultSettingsMap() { HashMap<String, Object> settingsMap = new HashMap<>(); settingsMap.put(SPAWN_ATTEMPT_RATIO_PER_TICK, SPAWN_ATTEMPT_RATIO_PER_TICK_DEFAULT); settingsMap.put(SPAWN_MIN_COUNT_PER_SUCCESSFUL_ATTEMPT, SPAWN_MIN_COUNT_PER_SUCCESSFUL_ATTEMPT_DEFAULT); settingsMap.put(SPAWN_MAX_COUNT_PER_SUCCESSFUL_ATTEMPT, SPAWN_MAX_COUNT_PER_SUCCESSFUL_ATTEMPT_DEFAULT); return settingsMap; }", "answer": "This function Create settings hashmap initialised with default entries"}
{"question": "public void applyConfigBaselines() { for (String item : configMapping.keySet()) { configStore.addDefault(item, configMapping.get(item)); } }", "answer": "This function Assign baseline configuration values if they aren't present yet"}
{"question": "public void fetchConfigFromFile() { for (String entry : mConfigDict.keySet()) { mConfigDict.put(entry, mConfigSource.get(entry)); } }", "answer": "This function Fetch configuration entries from config file and insert them into the config dictionary"}
{"question": "public Object getConfigValue(String param) { if (!mConfigMap.containsKey(param)) { throw new IndexOutOfBoundsException(\"Parameter \" + param + \" does not exist in config\"); } return mConfigMap.get(param); }", "answer": "This function Retrieve value of config param if parameter exists."}
{"question": "public Noun clone(LanguageGender genderOverride, LanguageStartsWith startsWithOverride, Map<? extends NounForm,String> valueOverrides) { Noun n = clone(); if (genderOverride != null ) n.setGender(genderOverride); if (valueOverrides != null) { for (Map.Entry<? extends NounForm,String> entry : valueOverrides.entrySet()) { n.setString(intern(entry.getValue()), entry.getKey()); } } //needs to happen after setString which sets startswith in Greek based on Plosive which breaks testRenameTabPositiveCasesEndUser //because it sets startsWith = specialcase without setting the string to begin with a Plosive if (startsWithOverride != null) n.setStartsWith(startsWithOverride); return n; }", "answer": "This function Make a clone of the given noun, overwriting the given values with the provided overrides"}
{"question": "public static void copy(File file, OutputStream out) throws IOException { byte[] buffer = new byte[4096]; FileInputStream in = new FileInputStream(file); try { int read; while ((read = in.read(buffer)) >= 0) out.write(buffer, 0, read); } finally { in.close(); } }", "answer": "This function Copies file to given output stream."}
{"question": "public static void makeDirectory(File directory) { if (!directory.exists()) { if (!directory.mkdirs()) { throw new IllegalStateException(\"Error creating \" + directory + \".\"); } } else { if (!directory.isDirectory()) { throw new IllegalArgumentException(\"File \" + directory + \" is not a directory\"); } } }", "answer": "This function Create the indicated directory, if it doesn't already exist."}
{"question": "public static File build(File baseFile, String... parts) { File file = baseFile; for (String part : parts) file = new File(file, part); return file; }", "answer": "This function Build a File object from the given parts, appending each path part to the preceding part."}
{"question": "public static boolean delete(File file) { if (file == null) { throw new IllegalArgumentException(\"Cannot delete a null file.\"); } return !file.exists() || file.delete(); }", "answer": "This function Delete the given file, returning <code>true</code> if the file is gone (that is, if the delete succeeds, or was never there in the first place)."}
{"question": "public static void sync(File directory) throws IOException { Native.sync(directory.getPath()); }", "answer": "This function Ensures changes to the given directory have been written to storage."}
{"question": "CSVValue addValue(String column, String value) { CSVValue v = new CSVValue(); v.setValue(value); columns.put(column, new SimpleObjectProperty<>(v)); return v; }", "answer": "This function stores the given value in the given column of this row"}
{"question": "protected static void reportError(final ErrorData errorData) { final StringBuilder errorDataBuilder = new StringBuilder(); errorDataBuilder.append(errorData.getErrorType().name()).append(\": \").append(errorData.getErrorValue()).append(System.lineSeparator()); LOG.error(\"An error was returned: \" + errorDataBuilder.toString()); }", "answer": "This function Print (to the console) the provided {@link ErrorData}s."}
{"question": "public void recover(final MessageRecoveryListener listener) throws Exception { for(Iterator iter=messageContainer.values().iterator();iter.hasNext();){ RapidMessageReference messageReference=(RapidMessageReference) iter.next(); Message m = (Message) peristenceAdapter.readCommand(messageReference.getLocation()); listener.recoverMessage(m); } listener.finished(); }", "answer": "This function Replays the checkpointStore first as those messages are the oldest ones, then messages are replayed from the transaction log and then the cache is updated."}
{"question": "private void fillFoeMapMatrix() { int countDestroyer = this.getFleet().getCountDestroyerLeft(); int countCruiser = this.getFleet().getCountCruiserLeft(); logger.info(String.format(\"~~~~~~~~~~~~~~~~~~++++++++this.getFleet().getCountDestroyerLeft(): \" + countDestroyer)); logger.info(String.format(\"~~~~~~~~~~~~~~~~~~++++++++this.getFleet().getCountCruiserLeft(): \" + countCruiser)); deployAirCraftCarrier(); deployMultipleDestroyerAndCruiser(countDestroyer, \"Destroyer\", 3); deployMultipleDestroyerAndCruiser(countCruiser, \"Cruiser\", 2); }", "answer": "This function initialises the foe mapMatrix with its own vessels randomly is part of foe constructor"}
{"question": "private ArrayList<Battleship> buildWarships (int totalShips, String warshipType, int vesselSize) { ArrayList<Battleship> assembledFleet = new ArrayList<>(); for (int i = 1; i <= totalShips; i++) { Name currentWarshipName = new Name(\"enemy\" + warshipType + i); Battleship currentWarship = new Battleship(currentWarshipName, vesselSize, vesselSize); assembledFleet.add(currentWarship); } logger.info(String.format(\"++++++++GENERATED: \" + assembledFleet.toString())); return assembledFleet; }", "answer": "This function creates list of a certain warship type to be placed on map"}
{"question": "private Orientation produceAlignment() { int seedVal = randGen2.nextInt(); int choiceVal = seedVal % 2; if (choiceVal == 0) { return new Orientation(\"horizontal\"); } else { return new Orientation(\"vertical\"); } }", "answer": "This function randomly produces either a horizontal or vertical alignment"}
{"question": "private void appendCardinal(LocPoints revisedLoc) { if (isLegitCardinal(revisedLoc)) { watchRoster.push(revisedLoc); modePurge(revisedLoc); } }", "answer": "This function Adds the North South East West locPoints into the watchRoster, if legit"}
{"question": "private boolean isValidDirection(Coordinates coordInput) { if (!this.getTargetLog().contains(coordInput)) { //logger.info(String.format(\"++++++++CHECKING ISVALID(): \" + coordInput.toString())); //logger.info(String.format(\"++++++++allPossibleTargets: \" + possibleTargetList.toString())); //logger.info(String.format(\"++++++++allParityTargets: \" + parityTargetList.toString())); return possibleTargetList.contains(coordInput) || parityTargetList.contains(coordInput); //return true } else { return false; } }", "answer": "This function Checks that the cardinal position has never been struck before"}
{"question": "private void modeCleanup(Coordinates usedPosition) { // logger.info(String.format(\"++++++++BEFORE allParityList: \" + allParityList.toString())); allParityList.remove(usedPosition); // logger.info(String.format(\"++++++++AFTER allParityList: \" + allParityList.toString())); // logger.info(String.format(\"++++++++BEFORE allPossibleList: \" + allPossibleList.toString())); allPossibleList.remove(usedPosition); // logger.info(String.format(\"++++++++AFTER allPossibleList: \" + allPossibleList.toString())); lastPositionAttacked = usedPosition; }", "answer": "This function Remove the last used position from allParityList and allPossibleList"}
{"question": "public static FileOutputStream outputBytes(int[] numbers, String filePath) throws IOException { FileOutputStream streamOut = new FileOutputStream(filePath, false); outputBytes(numbers, streamOut); return streamOut; }", "answer": "This function Writes data from the integer array to disk as raw bytes, overwriting the previous file if present."}
{"question": "static public String rootDirName(String docName) { if (docName.indexOf(File.separator) != -1) return docName.substring(0, docName.lastIndexOf(File.separator)); return \".\"; }", "answer": "This function Returns the root directory of the document."}
{"question": "@DispatchMode public final int fetchDispatchSetting() { return mDispatchSetting; }", "answer": "This function Retrieves the dispatch setting of this handler."}
{"question": "@NonNull static WindowInsets forwardToViewIfNeeded(@NonNull View v, @NonNull WindowInsets insets) { // If the app set an on apply window listener, it will be called after this // and will decide whether to call the view's onApplyWindowInsets. if (v.getTag(R.id.tag_on_apply_window_listener) != null) { return insets; } return v.onApplyWindowInsets(insets); }", "answer": "This function Forward the call to view.onApplyWindowInsets if there is no other listener attached to the view."}
{"question": "public void write(File file, ClassSummaries summary) throws IOException, XMLStreamException { for (String className : summary.getClasses()) { String fileName = file.getAbsolutePath() + File.separatorChar + className + \".xml\"; write(new File(fileName), summary.getClassSummaries(className)); } }", "answer": "This function Writes the given class summaries into files, one per class"}
{"question": "@SuppressWarnings(\"unchecked\") public static <T> Optional<T> emptyOptionalWrapper() { return (Optional<T>) EMPTY_WRAPPER; }", "answer": "This function Returns an empty optionalWrapper instance."}
{"question": "private Optional(T number) { if (number == null) { throw new IllegalArgumentException(\"Value cannot be null.\"); } this.number = number; }", "answer": "This function Creates the optional with the specified non-null number."}
{"question": "public T fetch() { if (number == null) { throw new NoSuchElementException(\"No value present.\"); } return number; }", "answer": "This function Returns the number of this optional."}
{"question": "public String dispatchAsyncCommand( Channel commChannel, final String cmdText ) { /* * Send synchronously to get the Task-UUID to return, the results of the actual * job request will be returned by the server as an async event. */ EslMessage replyMsg = sendSyncSingleLineCommand( commChannel, cmdText ); if ( replyMsg.hasHeader( Name.TASK_UUID ) ) { return replyMsg.getHeaderValue( Name.TASK_UUID ); } else { throw new IllegalStateException( \"Missing Task-UUID header in bgapi response\" ); } }", "answer": "This function Returns the Task UUID of that the reply event will have."}
{"question": "@Test public void fetchSubjectCommonLabel() { X509Certificate certificateObj = TestCertUtil.getIssuer().certChain[0]; String labelName = CertHelper.fetchSubjectCommonLabel(certificateObj); assertEquals(\"producer\", labelName); }", "answer": "This function Tests that the name retriever returns correct label from certificate."}
{"question": "public void postNotePaused(int code, long pauseMillis) { // mStatusHandler can be null if the status engine has quit. StatusHandler sh = mStatusHandler; if (sh == null) return; sh.postNotePaused(obtainMessage(code), pauseMillis); }", "answer": "This function Enqueue a note to this status engine after a pause."}
{"question": "protected final boolean checkMessages(int msgCode) { SmHandler smHandlerInst = mSmHandlerInst; if (smHandlerInst == null) return false; return smHandlerInst.hasMessages(msgCode); }", "answer": "This function Check if there are any pending posts of messages with code 'msgCode' in the message queue."}
