{"question": "def table_iter (self) : root = self.tree.getroot () for div in root.findall (\".//%s\" % tag (\"div\")) : if div.get ('id') == 'maincontent' : break tbl = div.find (\".//%s\" % tag (\"table\")) if tbl is None : return for tr in tbl : if tr [0].tag == tag ('th') : continue yield (self.tree.get_text (x) for x in tr)", "answer": "public class TableParser { private Document doc; public TableParser(Document doc) { this.doc = doc; } public List<List<String>> tableIter() { List<List<String>> result = new ArrayList<>(); Element mainDiv = doc.selectFirst(\"div#maincontent\"); if (mainDiv == null) { return result; } Element table = mainDiv.selectFirst(\"table\"); if (table == null) { return result; } for (Element tr : table.select(\"tr\")) { Elements firstCol = tr.select(\"th\"); if (!firstCol.isEmpty()) { continue; } List<String> row = new ArrayList<>(); for (Element td : tr.select(\"td\")) { row.add(td.text()); } result.add(row); } return result; } }"}
{"question": "def parse (self) : self.neighbors = {} for l in self.table_iter () : neighbor, ip, lq, nlq, etx = l lq, nlq, etx = (float (x) for x in (lq, nlq, etx)) self.neighbors [neighbor] = [ip, lq, nlq, etx]", "answer": "public class TableParser { private List<List<String>> tableData; private Map<String, List<Object>> neighbors; public TableParser(List<List<String>> tableData) { this.tableData = tableData; this.neighbors = new HashMap<>(); } public void parse() { for (List<String> row : tableData) { if (row.size() != 5) continue; String neighbor = row.get(0); String ip = row.get(1); try { float lq = Float.parseFloat(row.get(2)); float nlq = Float.parseFloat(row.get(3)); float etx = Float.parseFloat(row.get(4)); List<Object> values = new ArrayList<>(); values.add(ip); values.add(lq); values.add(nlq); values.add(etx); neighbors.put(neighbor, values); } catch (NumberFormatException e) { e.printStackTrace(); } } } public Map<String, List<Object>> getNeighbors() { return neighbors; } }"}
{"question": "def limit(img, std_hash, count): cmp_hash = calc_hash(img) diff = compare(std_hash, cmp_hash) if diff <= DIFF_THRES: if count >= LIMIT: return 'remove' else: return 'update_std' return 'continue'", "answer": "public static String limit(Image img, String stdHash, int count) { String cmpHash = calcHash(img); int diff = compare(stdHash, cmpHash); if (diff <= DIFF_THRES) { if (count >= LIMIT) { return \"remove\"; } } else { return \"update_std\"; } return \"continue\"; }"}
{"question": "def resize(img): width = np.shape(img)[1] height = np.shape(img)[0] if width > RESIZE: scale = RESIZE / width resized_img = cv2.resize( img, (RESIZE, math.floor(height / scale)), cv2.INTER_AREA) return resized_img return img", "answer": "public class ImageResizer { private static final int RESIZE = 800; public static BufferedImage resize(BufferedImage img) { int width = img.getWidth(); int height = img.getHeight(); if (width > RESIZE) { double scale = (double) RESIZE / width; int newHeight = (int) Math.floor(height * scale); Image tmp = img.getScaledInstance(RESIZE, newHeight, Image.SCALE_AREA_AVERAGING); BufferedImage resized = new BufferedImage(RESIZE, newHeight, img.getType()); Graphics2D g2d = resized.createGraphics(); g2d.drawImage(tmp, 0, 0, null); g2d.dispose(); return resized; } return img; } }"}
{"question": "class Room_Item(QWidget,Ui_Form): def __init__(self,parent=None,room_data=None): super(Room_Item,self).__init__(parent) self.setupUi(self) self.data = room_data self.setRoomInfo()", "answer": "public class RoomItem extends JPanel { private RoomData data; public RoomItem(RoomData roomData) { this.data = roomData; setupUi(); setRoomInfo(); } private void setupUi() { } private void setRoomInfo() { } }"}
{"question": "def print_stack_trace(cls, stack_trace_line): for level in stack_trace_line.split(\"', '\"): for line in level.split(\"\\\\n\"): if line: print(line)", "answer": "public class StackTracePrinter { public static void printStackTrace(String stackTraceLine) { String[] levels = stackTraceLine.split(\"', '\"); for (String level : levels) { String[] lines = level.split(\"\\\\\\\\n\"); for (String line : lines) { if (!line.isEmpty()) { System.out.println(line); } } } } }"}
{"question": "def run_app(self): try: self.create() self.native.ThreadException += self.winforms_thread_exception self.loop.run_forever(self.app_context) except: # NOQA traceback.print_exc()", "answer": "public class AppRunner { private AppContext appContext; private NativeHandler nativeHandler; private EventLoop loop; public void runApp() { try { create(); nativeHandler.addThreadExceptionListener(this::winformsThreadException); loop.runForever(appContext); } catch (Exception e) { e.printStackTrace(); } } private void create() { } private void winformsThreadException(Thread t, Throwable e) { e.printStackTrace(); } }"}
{"question": "def _create_app_commands(self): self.interface.commands.add( toga.Command( lambda w: self.open_file, label='Open...', shortcut=Key.MOD_1 + 'o', group=toga.Group.FILE, section=0 ) )", "answer": "public class AppCommands { private JMenuBar menuBar; public AppCommands(JMenuBar menuBar) { this.menuBar = menuBar; createAppCommands(); } private void createAppCommands() { JMenu fileMenu = new JMenu(\"File\"); JMenuItem openItem = new JMenuItem(\"Open...\"); openItem.setAccelerator(KeyStroke.getKeyStroke('O', Toolkit.getDefaultToolkit().getMenuShortcutKeyMaskEx())); openItem.addActionListener(new ActionListener() { @Override public void actionPerformed(ActionEvent e) { openFile(); } }); fileMenu.add(openItem); menuBar.add(fileMenu); } private void openFile() { System.out.println(\"Open file triggered\"); } }"}
{"question": "def featureSelection_variance(X, thrd): sel = VarianceThreshold(threshold=thrd) X_selected = sel.fit_transform(X) mask = sel.get_support() return X_selected, mask", "answer": "public class FeatureSelection { public static class Result { public double[][] XSelected; public boolean[] mask; public Result(double[][] XSelected, boolean[] mask) { this.XSelected = XSelected; this.mask = mask; } } public static Result featureSelectionVariance(double[][] X, double threshold) { int nSamples = X.length; int nFeatures = X[0].length; boolean[] mask = new boolean[nFeatures]; int selectedCount = 0; for (int j = 0; j < nFeatures; j++) { double mean = 0; for (int i = 0; i < nSamples; i++) { mean += X[i][j]; } mean /= nSamples; double var = 0; for (int i = 0; i < nSamples; i++) { var += (X[i][j] - mean) * (X[i][j] - mean); } var /= nSamples; if (var > threshold) { mask[j] = true; selectedCount++; } else { mask[j] = false; } } double[][] XSelected = new double[nSamples][selectedCount]; for (int i = 0; i < nSamples; i++) { int colIdx = 0; for (int j = 0; j < nFeatures; j++) { if (mask[j]) { XSelected[i][colIdx++] = X[i][j]; } } } return new Result(XSelected, mask); } }"}
{"question": "def init_hdf5(file_path, mode=\"w\", cam_type=\"davis\"): if mode == \"w\": dataset = h5py.File(file_path, mode=mode) dataset.create_group(\"dvs\") dataset.create_group(\"extra\") if cam_type == \"davis\": dataset.create_group(\"aps\") dataset.create_group(\"imu\") elif mode == \"r\": dataset = h5py.File(file_path, mode=mode) return dataset", "answer": "public class HDF5Initializer { public static H5File initHDF5(String filePath, String mode, String camType) throws Exception { H5File file; if (mode.equals(\"w\")) { file = new H5File(filePath, FileFormat.CREATE); file.open(); file.createGroup(\"dvs\", null); file.createGroup(\"extra\", null); if (camType.equals(\"davis\")) { file.createGroup(\"aps\", null); file.createGroup(\"imu\", null); } } else if (mode.equals(\"r\")) { file = new H5File(filePath, FileFormat.READ); file.open(); } else { throw new IllegalArgumentException(\"Unsupported mode: \" + mode); } return file; } }"}
{"question": "def GetRootAsFloatingPoint(cls, buf, offset): n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset) x = FloatingPoint() x.Init(buf, n + offset) return x", "answer": "public class FloatingPointHelper { public static FloatingPoint getRootAsFloatingPoint(ByteBuffer buf, int offset) { int n = buf.getInt(offset); FloatingPoint x = new FloatingPoint(); x.__init(n + offset, buf); return x; } }"}
{"question": "def Precision(self): o = flatbuffers.number_types.UOffsetTFlags.py_type( self._tab.Offset(4) ) if o != 0: return self._tab.Get( flatbuffers.number_types.Int16Flags, o + self._tab.Pos ) return 0", "answer": "public class MyTable extends Table { public short precision() { int o = __offset(4); if (o != 0) { return bb.getShort(o + bb_pos); } return 0; } }"}
{"question": "def avg(self): sum = float(self.sum) if not self.window_size: return 0 return sum / self.window_size / self.window_interval", "answer": "public class MovingAverage { private double sum; private int windowSize; private double windowInterval; public double avg() { if (windowSize == 0) { return 0; } return sum / windowSize / windowInterval; } }"}
{"question": "def keys(self): result = set() for key in self.manager.counters: if key[:len(self._keys)] == self._keys: key = key[len(self._keys):] result.add(key[0] if key else '__value__') return result", "answer": "public class KeyManager { private Manager manager; private String[] keys; public Set<String> keys() { Set<String> result = new HashSet<>(); for (String[] key : manager.counters.keySet()) { if (startsWith(key, this.keys)) { String[] subKey = subArray(key, this.keys.length, key.length); if (subKey.length > 0) { result.add(subKey[0]); } else { result.add(\"__value__\"); } } } return result; }"}
{"question": "def to_dict(self, get_value=None): result = {} for key, value in iteritems(self): if isinstance(value, BaseCounter): if get_value is not None: value = getattr(value, get_value) result[key] = value else: result[key] = value.to_dict(get_value) return result", "answer": "public class BaseCounter { public Map<String, Object> iterItems() { return new HashMap<>(); } public Map<String, Object> toDict(String getValue) { Map<String, Object> result = new HashMap<>(); for (Map.Entry<String, Object> entry : iterItems().entrySet()) { String key = entry.getKey(); Object value = entry.getValue(); if (value instanceof BaseCounter) { if (getValue != null) { try { value = value.getClass().getField(getValue).get(value); } catch (Exception e) { e.printStackTrace(); value = null; } } result.put(key, value); } else if (value instanceof BaseCounter) { result.put(key, ((BaseCounter) value).toDict(getValue)); } else { result.put(key, value); } } return result; } }"}
{"question": "def load(self, filename): try: with open(filename) as fp: self.counters = cPickle.load(fp) except: logging.debug(\"can't load counter from file: %s\" % filename) return False return True", "answer": "public class CounterManager { private static final Logger logger = Logger.getLogger(CounterManager.class.getName()); private Object counters; public boolean load(String filename) { try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream(filename))) { counters = ois.readObject(); return true; } catch (IOException | ClassNotFoundException e) { logger.log(Level.FINE, \"can't load counter from file: \" + filename, e); return false; } } }"}
{"question": "def dfs(i, j): if i == len(grid): return 0 if memo[i][j] == UNKNOWN: memo[i][j] = grid[i][j] + max(dfs(i + 1, j), dfs(i + 1, j + 1)) return memo[i][j] return dfs(0, 0)", "answer": "public class TriangleMaxPath { private int[][] grid; private int[][] memo; private static final int UNKNOWN = Integer.MIN_VALUE; public TriangleMaxPath(int[][] grid) { this.grid = grid; this.memo = new int[grid.length][grid[0].length]; for (int i = 0; i < memo.length; i++) { for (int j = 0; j < memo[i].length; j++) { memo[i][j] = UNKNOWN; } } } public int maxPathSum() { return dfs(0, 0); } private int dfs(int i, int j) { if (i == grid.length) { return 0; } if (memo[i][j] == UNKNOWN) { memo[i][j] = grid[i][j] + Math.max(dfs(i + 1, j), dfs(i + 1, j + 1)); } return memo[i][j]; } }"}
{"question": "def kornia_color_jitter_numpy(img, setting): if setting * 255 > 1: # I'm using Kornia's ColorJitter, which requires pytorch arrays in b,c,h,w format. img = torch.from_numpy(img).permute(2,0,1).unsqueeze(0) img = ColorJitter(setting, setting, setting, setting)(img) img = img.squeeze(0).permute(1,2,0).numpy() return img", "answer": "public class ColorJitter { public static Mat korniaColorJitter(Mat img, float setting) { if (setting * 255 > 1) { Mat jittered = img.clone(); double alpha = 1.0; double beta = (Math.random() * 2 - 1) * setting * 255; jittered.convertTo(jittered, -1, alpha, beta); Mat hsv = new Mat(); Imgproc.cvtColor(jittered, hsv, Imgproc.COLOR_RGB2HSV); List<Mat> hsvChannels = new ArrayList<>(); Core.split(hsv, hsvChannels); hsvChannels.get(1).convertTo(hsvChannels.get(1), -1, 1, (Math.random() * 2 - 1) * setting * 255); Core.merge(hsvChannels, hsv); Imgproc.cvtColor(hsv, jittered, Imgproc.COLOR_HSV2RGB); return jittered; } return img; } }"}
{"question": "def reset_random(self): if 'random_seed' in self.opt.keys(): self.rand = random.Random(self.opt['random_seed']) else: self.rand = random.Random()", "answer": "public class RandomResetter { private Map<String, Object> opt; private Random rand; public void resetRandom() { if (opt.containsKey(\"random_seed\")) { long seed = ((Number) opt.get(\"random_seed\")).longValue(); rand = new Random(seed); } else { rand = new Random(); } } }"}
{"question": "def get_rand(self): r = self.rand.random() if self.cosine_bias: return 1 - cos(r * pi / 2) else: return r", "answer": "public class RandomGenerator { private Random rand; private boolean cosineBias; public double getRand() { double r = rand.nextDouble(); if (cosineBias) { return 1 - Math.cos(r * Math.PI / 2); } else { return r; } } }"}
{"question": "def test_hue_shift_limit_value( quality_lower, quality_upper, expected, message): try: Tfda.JpegCompression( quality_lower=quality_lower, quality_upper=quality_upper) actual = TestResult.OK except ValueError: actual = TestResult.Error assert expected == actual, message", "answer": "public class JpegCompressionTest { enum TestResult { OK, Error } public void testHueShiftLimitValue(int qualityLower, int qualityUpper, TestResult expected, String message) { TestResult actual; try { Tfda.JpegCompression jpeg = new Tfda.JpegCompression(qualityLower, qualityUpper); actual = TestResult.OK; } catch (IllegalArgumentException e) { actual = TestResult.Error; } assertEquals(expected, actual, message); } @Test public void runTest() { testHueShiftLimitValue(10, 90, TestResult.OK, \"Quality range valid\"); testHueShiftLimitValue(-5, 105, TestResult.Error, \"Quality range invalid\"); } }"}
{"question": "def test_bg_swap_fast(): bg_x = np.ones(shape=[2, 5, 5, 3]) * -1 bg_y = np.random.rand(2) fg = np.random.normal(loc=.5, scale=.1, size=[5, 5]) bg = InMemoryDataset(bg_x, bg_y) bg_swap = BackgroundSwap(bg, input_dim=(5, 5), normalize_bg=None) spliced_1_channel = bg_swap(fg)[:, :, 0] assert np.array_equal((spliced_1_channel <= -1), (fg <= .5))", "answer": "public class BackgroundSwapTest { @Test public void testBgSwapFast() { int batch = 2; int height = 5; int width = 5; int channels = 3; Random rand = new Random(); Mat[] bg_x = new Mat[batch]; for (int b = 0; b < batch; b++) { bg_x[b] = new Mat(height, width, CvType.CV_32FC3); for (int i = 0; i < height; i++) { for (int j = 0; j < width; j++) { double[] vals = new double[channels]; for (int c = 0; c < channels; c++) { vals[c] = -1.0; } bg_x[b].put(i, j, vals); } } } double[] bg_y = new double[batch]; for (int b = 0; b < batch; b++) { bg_y[b] = rand.nextDouble(); } Mat fg = new Mat(height, width, CvType.CV_32F); for (int i = 0; i < height; i++) { for (int j = 0; j < width; j++) { fg.put(i, j, 0.5 + 0.1 * rand.nextGaussian()); } } InMemoryDataset bg = new InMemoryDataset(bg_x, bg_y); BackgroundSwap bgSwap = new BackgroundSwap(bg, new int[]{5, 5}, null); Mat spliced = bgSwap.apply(fg); Mat spliced1Channel = new Mat(); Core.extractChannel(spliced, spliced1Channel, 0); for (int i = 0; i < height; i++) { for (int j = 0; j < width; j++) { double valSpliced = spliced1Channel.get(i, j)[0]; double valFg = fg.get(i, j)[0]; assertEquals(valSpliced <= -1, valFg <= 0.5); } } } }"}
{"question": "def test_background_swap_numpy(): mnist = MNIST(DATA_PATH, download=True, train=True) cifar = CIFAR10(DATA_PATH, download=True, train=True) bg_swap = BackgroundSwap(cifar, input_dim=(28, 28)) im = mnist.get_data()[0][0] im = bg_swap(im)", "answer": "public class BackgroundSwapTestJava { public void testBackgroundSwapNumpy() { MNISTDataset mnist = new MNISTDataset(\"data_path\", true); CIFAR10Dataset cifar = new CIFAR10Dataset(\"data_path\", true); BackgroundSwap bgSwap = new BackgroundSwap(cifar, new int[]{28, 28}, null); Mat im = mnist.getData().get(0); Mat result = bgSwap.apply(im); } }"}
{"question": "def test_leaves_remote_addr_alone_if_no_real_ip(): remote_addr = object() request = unittest.mock.MagicMock() request.META = {\"REMOTE_ADDR\": remote_addr} middleware.XRealIPMiddleware(get_response)(request) assert request.META[\"REMOTE_ADDR\"] is remote_addr", "answer": "public class XRealIPMiddlewareTest { @Test public void testLeavesRemoteAddrAloneIfNoRealIp() { Object remoteAddr = new Object(); Request request = Mockito.mock(Request.class); Map<String, Object> meta = new HashMap<>(); meta.put(\"REMOTE_ADDR\", remoteAddr); Mockito.when(request.getMeta()).thenReturn(meta); Middleware middleware = new XRealIPMiddleware(getResponse()); middleware.handle(request); assertSame(remoteAddr, request.getMeta().get(\"REMOTE_ADDR\")); } private Response getResponse() { return new Response(); } public static class Request { private Map<String, Object> meta; public Map<String, Object> getMeta() { return meta; } } public interface Middleware { void handle(Request request); } public static class XRealIPMiddleware implements Middleware { private Response response; public XRealIPMiddleware(Response response) { this.response = response; } public void handle(Request request) { } } public static class Response {} }"}
{"question": "def test_switches_out_x_real_ip_if_available(): remote_addr = object() x_real_ip = object() request = unittest.mock.MagicMock() request.META = {\"REMOTE_ADDR\": remote_addr, \"HTTP_X_REAL_IP\": x_real_ip} middleware.XRealIPMiddleware(get_response)(request) assert request.META[\"REMOTE_ADDR\"] is x_real_ip assert request.META[\"HTTP_X_REAL_IP\"] is x_real_ip", "answer": "public class XRealIPMiddlewareTest { @Test public void testSwitchesOutXRealIpIfAvailable() { Object remoteAddr = new Object(); Object xRealIp = new Object(); Request request = Mockito.mock(Request.class); Map<String, Object> meta = new HashMap<>(); meta.put(\"REMOTE_ADDR\", remoteAddr); meta.put(\"HTTP_X_REAL_IP\", xRealIp); Mockito.when(request.getMeta()).thenReturn(meta); Middleware middleware = new XRealIPMiddleware(getResponse()); middleware.handle(request); assertSame(xRealIp, request.getMeta().get(\"REMOTE_ADDR\")); assertSame(xRealIp, request.getMeta().get(\"HTTP_X_REAL_IP\")); } private Response getResponse() { return new Response(); } public static class Request { private Map<String, Object> meta; public Map<String, Object> getMeta() { return meta; } } public interface Middleware { void handle(Request request); } public static class XRealIPMiddleware implements Middleware { private Response response; public XRealIPMiddleware(Response response) { this.response = response; } public void handle(Request request) { Map<String, Object> meta = request.getMeta(); if (meta.containsKey(\"HTTP_X_REAL_IP\")) { meta.put(\"REMOTE_ADDR\", meta.get(\"HTTP_X_REAL_IP\")); } } } public static class Response {} }"}
{"question": "class Notifier: def __init__(self, name): self.notify = directNotify.newCategory(name)", "answer": "public class Notifier { private NotifyCategory notify; public Notifier(String name) { this.notify = DirectNotify.newCategory(name); } public NotifyCategory getNotify() { return notify; } }"}
{"question": "def __init__(self): super().__init__(SCREEN_WIDTH, SCREEN_HEIGHT, SCREEN_TITLE) self.camera = None self.gui_camera = None self.score = 0", "answer": "public class GameWindow extends BaseWindow { private Camera camera; private Camera guiCamera; private int score; public GameWindow() { super(SCREEN_WIDTH, SCREEN_HEIGHT, SCREEN_TITLE); this.camera = null; this.guiCamera = null; this.score = 0; } }"}
{"question": "def setup(self): self.camera = arcade.Camera(self.width, self.height) self.gui_camera = arcade.Camera(self.width, self.height) map_name = \":resources:tiled_maps/map.json\" layer_options = { \"Platforms\": { \"use_spatial_hash\": True } }", "answer": "public class GameWindow extends BaseWindow { private Camera camera; private Camera guiCamera; public void setup() { this.camera = new Camera(this.getWidth(), this.getHeight()); this.guiCamera = new Camera(this.getWidth(), this.getHeight()); String mapName = \":resources:tiled_maps/map.json\"; Map<String, Map<String, Object>> layerOptions = new HashMap<>(); Map<String, Object> platformsOptions = new HashMap<>(); platformsOptions.put(\"use_spatial_hash\", true); layerOptions.put(\"Platforms\", platformsOptions); } }"}
{"question": "def on_key_release(self, key, modifiers): if key == arcade.key.LEFT or key == arcade.key.A: self.player_sprite.change_x = 0 elif key == arcade.key.RIGHT or key == arcade.key.D: self.player_sprite.change_x = 0", "answer": "public class PlayerKeyListener extends KeyAdapter { private PlayerSprite playerSprite; public PlayerKeyListener(PlayerSprite playerSprite) { this.playerSprite = playerSprite; } @Override public void keyReleased(KeyEvent e) { int key = e.getKeyCode(); if (key == KeyEvent.VK_LEFT || key == KeyEvent.VK_A) { playerSprite.setChangeX(0); } else if (key == KeyEvent.VK_RIGHT || key == KeyEvent.VK_D) { playerSprite.setChangeX(0); } } }"}
{"question": "def ycmd_root_directory(self): if self._ycmd_root_directory is None: logger.warning('no ycmd root directory has been set') return self._ycmd_root_directory", "answer": "public class YcmdHandler { private static final Logger logger = Logger.getLogger(YcmdHandler.class.getName()); private String ycmdRootDirectory; public String getYcmdRootDirectory() { if (this.ycmdRootDirectory == null) { logger.warning(\"no ycmd root directory has been set\"); } return this.ycmdRootDirectory; } public void setYcmdRootDirectory(String path) { this.ycmdRootDirectory = path; } }"}
{"question": "def ycmd_root_directory(self, ycmd_root_directory): if ycmd_root_directory is not None and not isinstance(ycmd_root_directory, str): raise TypeError(ycmd_root_directory) self._ycmd_root_directory = ycmd_root_directory", "answer": "public class YcmdHandler { private String ycmdRootDirectory; public void setYcmdRootDirectory(String ycmdRootDirectory) { if (ycmdRootDirectory != null && !(ycmdRootDirectory instanceof String)) { throw new IllegalArgumentException(\"ycmdRootDirectory must be a String\"); } this.ycmdRootDirectory = ycmdRootDirectory; } public String getYcmdRootDirectory() { return this.ycmdRootDirectory; } }"}
{"question": "def ycmd_settings_path(self): if self._ycmd_settings_path is None: if self._ycmd_root_directory is not None: return get_default_settings_path(self._ycmd_root_directory) logger.warning('no ycmd root directory has been set') return self._ycmd_settings_path", "answer": "public class YcmdHandler { private static final Logger logger = Logger.getLogger(YcmdHandler.class.getName()); private String ycmdRootDirectory; private String ycmdSettingsPath; public String getYcmdSettingsPath() { if (this.ycmdSettingsPath == null) { if (this.ycmdRootDirectory != null) { return getDefaultSettingsPath(this.ycmdRootDirectory); } logger.warning(\"no ycmd root directory has been set\"); } return this.ycmdSettingsPath; } private String getDefaultSettingsPath(String rootDirectory) { return rootDirectory + \"/.ycmd/settings.json\"; } public void setYcmdRootDirectory(String path) { this.ycmdRootDirectory = path; } public void setYcmdSettingsPath(String path) { this.ycmdSettingsPath = path; } }"}
{"question": "def working_directory(self): if self._working_directory is None: return os.getcwd() return self._working_directory", "answer": "public class DirectoryHandler { private String workingDirectory; public String getWorkingDirectory() { if (this.workingDirectory == null) { return System.getProperty(\"user.dir\"); } return this.workingDirectory; } public void setWorkingDirectory(String path) { this.workingDirectory = path; } }"}
{"question": "def python_binary_path(self): if self._python_binary_path is None: return default_python_binary_path() return self._python_binary_path", "answer": "public String getPythonBinaryPath() { if (this.pythonBinaryPath == null) { return defaultPythonBinaryPath(); } return this.pythonBinaryPath; }"}
{"question": "def server_idle_suicide_seconds(self): if self._server_idle_suicide_seconds is None: return YCMD_DEFAULT_SERVER_IDLE_SUICIDE_SECONDS return self._server_idle_suicide_seconds", "answer": "public int getServerIdleSuicideSeconds() { if (this.serverIdleSuicideSeconds == null) { return YCMD_DEFAULT_SERVER_IDLE_SUICIDE_SECONDS; } return this.serverIdleSuicideSeconds; }"}
{"question": "def log_level(self, log_level): if log_level is not None and not isinstance(log_level, str): raise TypeError('log level must be a str: %r' % log_level) if log_level is not None and not _is_valid_log_level(log_level): logger.warning('log level unrecognized: %r', log_level) self._log_level = log_level", "answer": "public void setLogLevel(String logLevel) { if (logLevel != null && !(logLevel instanceof String)) { throw new IllegalArgumentException(\"log level must be a String: \" + logLevel); } if (logLevel != null && !_isValidLogLevel(logLevel)) { logger.warning(\"log level unrecognized: \" + logLevel); } this._logLevel = logLevel; }"}
{"question": "def stderr_log_path(self, stderr_log_path): if stderr_log_path is not None and not isinstance(stderr_log_path, str): raise TypeError( 'stderr_log_path must be a str: %r' % stderr_log_path ) self._stderr_log_path = stderr_log_path", "answer": "public void setStderrLogPath(String stderrLogPath) { if (stderrLogPath != null && !(stderrLogPath instanceof String)) { throw new IllegalArgumentException( String.format(\"stderr_log_path must be a String: %s\", stderrLogPath) ); } this.stderrLogPath = stderrLogPath; }"}
{"question": "def ycmd_module_directory(self): if self._ycmd_root_directory is None: logger.error('no ycmd root directory set') raise AttributeError return os.path.join(self._ycmd_root_directory, 'ycmd')", "answer": "public class YcmdConfig { private static final Logger logger = Logger.getLogger(YcmdConfig.class.getName()); private String ycmdRootDirectory; public String getYcmdModuleDirectory() { if (ycmdRootDirectory == null) { logger.severe(\"no ycmd root directory set\"); throw new IllegalStateException(\"ycmd root directory not set\"); } return new File(ycmdRootDirectory, \"ycmd\").getPath(); } public void setYcmdRootDirectory(String path) { this.ycmdRootDirectory = path; } }"}
{"question": "def opEnd(self, result): sys.stdout.write(result.ljust(20)) sys.stdout.write(\"\\n\")", "answer": "public void opEnd(String result) { System.out.print(String.format(\"%-20s\", result)); System.out.print(\"\\n\"); }"}
{"question": "def cmd(self, cmd, argA=0, argB=0): buffer = struct.pack(\"<LL\", argA, argB) self.serial.write(bytes([cmd])) self.serial.write(buffer) self.serial.flush()", "answer": "public class SerialDevice { private OutputStream serial; public SerialDevice(OutputStream serial) { this.serial = serial; } public void cmd(int cmd, long argA, long argB) throws IOException { ByteBuffer buffer = ByteBuffer.allocate(8); // 两个 4 字节的无符号长整型 buffer.order(ByteOrder.LITTLE_ENDIAN); buffer.putInt((int) argA); buffer.putInt((int) argB); serial.write(new byte[] { (byte) cmd }); serial.write(buffer.array()); serial.flush(); } }"}
{"question": "def flashInit(self): self.cmd(0x03) buffer = self.serial.read(4) return struct.unpack(\"<L\", buffer)[0]", "answer": "public class SerialDevice { private InputStream serial; public SerialDevice(InputStream serial) { this.serial = serial; } public long flashInit() throws IOException { cmd(0x03, 0, 0); byte[] buffer = new byte[4]; int readBytes = serial.read(buffer); if (readBytes != 4) { throw new IOException(\"Failed to read 4 bytes from serial\"); } ByteBuffer bb = ByteBuffer.wrap(buffer); bb.order(ByteOrder.LITTLE_ENDIAN); return bb.getInt() & 0xFFFFFFFFL; }"}
{"question": "def __init__(self, deadline='', *args, **kw_args): self.deadline = deadline super(ComplianceEvent, self).__init__(*args, **kw_args)", "answer": "public class ComplianceEvent extends BaseEvent { private String deadline; public ComplianceEvent(String deadline, Object... args) { this.deadline = deadline; superInit(args); }"}
{"question": "def create(self, request, *args, **kwargs): self.serializer_class = serializers.GameDataSerializer return super().create(request, *args, **kwargs)", "answer": "public class GameDataController extends BaseController { private Class<?> serializerClass; @Override public Response create(Request request, Object... args) { this.serializerClass = GameDataSerializer.class; return super.create(request, args); } }"}
{"question": "def matches(cls, python): if python not in cls._matches_cache: cls._matches_cache[python] = cls._matches(python) return cls._matches_cache[python]", "answer": "public class PythonMatcher { private static Map<String, Boolean> matchesCache = new ConcurrentHashMap<>(); public static boolean matches(String python) { if (!matchesCache.containsKey(python)) { matchesCache.put(python, _matches(python)); } return matchesCache.get(python); } private static boolean _matches(String python) { return python != null && !python.isEmpty(); } }"}
{"question": "def run(self, args, **kwargs): log.debug(\"Running '{0}' in {1}\".format(' '.join(args), self.name)) return self.run_executable('python', args, **kwargs)", "answer": "public class PythonRunner { private static final Logger log = Logger.getLogger(PythonRunner.class.getName()); private String name; public PythonRunner(String name) { this.name = name; } public int run(List<String> args, Object... kwargs) { log.fine(String.format(\"Running '%s' in %s\", String.join(\" \", args), name)); return runExecutable(\"python\", args, kwargs); } private int runExecutable(String executable, List<String> args, Object... kwargs) { return 0; } }"}
{"question": "def run_executable(self, executable, args, **kwargs): kwargs[\"env\"] = dict(kwargs.pop(\"env\", os.environ), PYTHONNOUSERSITE=str(\"True\")) return super(Conda, self).run_executable(executable, args, **kwargs)", "answer": "public class Conda extends BaseRunner { @Override public int runExecutable(String executable, List<String> args, Map<String, String> envVars) throws IOException, InterruptedException { ProcessBuilder pb = new ProcessBuilder(); pb.command().add(executable); pb.command().addAll(args); Map<String, String> env = pb.environment(); if (envVars != null) { env.putAll(envVars); } env.put(\"PYTHONNOUSERSITE\", \"True\"); Process process = pb.start(); return process.waitFor(); } }"}
{"question": "def getdict(self): if self.w_func_dict is None: self.w_func_dict = self.space.newdict() return self.w_func_dict", "answer": "public class FuncContainer { private Map<String, Object> wFuncDict; private Space space; public FuncContainer(Space space) { this.space = space; } public Map<String, Object> getDict() { if (wFuncDict == null) { wFuncDict = space.newDict(); } return wFuncDict; }"}
{"question": "def setdict(self, space, w_dict): if not space.is_true(space.isinstance(w_dict, space.w_dict)): raise OperationError(space.w_TypeError, space.wrap(\"setting function's dictionary to a non-dict\")) self.w_func_dict = w_dict", "answer": "public class FuncContainer { private Map<String, Object> wFuncDict; public void setDict(Space space, Object wDict) { if (!space.isTrue(space.isInstance(wDict, space.getWDict()))) { throw new OperationError( space.getWTypeError(), space.wrap(\"setting function's dictionary to a non-dict\") ); } this.wFuncDict = (Map<String, Object>) wDict; }"}
{"question": "def fget_func_defaults(space, self): values_w = self.defs_w if not values_w: return space.w_None return space.newtuple(values_w[:])", "answer": "public class FuncContainer { private List<Object> defsW; public Object fgetFuncDefaults(Space space) { if (defsW == null || defsW.isEmpty()) { return space.wNone(); } return space.newTuple(defsW); }"}
{"question": "def fget___module__(space, self): if self.w_module is None: if self.w_func_globals is not None and not space.is_w(self.w_func_globals, space.w_None): self.w_module = space.call_method(self.w_func_globals, \"get\", space.wrap(\"__name__\")) else: self.w_module = space.w_None return self.w_module", "answer": "public class FuncContainer { private Object wModule; private Object wFuncGlobals; public Object fgetModule(Space space) { if (wModule == null) { if (wFuncGlobals != null && !space.isW(wFuncGlobals, space.wNone())) { wModule = space.callMethod(wFuncGlobals, \"get\", space.wrap(\"__name__\")); } else { wModule = space.wNone(); } } return wModule; }"}
{"question": "def descr_method__new__(space, w_subtype, w_function, w_instance, w_class=None): if space.is_w(w_instance, space.w_None): w_instance = None method = space.allocate_instance(Method, w_subtype) Method.__init__(method, space, w_function, w_instance, w_class) return space.wrap(method)", "answer": "public class FuncContainer { public static Object descrMethodNew(Space space, Class<?> wSubtype, Object wFunction, Object wInstance, Object wClass) { if (space.isW(wInstance, space.wNone())) { wInstance = null; } Method method = space.allocateInstance(Method.class, wSubtype); method.init(space, wFunction, wInstance, wClass); return space.wrap(method); }"}
{"question": "def descr_method_hash(self): space = self.space w_result = space.hash(self.w_function) if self.w_instance is not None: w_result = space.xor(w_result, space.hash(self.w_instance)) return w_result", "answer": "public class MethodContainer { private Object wFunction; private Object wInstance; private Space space; public Object descrMethodHash() { Object wResult = space.hash(wFunction); if (wInstance != null) { wResult = space.xor(wResult, space.hash(wInstance)); } return wResult; } }"}
{"question": "def descr_classmethod_get(self, space, w_obj, w_klass=None): if space.is_w(w_klass, space.w_None): w_klass = space.type(w_obj) return space.wrap(Method(space, self.w_function, w_klass, space.w_None))", "answer": "public Object descrClassMethodGet(Space space, Object wObj, Object wKlass) { if (space.isW(wKlass, space.wNone())) { wKlass = space.type(wObj); } return space.wrap(new Method(space, wFunction, wKlass, space.wNone())); }"}
{"question": "def descr_builtinfunction__new__(space, w_subtype, w_func): func = space.interp_w(Function, w_func) bltin = space.allocate_instance(BuiltinFunction, w_subtype) BuiltinFunction.__init__(bltin, func) return space.wrap(bltin)", "answer": "public class BuiltinFunctionContainer { public static Object descrBuiltinFunctionNew(Space space, Class<?> wSubtype, Object wFunc) { Function func = space.interpW(Function.class, wFunc); BuiltinFunction bltin = space.allocateInstance(BuiltinFunction.class, wSubtype); bltin.init(func); return space.wrap(bltin); } }"}
{"question": "def timeit(self, number: int) -> float: if self._timeit_module is None: self._timeit_module = cpp_jit.compile_timeit_template( self._stmt, self._setup, ) return self._timeit_module.timeit(number)", "answer": "public class Timer { private TimeitModule timeitModule; private String stmt; private String setup; private CppJit cppJit; public Timer(String stmt, String setup, CppJit cppJit) { this.stmt = stmt; this.setup = setup; this.cppJit = cppJit; } public double timeit(int number) { if (timeitModule == null) { timeitModule = cppJit.compileTimeitTemplate(stmt, setup); } return timeitModule.timeit(number); } }"}
{"question": "def isUpperBoundClosed(self): if self.upperCut.point is None: raise TypeError(\"Range unbounded above\") else: return not self.upperCut.below", "answer": "public boolean isUpperBoundClosed() { if (upperCut.point == null) { throw new IllegalArgumentException(\"Range unbounded above\"); } else { return !upperCut.below; } }"}
{"question": "def isLowerBoundClosed(self): if self.lowerCut.point is None: raise TypeError(\"Range unbounded below\") else: return self.lowerCut.below", "answer": "public boolean isLowerBoundClosed() { if (lowerCut.point == null) { throw new IllegalArgumentException(\"Range unbounded below\"); } else { return lowerCut.below; } }"}
{"question": "def encloses(self, other): if not isinstance(other, Range): raise ValueError(\"Range required\") return (self.lowerCut <= other.lowerCut) and (self.upperCut >= other.upperCut)", "answer": "public boolean encloses(Range other) { if (other == null) { throw new IllegalArgumentException(\"Range required\"); } return (this.lowerCut.compareTo(other.lowerCut) <= 0) && (this.upperCut.compareTo(other.upperCut) >= 0); }"}
{"question": "class CAR: XTRAIL = \"NISSAN X-TRAIL 2017\" LEAF = \"NISSAN LEAF 2018\" LEAF_IC = \"NISSAN LEAF 2018 Instrument Cluster\" ROGUE = \"NISSAN ROGUE 2019\" ALTIMA = \"NISSAN ALTIMA 2020\"", "answer": "public class CAR { public static final String XTRAIL = \"NISSAN X-TRAIL 2017\"; public static final String LEAF = \"NISSAN LEAF 2018\"; public static final String LEAF_IC = \"NISSAN LEAF 2018 Instrument Cluster\"; public static final String ROGUE = \"NISSAN ROGUE 2019\"; public static final String ALTIMA = \"NISSAN ALTIMA 2020\"; }"}
{"question": "def parse_response(self, response): self.__logger.debug('Saving file to download path: {}'.format(Settings.download_path)) with open(Settings.download_path, 'wb+') as f: for chunk in response.raw.stream(1024, decode_content=False): if chunk: f.write(chunk) self.__logger.debug('File saved successfully')", "answer": "public class ResponseParser { private static final Logger logger = Logger.getLogger(ResponseParser.class.getName()); public void parseResponse(Response response) throws IOException { logger.info(\"Saving file to download path: \" + Settings.DOWNLOAD_PATH); try (InputStream inputStream = response.getRawStream(); FileOutputStream outputStream = new FileOutputStream(Settings.DOWNLOAD_PATH)) { byte[] buffer = new byte[1024]; int bytesRead; while ((bytesRead = inputStream.read(buffer)) != -1) { outputStream.write(buffer, 0, bytesRead); } } logger.info(\"File saved successfully\"); } }"}
{"question": "def foward_features(self, features): bbox_list = self.bbox_head.get_bboxes(*features) bbox_results = [ bbox2result(det_bboxes, det_labels, self.bbox_head.num_classes) for det_bboxes, det_labels in bbox_list ] return bbox_results[0]", "answer": "public List<Map<String, Object>> forwardFeatures(List<Object> features) { List<List<Object>> bboxList = this.bboxHead.getBboxes(features); List<Map<String, Object>> bboxResults = new ArrayList<>(); for (List<Object> bboxItem : bboxList) { List<Object> detBboxes = (List<Object>) bboxItem.get(0); List<Integer> detLabels = (List<Integer>) bboxItem.get(1); Map<String, Object> result = bbox2result(detBboxes, detLabels, this.bboxHead.getNumClasses()); bboxResults.add(result); } return bboxResults.isEmpty() ? new ArrayList<>() : Arrays.asList(bboxResults.get(0)); } private Map<String, Object> bbox2result(List<Object> detBboxes, List<Integer> detLabels, int numClasses) { Map<String, Object> result = new HashMap<>(); result.put(\"bboxes\", detBboxes); result.put(\"labels\", detLabels); result.put(\"num_classes\", numClasses); return result; }"}
{"question": "def test_metering_agent_host_value(self): expected_host = 'my agent' self.assertEqual(expected_host, self.agent.host)", "answer": "public class MeteringAgentTest { private MeteringAgent agent = new MeteringAgent(); @Test public void testMeteringAgentHostValue() { String expectedHost = \"my agent\"; assertEquals(expectedHost, agent.getHost()); } }"}
{"question": "def test_add_metering_label_with_bad_driver_impl(self): del self.driver.add_metering_label with mock.patch.object(metering_agent, 'LOG') as log: self.agent.add_metering_label(None, ROUTERS) log.exception.assert_called_with( mock.ANY, {'driver': 'noop', 'func': 'add_metering_label'} )", "answer": "public class MeteringAgentTest { @Test public void testAddMeteringLabelWithBadDriverImpl() { Driver driver = mock(Driver.class); doThrow(new UnsupportedOperationException()).when(driver).addMeteringLabel(any(), any()); MeteringAgent agent = new MeteringAgent(driver); try (MockedStatic<MeteringAgentLogger> logMock = mockStatic(MeteringAgentLogger.class)) { agent.addMeteringLabel(null, ROUTERS); logMock.verify(() -> MeteringAgentLogger.exception( any(), eq(Map.of(\"driver\", \"noop\", \"func\", \"add_metering_label\")) )); } } }"}
{"question": "def test_init_chain(self): with mock.patch( 'oslo_service.periodic_task.PeriodicTasks.__init__' ) as init: metering_agent.MeteringAgent('my agent', cfg.CONF) init.assert_called_once_with(cfg.CONF)", "answer": "public class MeteringAgentTest { @Test public void testInitChain() throws Exception { PeriodicTasks periodicTasksMock = mock(PeriodicTasks.class); MeteringAgent agent = new MeteringAgent(\"my agent\", Config.CONF); verify(periodicTasksMock, times(1)).init(Config.CONF); }"}
{"question": "def GetStatusCode(host, path=\"/\"): try: conn = HTTPConnection(host) conn.request(\"HEAD\", path) return conn.getresponse().status except Exception: return None", "answer": "public class HttpUtils { public static Integer getStatusCode(String host, String path) { if (path == null) { path = \"/\"; } try { URL url = new URL(\"http://\" + host + path); HttpURLConnection conn = (HttpURLConnection) url.openConnection(); conn.setRequestMethod(\"HEAD\"); conn.connect(); return conn.getResponseCode(); } catch (Exception e) { return null; } } }"}
{"question": "def WaitOK(host, path=\"/\"): while GetStatusCode(host, path) != 200: sleep(5)", "answer": "public static void waitOK(String host, String path) { if (path == null) path = \"/\"; while (getStatusCode(host, path) != 200) { try { Thread.sleep(5000); } catch (InterruptedException e) { Thread.currentThread().interrupt(); } } }"}
{"question": "def load_adjustments(self, columns, dts, assets): out = [None] * len(columns) for i, column in enumerate(columns): adjs = {} for asset in assets: adjs.update(self._get_adjustments_in_range(asset, dts, column)) out[i] = adjs return out", "answer": "public class AdjustmentsLoader { public List<Map<String, Object>> loadAdjustments(List<String> columns, List<Date> dts, List<String> assets) { List<Map<String, Object>> out = new ArrayList<>(columns.size()); for (int i = 0; i < columns.size(); i++) { String column = columns.get(i); Map<String, Object> adjs = new HashMap<>(); for (String asset : assets) { adjs.putAll(getAdjustmentsInRange(asset, dts, column)); } out.add(adjs); } return out; }"}
{"question": "def __init__(self, trading_calendar, asset_finder, bar_reader, roll_finders, frequency): self._trading_calendar = trading_calendar self._asset_finder = asset_finder self._bar_reader = bar_reader self._roll_finders = roll_finders self._frequency = frequency", "answer": "public class DataPortal { private TradingCalendar tradingCalendar; private AssetFinder assetFinder; private BarReader barReader; private RollFinders rollFinders; private Frequency frequency; public DataPortal(TradingCalendar tradingCalendar, AssetFinder assetFinder, BarReader barReader, RollFinders rollFinders, Frequency frequency) { this.tradingCalendar = tradingCalendar; this.assetFinder = assetFinder; this.barReader = barReader; this.rollFinders = rollFinders; this.frequency = frequency; } }"}
{"question": "def load_adjustments(self, columns, dts, assets): out = [None] * len(columns) for i, column in enumerate(columns): adjs = {} for asset in assets: adjs.update(self._get_adjustments_in_range(asset, dts, column)) out[i] = adjs return out", "answer": "public class AdjustmentLoader { public List<Map<String, Object>> loadAdjustments( List<String> columns, List<Date> dts, List<String> assets) { List<Map<String, Object>> out = new ArrayList<>(); for (int i = 0; i < columns.size(); i++) { String column = columns.get(i); Map<String, Object> adjs = new HashMap<>(); for (String asset : assets) { adjs.putAll(getAdjustmentsInRange(asset, dts, column)); } out.add(adjs); } return out; }"}
{"question": "def _array(self, dts, assets, field): return self._reader.load_raw_arrays( [field], dts[0], dts[-1], assets )[0]", "answer": "public Object[] array(List<Date> dts, List<Asset> assets, String field) { return reader.loadRawArrays( Collections.singletonList(field), dts.get(0), dts.get(dts.size() - 1), assets )[0]; }"}
{"question": "def _calendar(self): mm = self.trading_calendar.all_minutes start = mm.searchsorted(self._reader.first_trading_day) end = mm.searchsorted(self._reader.last_available_dt, side='right') return mm[start:end]", "answer": "public class CalendarHelper { public static long[] getCalendar(TradingCalendar tradingCalendar, BarReader reader) { long[] allMinutes = tradingCalendar.getAllMinutes(); int start = searchSorted(allMinutes, reader.getFirstTradingDay(), false); int end = searchSorted(allMinutes, reader.getLastAvailableDt(), true); return Arrays.copyOfRange(allMinutes, start, end); } private static int searchSorted(long[] array, long value, boolean sideRight) { int low = 0; int high = array.length; while (low < high) { int mid = (low + high) >>> 1; if (array[mid] < value || (sideRight && array[mid] == value)) { low = mid + 1; } else { high = mid; } } return low; } }"}
{"question": "def _command(self, command, **kwargs): params = kwargs params.update({'command': command, 'sessionkey': self.sessionkey}) res = requests.get(self.url, params=params) return res", "answer": "public class MyClass { private String sessionKey; private String url; public HttpURLConnection command(String command, Map<String, String> kwargs) throws IOException { kwargs.put(\"command\", command); kwargs.put(\"sessionkey\", this.sessionKey); String query = kwargs.entrySet() .stream() .map(entry -> entry.getKey() + \"=\" + entry.getValue()) .collect(Collectors.joining(\"&\")); URL fullUrl = new URL(this.url + \"?\" + query); HttpURLConnection conn = (HttpURLConnection) fullUrl.openConnection(); conn.setRequestMethod(\"GET\"); return conn; } }"}
{"question": "class Migration(migrations.Migration): dependencies = [ ('catalog', '0002_tag'), ] operations = [ migrations.AddField( model_name='item', name='tags', field=models.ManyToManyField( related_name='items', to='catalog.Tag', verbose_name='Теги' ), ), ]", "answer": "public class Migration extends MigrationsMigration { public void dependencies() { addDependency(\"catalog\", \"0002_tag\"); } public void operations() { addField( \"item\", \"tags\", new ManyToManyField() .relatedName(\"items\") .to(\"catalog.Tag\") .verboseName(\"Теги\") ); } }"}
{"question": "def _read_task_logs(self, stream): while True: line = stream.readline() if isinstance(line, bytes): line = line.decode('utf-8') if not line: break self.log.info( 'Job %s: Subtask %s %s', self._task_instance.job_id, self._task_instance.task_id, line.rstrip('\\n') )", "answer": "public void readTaskLogs(InputStream stream) throws IOException { BufferedReader reader = new BufferedReader(new InputStreamReader(stream, StandardCharsets.UTF_8)); String line; while ((line = reader.readLine()) != null) { log.info(String.format( \"Job %s: Subtask %s %s\", this.taskInstance.getJobId(), this.taskInstance.getTaskId(), line )); } }"}
{"question": "def on_finish(self) -> None: if self._cfg_path and os.path.isfile(self._cfg_path): if self.run_as_user: subprocess.call(['sudo', 'rm', self._cfg_path], close_fds=True) else: os.remove(self._cfg_path) try: self._error_file.close() except FileNotFoundError: pass", "answer": "public void onFinish() { if (this.cfgPath != null && new File(this.cfgPath).exists()) { if (this.runAsUser) { try { ProcessBuilder pb = new ProcessBuilder(\"sudo\", \"rm\", this.cfgPath); pb.inheritIO(); Process process = pb.start(); process.waitFor(); } catch (IOException | InterruptedException e) { e.printStackTrace(); } } else { new File(this.cfgPath).delete(); } } if (this.errorFile != null) { try { this.errorFile.close(); } catch (FileNotFoundException e) { } catch (IOException e) { e.printStackTrace(); } } }"}
{"question": "class Config: SECRET_KEY = os.environ.get('SECRET_KEY') SQLALCHEMY_DATABASE_URI = 'postgresql+psycopg2://fidel:fidel@localhost/blog' UPLOADED_PHOTOS_DEST = 'app/static/photos' QUOTES_URL = 'http://quotes.stormconsultancy.co.uk/random.json' MAIL_SERVER = 'smtp.googlemail.com' MAIL_PORT = 587 MAIL_USE_TLS = True MAIL_USERNAME = os.environ.get(\"MAIL_USERNAME\") MAIL_PASSWORD = os.environ.get(\"MAIL_PASSWORD\")", "answer": "public class Config { public static final String SECRET_KEY = System.getenv(\"SECRET_KEY\"); public static final String SQLALCHEMY_DATABASE_URI = \"postgresql+psycopg2://fidel:fidel@localhost/blog\"; public static final String UPLOADED_PHOTOS_DEST = \"app/static/photos\"; public static final String QUOTES_URL = \"http://quotes.stormconsultancy.co.uk/random.json\"; public static final String MAIL_SERVER = \"smtp.googlemail.com\"; public static final int MAIL_PORT = 587; public static final boolean MAIL_USE_TLS = true; public static final String MAIL_USERNAME = System.getenv(\"MAIL_USERNAME\"); public static final String MAIL_PASSWORD = System.getenv(\"MAIL_PASSWORD\"); }"}
{"question": "def update(self): self.data.update() event = copy.deepcopy(self.data.event) if event is None: self._event = event return event = calculate_offset(event, OFFSET) self._offset_reached = is_offset_reached(event) self._event = event", "answer": "public void update() { this.data.update(); Event event = this.data.getEvent() != null ? this.data.getEvent().deepCopy() : null; if (event == null) { this._event = event; return; } event = calculateOffset(event, OFFSET); this._offsetReached = isOffsetReached(event); this._event = event; }"}
{"question": "def format_dates(self, event): event[\"start\"] = self.get_date_formatted(event[\"start\"], event[\"all_day\"]) event[\"end\"] = self.get_date_formatted(event[\"end\"], event[\"all_day\"]) return event", "answer": "public Map<String, Object> formatDates(Map<String, Object> event) { event.put(\"start\", getDateFormatted(event.get(\"start\"), (Boolean) event.get(\"all_day\"))); event.put(\"end\", getDateFormatted(event.get(\"end\"), (Boolean) event.get(\"all_day\"))); return event; }"}
{"question": "def get_date_formatted(self, dt, is_all_day): if is_all_day: return dt.strftime(\"%Y-%m-%d\") return dt.strftime(\"%Y-%m-%dT%H:%M:%S.%f%z\")", "answer": "public class DateFormatter { public static String getDateFormatted(ZonedDateTime dt, boolean isAllDay) { if (isAllDay) { return dt.format(DateTimeFormatter.ofPattern(\"yyyy-MM-dd\")); } else { return dt.format(DateTimeFormatter.ofPattern(\"yyyy-MM-dd'T'HH:mm:ss.SSSZ\")); } } }"}
{"question": "def get_imageId_from_fileName(filename, id_iter): filename = os.path.splitext(filename)[0] if filename.isdigit(): return int(filename) return id_iter", "answer": "public class ImageUtils { public static int getImageIdFromFileName(String filename, int idIter) { String nameWithoutExt = filename.contains(\".\") ? filename.substring(0, filename.lastIndexOf('.')) : filename; if (nameWithoutExt.matches(\"\\\\d+\")) { return Integer.parseInt(nameWithoutExt); } return idIter; } }"}
{"question": "def anno_parser(annos_str): annos = [] for anno_str in annos_str: anno = list(map(int, anno_str.strip().split(','))) annos.append(anno) return annos", "answer": "public class AnnotationParser { public static List<List<Integer>> annoParser(List<String> annosStr) { List<List<Integer>> annos = new ArrayList<>(); for (String annoStr : annosStr) { String[] parts = annoStr.trim().split(\",\"); List<Integer> anno = new ArrayList<>(); for (String part : parts) { anno.add(Integer.parseInt(part)); } annos.add(anno); } return annos; } }"}
{"question": "def load_time_difference(self, params={}): serverTime = self.fetch_time(params) after = self.milliseconds() self.options['timeDifference'] = after - serverTime return self.options['timeDifference']", "answer": "public long loadTimeDifference(Map<String, Object> params) { long serverTime = fetchTime(params); long after = milliseconds(); this.options.put(\"timeDifference\", after - serverTime); return (Long) this.options.get(\"timeDifference\"); }"}
{"question": "def parse_order_status(self, status): statuses = { 'NEW': 'open', 'PARTIALLY_FILLED': 'open', 'FILLED': 'closed', 'CANCELED': 'canceled', 'PENDING_CANCEL': 'canceling', 'REJECTED': 'rejected', 'EXPIRED': 'expired', } return self.safe_string(statuses, status, status)", "answer": "public String parseOrderStatus(String status) { Map<String, String> statuses = new HashMap<>(); statuses.put(\"NEW\", \"open\"); statuses.put(\"PARTIALLY_FILLED\", \"open\"); statuses.put(\"FILLED\", \"closed\"); statuses.put(\"CANCELED\", \"canceled\"); statuses.put(\"PENDING_CANCEL\", \"canceling\"); statuses.put(\"REJECTED\", \"rejected\"); statuses.put(\"EXPIRED\", \"expired\"); return statuses.getOrDefault(status, status); }"}
{"question": "def create_reduce_only_order(self, symbol, type, side, amount, price=None, params={}): request = { 'reduceOnly': True, } return self.create_order(symbol, type, side, amount, price, self.extend(request, params))", "answer": "public Order createReduceOnlyOrder(String symbol, String type, String side, double amount, Double price, Map<String, Object> params) { Map<String, Object> request = new HashMap<>(); request.put(\"reduceOnly\", true); return createOrder(symbol, type, side, amount, price, extend(request, params)); }"}
{"question": "def fetch_closed_orders(self, symbol=None, since=None, limit=None, params={}): orders = self.fetch_orders(symbol, since, limit, params) return self.filter_by(orders, 'status', 'closed')", "answer": "public List<Order> fetchClosedOrders(String symbol, Long since, Integer limit, Map<String, Object> params) { List<Order> orders = fetchOrders(symbol, since, limit, params); return filterBy(orders, \"status\", \"closed\"); }"}
{"question": "def parse_incomes(self, incomes, market=None, since=None, limit=None): result = [] for i in range(len(incomes)): entry = incomes[i] parsed = self.parse_income(entry, market) result.append(parsed) sorted_result = self.sort_by(result, 'timestamp') return self.filter_by_since_limit(sorted_result, since, limit)", "answer": "public List<Income> parseIncomes(List<Income> incomes, Market market, Long since, Integer limit) { List<Income> result = new ArrayList<>(); for (Income entry : incomes) { Income parsed = parseIncome(entry, market); result.add(parsed); } List<Income> sortedResult = sortBy(result, \"timestamp\"); return filterBySinceLimit(sortedResult, since, limit); }"}
{"question": "def parse_trading_fee(self, fee, market=None): marketId = self.safe_string(fee, 'symbol') symbol = self.safe_symbol(marketId) return { 'info': fee, 'symbol': symbol, 'maker': self.safe_number(fee, 'makerCommission'), 'taker': self.safe_number(fee, 'takerCommission'), }", "answer": "public Map<String, Object> parseTradingFee(Map<String, Object> fee, Market market) { String marketId = safeString(fee, \"symbol\"); String symbol = safeSymbol(marketId); Map<String, Object> result = new HashMap<>(); result.put(\"info\", fee); result.put(\"symbol\", symbol); result.put(\"maker\", safeNumber(fee, \"makerCommission\")); result.put(\"taker\", safeNumber(fee, \"takerCommission\")); return result; }"}
{"question": "def fetch_trading_fee(self, symbol, params={}): self.load_markets() market = self.market(symbol) request = { 'symbol': market['id'], } response = self.sapiGetAssetTradeFee(self.extend(request, params)) first = self.safe_value(response, 0, {}) return self.parse_trading_fee(first)", "answer": "public Map<String, Object> fetchTradingFee(String symbol, Map<String, Object> params) throws Exception { this.loadMarkets(); Map<String, Object> market = this.market(symbol); Map<String, Object> request = new HashMap<>(); request.put(\"symbol\", market.get(\"id\")); List<Map<String, Object>> response = this.sapiGetAssetTradeFee(this.extend(request, params)); Map<String, Object> first = response.isEmpty() ? new HashMap<>() : response.get(0); return this.parseTradingFee(first, null); }"}
{"question": "def set_margin_mode(self, marginType, symbol=None, params={}): marginType = marginType.upper() if marginType != 'ISOLATED' and marginType != 'CROSSED': raise BadRequest(self.id + ' marginType must be either isolated or crossed') self.load_markets() market = self.market(symbol) method = None if market['linear']: method = 'fapiPrivatePostMarginType' elif market['inverse']: method = 'dapiPrivatePostMarginType' else: raise NotSupported(self.id + ' setMarginMode() supports linear and inverse contracts only') request = { 'symbol': market['id'], 'marginType': marginType, } return getattr(self, method)(self.extend(request, params))", "answer": "public Object setMarginMode(String marginType, String symbol, Map<String, Object> params) throws Exception { marginType = marginType.toUpperCase(); if (!marginType.equals(\"ISOLATED\") && !marginType.equals(\"CROSSED\")) { throw new BadRequest(this.id + \" marginType must be either isolated or crossed\"); } this.loadMarkets(); Map<String, Object> market = this.market(symbol); String method = null; if ((boolean) market.get(\"linear\")) { method = \"fapiPrivatePostMarginType\"; } else if ((boolean) market.get(\"inverse\")) { method = \"dapiPrivatePostMarginType\"; } else { throw new NotSupported(this.id + \" setMarginMode() supports linear and inverse contracts only\"); } Map<String, Object> request = new HashMap<>(); request.put(\"symbol\", market.get(\"id\")); request.put(\"marginType\", marginType); Map<String, Object> extendedRequest = this.extend(request, params); return this.invokeMethodByName(method, extendedRequest); }"}
{"question": "def request(self, path, api='public', method='GET', params=None, headers=None, body=None, config=None, context=None): if params is None: params = {} if config is None: config = {} if context is None: context = {} response = self.fetch2(path, api, method, params, headers, body, config, context) if api == 'private' or api == 'wapi': self.options['hasAlreadyAuthenticatedSuccessfully'] = True return response", "answer": "public Object request(String path, String api, String method, Map<String, Object> params, Map<String, String> headers, String body, Map<String, Object> config, Map<String, Object> context) throws Exception { if (params == null) { params = new HashMap<>(); } if (config == null) { config = new HashMap<>(); } if (context == null) { context = new HashMap<>(); } Object response = fetch2(path, api, method, params, headers, body, config, context); if (\"private\".equals(api) || \"wapi\".equals(api)) { this.options.put(\"hasAlreadyAuthenticatedSuccessfully\", true); } return response; }"}
{"question": "def init(self, context): super(SetTransformNode, self).init(context) self.add_input('ArmNodeSocketAction', 'In') self.add_input('ArmNodeSocketObject', 'Object') self.add_input('NodeSocketShader', 'Transform') self.add_output('ArmNodeSocketAction', 'Out')", "answer": "public void init(Context context) { super.init(context); this.addInput(\"ArmNodeSocketAction\", \"In\"); this.addInput(\"ArmNodeSocketObject\", \"Object\"); this.addInput(\"NodeSocketShader\", \"Transform\"); this.addOutput(\"ArmNodeSocketAction\", \"Out\"); }"}
{"question": "def test_verify_plugin_version_success(self, mock_subprocess): result = mock_subprocess.run() result.stdout = b\"9.8.3\" self.assertTrue(verify_plugin_version(\"9.8.3\"))", "answer": "public void testVerifyPluginVersionSuccess() throws Exception { ProcessResult result = mockSubprocess.run(); result.stdout = \"9.8.3\".getBytes(); assertTrue(verifyPluginVersion(\"9.8.3\")); }"}
{"question": "def test_verify_plugin_version_fail(self, mock_subprocess): with self.assertLogs(\"ssmpfwd.helpers\", level=\"INFO\") as cm: result = mock_subprocess.run() result.stdout = b\"1.8.1\" self.assertFalse(verify_plugin_version(\"9.2.3\")) self.assertEqual( cm.output[0], \"ERROR:ssmpfwd.helpers:session-manager-plugin version 1.8.1 is installed, 9.2.3 is required\" ) }", "answer": "public void testVerifyPluginVersionFail() throws Exception { try (MockedStatic<Subprocess> mockSubprocess = Mockito.mockStatic(Subprocess.class)) { SubprocessResult result = Mockito.mock(SubprocessResult.class); Mockito.when(result.getStdout()).thenReturn(\"1.8.1\"); mockSubprocess.when(() -> Subprocess.run()).thenReturn(result); boolean isValid = Helpers.verifyPluginVersion(\"9.2.3\"); assertFalse(isValid); String expectedLog = \"ERROR:ssmpfwd.helpers:session-manager-plugin version 1.8.1 is installed, 9.2.3 is required\"; assertEquals(expectedLog, LogCapture.getLastLog()); } }"}
{"question": "def setUp(self): @time_decorator def test_func(): self.sleep(0.5) self.time_decorated_method = test_func", "answer": "public void setUp() { Runnable testFunc = timeDecorator(() -> { try { Thread.sleep(500); } catch (InterruptedException e) { e.printStackTrace(); } }); this.timeDecoratedMethod = testFunc; }"}
{"question": "def test_time_decorator(self): with self.assertLogs(\"ssmpfwd.helpers\", level=\"INFO\") as cm: self.time_decorated_method() self.assertEqual(cm.output[0], \"INFO:ssmpfwd.helpers:[*] starting test_func\")", "answer": "public void testTimeDecorator() { try (TestLogger logger = new TestLogger(\"ssmpfwd.helpers\", Level.INFO)) { this.timeDecoratedMethod.run(); assertEquals( \"INFO:ssmpfwd.helpers:[*] starting test_func\", logger.getOutput().get(0) ); } }"}
{"question": "def main(): resp = MessagingResponse() resp.message(\"You have reached the DogBot. Thanks for contacting us :)\") return str(resp)", "answer": "public String main() { MessagingResponse resp = new MessagingResponse(); resp.message(\"You have reached the DogBot. Thanks for contacting us :)\"); return resp.toString(); }"}
{"question": "class ObjectType(IntEnum): Opaque = 0x01 AuthenticationKey = 0x02 AsymmetricKey = 0x03 WrapKey = 0x04 HmacKey = 0x05 Template = 0x06 OtpAeadKey = 0x07", "answer": "public enum ObjectType { Opaque(0x01), AuthenticationKey(0x02), AsymmetricKey(0x03), WrapKey(0x04), HmacKey(0x05), Template(0x06), OtpAeadKey(0x07); private final int value; ObjectType(int value) { this.value = value; } public int getValue() { return value; } }"}
{"question": "def test_reactive_servable_title(): doc = Document() session_context = unittest.mock.Mock() with patch_curdoc(doc): doc._session_context = lambda: session_context ReactiveHTML().servable(title='A') ReactiveHTML().servable(title='B') assert doc.title == 'B'", "answer": "public void testReactiveServableTitle() { Document doc = new Document(); SessionContext sessionContext = mock(SessionContext.class); try (PatchCurDoc patch = new PatchCurDoc(doc)) { doc.setSessionContext(() -> sessionContext); new ReactiveHTML().servable(\"A\"); new ReactiveHTML().servable(\"B\"); } assertEquals(\"B\", doc.getTitle()); }"}
{"question": "def test_link(): class ReactiveLink(Reactive): a = param.Parameter() obj = ReactiveLink() obj2 = ReactiveLink() obj.link(obj2, a='a') obj.a = 1 assert obj.a == 1 assert obj2.a == 1", "answer": "public void testLink() { class ReactiveLink extends Reactive { public Parameter a = new Parameter(); } ReactiveLink obj = new ReactiveLink(); ReactiveLink obj2 = new ReactiveLink(); obj.link(obj2, \"a\", \"a\"); obj.a.setValue(1); assertEquals(1, obj.a.getValue()); assertEquals(1, obj2.a.getValue()); }"}
{"question": "def test_param_rename(): class ReactiveRename(Reactive): a = param.Parameter() _rename = {'a': 'b'} obj = ReactiveRename() params = obj._process_property_change({'b': 1}) assert params == {'a': 1} properties = obj._process_param_change({'a': 1}) assert properties == {'b': 1}", "answer": "public void testParamRename() { class ReactiveRename extends Reactive { public Parameter a = new Parameter(); public Map<String, String> _rename = Map.of(\"a\", \"b\"); } ReactiveRename obj = new ReactiveRename(); Map<String, Object> params = obj._processPropertyChange(Map.of(\"b\", 1)); assertEquals(Map.of(\"a\", 1), params); Map<String, Object> properties = obj._processParamChange(Map.of(\"a\", 1)); assertEquals(Map.of(\"b\", 1), properties); }"}
