{"question": "def grid_scan (self) : base = self.tree.getroot () for section in base.findall (\".//%s\" % tag (\"div\")) : if section.get ('id') == 'maincontent' : break grid = section.find (\".//%s\" % tag (\"table\")) if grid is None : return for table_row in grid : if table_row [0].tag == tag ('th') : continue yield (self.tree.get_text (item) for item in table_row)", "answer": "public class GridAnalyzer { private Document document; public GridAnalyzer(Document document) { this.document = document; } public List<List<String>> gridScan() { List<List<String>> output = new ArrayList<>(); Element primarySection = document.selectFirst(\"div#maincontent\"); if (primarySection == null) { return output; } Element grid = primarySection.selectFirst(\"table\"); if (grid == null) { return output; } for (Element tableRow : grid.select(\"tr\")) { Elements headerCells = tableRow.select(\"th\"); if (!headerCells.isEmpty()) { continue; } List<String> line = new ArrayList<>(); for (Element cell : tableRow.select(\"td\")) { line.add(cell.text()); } output.add(line); } return output; } }"}
{"question": "def process (self) : self.connections = {} for row in self.grid_scan () : node, address, link_quality, neighbor_link_quality, etx_value = row link_quality, neighbor_link_quality, etx_value = (float (val) for val in (link_quality, neighbor_link_quality, etx_value)) self.connections [node] = [address, link_quality, neighbor_link_quality, etx_value]", "answer": "public class DataProcessor { private List<List<String>> inputData; private Map<String, List<Object>> connections; public DataProcessor(List<List<String>> inputData) { this.inputData = inputData; this.connections = new HashMap<>(); } public void process() { for (List<String> line : inputData) { if (line.size() != 5) continue; String node = line.get(0); String address = line.get(1); try { float linkQuality = Float.parseFloat(line.get(2)); float neighborLinkQuality = Float.parseFloat(line.get(3)); float etxValue = Float.parseFloat(line.get(4)); List<Object> entries = new ArrayList<>(); entries.add(address); entries.add(linkQuality); entries.add(neighborLinkQuality); entries.add(etxValue); connections.put(node, entries); } catch (NumberFormatException ex) { ex.printStackTrace(); } } } public Map<String, List<Object>> getConnections() { return connections; } }"}
{"question": "def restrict(image, ref_hash, num): comp_hash = compute_hash(image) difference = compare(ref_hash, comp_hash) if difference <= DIFF_LIMIT: if num >= THRESHOLD: return 'remove' else: return 'update_std' return 'continue'", "answer": "public static String restrict(Image image, String refHash, int num) { String compHash = computeHash(image); int difference = compare(refHash, compHash); if (difference <= DIFF_LIMIT) { if (num >= THRESHOLD) { return \"remove\"; } } else { return \"update_std\"; } return \"continue\"; }"}
{"question": "def scale(image): width = np.shape(image)[1] height = np.shape(image)[0] if width > TARGET_SIZE: ratio = TARGET_SIZE / width scaled_image = cv2.resize( image, (TARGET_SIZE, math.floor(height / ratio)), cv2.INTER_AREA) return scaled_image return image", "answer": "public class ImageScaler { private static final int TARGET_SIZE = 800; public static BufferedImage scale(BufferedImage image) { int width = image.getWidth(); int height = image.getHeight(); if (width > TARGET_SIZE) { double ratio = (double) TARGET_SIZE / width; int scaledHeight = (int) Math.floor(height * ratio); Image temp = image.getScaledInstance(TARGET_SIZE, scaledHeight, Image.SCALE_AREA_AVERAGING); BufferedImage scaled = new BufferedImage(TARGET_SIZE, scaledHeight, image.getType()); Graphics2D graphics = scaled.createGraphics(); graphics.drawImage(temp, 0, 0, null); graphics.dispose(); return scaled; } return image; } }"}
{"question": "class Space_Element(QWidget,Ui_Form): def __init__(self,parent=None,space_info=None): super(Space_Element,self).__init__(parent) self.setupUi(self) self.info = space_info self.configureSpaceInfo()", "answer": "public class SpaceElement extends JPanel { private SpaceInfo info; public SpaceElement(SpaceInfo spaceInfo) { this.info = spaceInfo; initializeUi(); configureSpaceInfo(); } private void initializeUi() { } private void configureSpaceInfo() { } }"}
{"question": "def log_exception_trace(cls, exception_trace_line): for segment in exception_trace_line.split(\"', '\"): for entry in segment.split(\"\\\\n\"): if entry: print(entry)", "answer": "public class ExceptionTraceLogger { public static void logExceptionTrace(String exceptionTraceLine) { String[] segments = exceptionTraceLine.split(\"', '\"); for (String segment : segments) { String[] entries = segment.split(\"\\\\\\\\n\"); for (String entry : entries) { if (!entry.isEmpty()) { System.out.println(entry); } } } } }"}
{"question": "def execute_app(self): try: self.initialize() self.native.ThreadException += self.windows_thread_error self.processor.run_continuously(self.app_ctx) except: # NOQA traceback.print_exc()", "answer": "public class ApplicationExecutor { private ApplicationContext appCtx; private NativeController nativeCtrl; private EventProcessor processor; public void executeApp() { try { initialize(); nativeCtrl.registerThreadExceptionHandler(this::windowsThreadError); processor.processContinuously(appCtx); } catch (Exception ex) { ex.printStackTrace(); } } private void initialize() { } private void windowsThreadError(Thread thread, Throwable error) { error.printStackTrace(); } }"}
{"question": "def _setup_application_actions(self): self.interface.actions.add( toga.Command( lambda widget: self.load_document, label='Open...', shortcut=Key.MOD_1 + 'o', group=toga.Group.FILE, section=0 ) )", "answer": "public class ApplicationActions { private JMenuBar menuBar; public ApplicationActions(JMenuBar menuBar) { this.menuBar = menuBar; setupApplicationActions(); } private void setupApplicationActions() { JMenu fileMenu = new JMenu(\"File\"); JMenuItem openOption = new JMenuItem(\"Open...\"); openOption.setAccelerator(KeyStroke.getKeyStroke('O', Toolkit.getDefaultToolkit().getMenuShortcutKeyMaskEx())); openOption.addActionListener(new ActionListener() { @Override public void actionPerformed(ActionEvent evt) { loadDocument(); } }); fileMenu.add(openOption); menuBar.add(fileMenu); } private void loadDocument() { System.out.println(\"Open file triggered\"); } }"}
{"question": "def attribute_selection_variance(X, limit): selector = VarianceThreshold(threshold=limit) X_chosen = selector.fit_transform(X) filter = selector.get_support() return X_chosen, filter", "answer": "public class AttributeSelector { public static class Outcome { public double[][] XChosen; public boolean[] filter; public Outcome(double[][] XChosen, boolean[] filter) { this.XChosen = XChosen; this.filter = filter; } } public static Outcome attributeSelectionVariance(double[][] X, double limit) { int sampleCount = X.length; int attributeCount = X[0].length; boolean[] filter = new boolean[attributeCount]; int chosenCount = 0; for (int j = 0; j < attributeCount; j++) { double average = 0; for (int i = 0; i < sampleCount; i++) { average += X[i][j]; } average /= sampleCount; double variance = 0; for (int i = 0; i < sampleCount; i++) { variance += (X[i][j] - average) * (X[i][j] - average); } variance /= sampleCount; if (variance > limit) { filter[j] = true; chosenCount++; } else { filter[j] = false; } } double[][] XChosen = new double[sampleCount][chosenCount]; for (int i = 0; i < sampleCount; i++) { int columnIndex = 0; for (int j = 0; j < attributeCount; j++) { if (filter[j]) { XChosen[i][columnIndex++] = X[i][j]; } } } return new Outcome(XChosen, filter); } }"}
{"question": "def init_hdf5(file_path, mode=\"w\", cam_type=\"davis\"): if mode == \"w\": dataset = h5py.File(file_path, mode=mode) dataset.create_group(\"dvs\") dataset.create_group(\"extra\") if cam_type == \"davis\": dataset.create_group(\"aps\") dataset.create_group(\"imu\") elif mode == \"r\": dataset = h5py.File(file_path, mode=mode) return dataset", "answer": "public class HDF5Initializer { public static H5File initHDF5(String filePath, String mode, String camType) throws Exception { H5File file; if (mode.equals(\"w\")) { file = new H5File(filePath, FileFormat.CREATE); file.open(); file.createGroup(\"dvs\", null); file.createGroup(\"extra\", null); if (camType.equals(\"davis\")) { file.createGroup(\"aps\", null); file.createGroup(\"imu\", null); } } else if (mode.equals(\"r\")) { file = new H5File(filePath, FileFormat.READ); file.open(); } else { throw new IllegalArgumentException(\"Unsupported mode: \" + mode); } return file; } }"}
{"question": "def ObtainRootAsDoubleValue(cls, buffer, position): index = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buffer, position) value = DoubleValue() value.Init(buffer, index + position) return value", "answer": "public class DoubleValueHelper { public static DoubleValue obtainRootAsDoubleValue(ByteBuffer buffer, int position) { int index = buffer.getInt(position); DoubleValue value = new DoubleValue(); value.__init(index + position, buffer); return value; } }"}
{"question": "def Accuracy(self): offset = flatbuffers.number_types.UOffsetTFlags.py_type( self._table.Offset(4) ) if offset != 0: return self._table.Get( flatbuffers.number_types.Int16Flags, offset + self._table.Pos ) return 0", "answer": "public class CustomTable extends Table { public short accuracy() { int offset = __offset(4); if (offset != 0) { return buffer.getShort(offset + buffer_pos); } return 0; } }"}
{"question": "def mean(self): total = float(self.total) if not self.window_length: return 0 return total / self.window_length / self.window_span", "answer": "public class RollingMean { private double total; private int windowLength; private double windowSpan; public double mean() { if (windowLength == 0) { return 0; } return total / windowLength / windowSpan; } }"}
{"question": "def identifiers(self): output = set() for id in self.controller.metrics: if id[:len(self._identifiers)] == self._identifiers: id = id[len(self._identifiers):] output.add(id[0] if id else '__value__') return output", "answer": "public class IdentifierController { private Controller controller; private String[] identifiers; public Set<String> identifiers() { Set<String> output = new HashSet<>(); for (String[] id : controller.metrics.keySet()) { if (beginsWith(id, this.identifiers)) { String[] subId = sliceArray(id, this.identifiers.length, id.length); if (subId.length > 0) { output.add(subId[0]); } else { output.add(\"__value__\"); } } } return output; } }"}
{"question": "def as_dictionary(self, retrieve_value=None): output = {} for key, value in iteritems(self): if isinstance(value, BasicCounter): if retrieve_value is not None: value = getattr(value, retrieve_value) output[key] = value else: output[key] = value.as_dictionary(retrieve_value) return output", "answer": "public class BasicCounter { public Map<String, Object> iterateEntries() { return new HashMap<>(); } public Map<String, Object> asDictionary(String retrieveValue) { Map<String, Object> output = new HashMap<>(); for (Map.Entry<String, Object> entry : iterateEntries().entrySet()) { String key = entry.getKey(); Object value = entry.getValue(); if (value instanceof BasicCounter) { if (retrieveValue != null) { try { value = value.getClass().getField(retrieveValue).get(value); } catch (Exception ex) { ex.printStackTrace(); value = null; } } output.put(key, value); } else if (value instanceof BasicCounter) { output.put(key, ((BasicCounter) value).asDictionary(retrieveValue)); } else { output.put(key, value); } } return output; } }"}
{"question": "def load_file(self, filepath): try: with open(filepath) as file_ptr: self.metrics = cPickle.load(file_ptr) except: logging.debug(\"cannot load metric from file: %s\" % filepath) return False return True", "answer": "public class MetricController { private static final Logger log = Logger.getLogger(MetricController.class.getName()); private Object metrics; public boolean loadFile(String filepath) { try (ObjectInputStream stream = new ObjectInputStream(new FileInputStream(filepath))) { metrics = stream.readObject(); return true; } catch (IOException | ClassNotFoundException ex) { log.log(Level.FINE, \"cannot load metric from file: \" + filepath, ex); return false; } } }"}
{"question": "def traverse(row, col): if row == len(matrix): return 0 if cache[row][col] == UNDEFINED: cache[row][col] = matrix[row][col] + max(traverse(row + 1, col), traverse(row + 1, col + 1)) return cache[row][col] return traverse(0, 0)", "answer": "public class TriangleMaximumRoute { private int[][] matrix; private int[][] cache; private static final int UNDEFINED = Integer.MIN_VALUE; public TriangleMaximumRoute(int[][] matrix) { this.matrix = matrix; this.cache = new int[matrix.length][matrix[0].length]; for (int row = 0; row < cache.length; row++) { for (int col = 0; col < cache[row].length; col++) { cache[row][col] = UNDEFINED; } } } public int maximumRouteSum() { return traverse(0, 0); } private int traverse(int row, int col) { if (row == matrix.length) { return 0; } if (cache[row][col] == UNDEFINED) { cache[row][col] = matrix[row][col] + Math.max(traverse(row + 1, col), traverse(row + 1, col + 1)); } return cache[row][col]; } }"}
{"question": "def kornia_color_perturbation_numpy(image, parameter): if parameter * 255 > 1: image = torch.from_numpy(image).permute(2,0,1).unsqueeze(0) image = ColorPerturbation(parameter, parameter, parameter, parameter)(image) image = image.squeeze(0).permute(1,2,0).numpy() return image", "answer": "public class ColorPerturbation { public static Mat korniaColorPerturbation(Mat image, float parameter) { if (parameter * 255 > 1) { Mat perturbed = image.clone(); double alpha = 1.0; double beta = (Math.random() * 2 - 1) * parameter * 255; perturbed.convertTo(perturbed, -1, alpha, beta); Mat hsv = new Mat(); Imgproc.cvtColor(perturbed, hsv, Imgproc.COLOR_RGB2HSV); List<Mat> hsvChannels = new ArrayList<>(); Core.split(hsv, hsvChannels); hsvChannels.get(1).convertTo(hsvChannels.get(1), -1, 1, (Math.random() * 2 - 1) * parameter * 255); Core.merge(hsvChannels, hsv); Imgproc.cvtColor(hsv, perturbed, Imgproc.COLOR_HSV2RGB); return perturbed; } return image; } }"}
{"question": "def initialize_random(self): if 'random_seed' in self.options.keys(): self.random = random.Random(self.options['random_seed']) else: self.random = random.Random()", "answer": "public class RandomInitializer { private Map<String, Object> options; private Random random; public void initializeRandom() { if (options.containsKey(\"random_seed\")) { long seed = ((Number) options.get(\"random_seed\")).longValue(); random = new Random(seed); } else { random = new Random(); } } }"}
{"question": "def obtain_random(self): value = self.random.random() if self.cosine_skew: return 1 - cos(value * pi / 2) else: return value", "answer": "public class RandomProducer { private Random random; private boolean cosineSkew; public double obtainRandom() { double value = random.nextDouble(); if (cosineSkew) { return 1 - Math.cos(value * Math.PI / 2); } else { return value; } } }"}
{"question": "def verify_hue_shift_threshold( quality_min, quality_max, expected, description): try: Tfda.JpegCompression( quality_lower=quality_min, quality_upper=quality_max) result = TestOutcome.PASS except ValueError: result = TestOutcome.FAIL assert expected == result, description", "answer": "public class JpegCompressionTest { enum TestOutcome { PASS, FAIL } public void verifyHueShiftThreshold(int qualityMin, int qualityMax, TestOutcome expected, String description) { TestOutcome result; try { Tfda.JpegCompression jpeg = new Tfda.JpegCompression(qualityMin, qualityMax); result = TestOutcome.PASS; } catch (IllegalArgumentException ex) { result = TestOutcome.FAIL; } assertEquals(expected, result, description); } @Test public void executeTest() { verifyHueShiftThreshold(10, 90, TestOutcome.PASS, \"Quality range valid\"); verifyHueShiftThreshold(-5, 105, TestOutcome.FAIL, \"Quality range invalid\"); } }"}
{"question": "def test_fg_exchange_quick(): background_data = np.ones(shape=[2, 5, 5, 3]) * -1 background_labels = np.random.rand(2) foreground = np.random.normal(loc=.5, scale=.1, size=[5, 5]) background_set = InMemoryDataset(background_data, background_labels) fg_exchange = ForegroundExchange(background_set, input_dim=(5, 5), normalize_bg=None) exchanged_single_channel = fg_exchange(foreground)[:, :, 0] assert np.array_equal((exchanged_single_channel <= -1), (foreground <= .5))", "answer": "public class ForegroundExchangeTest { @Test public void testFgExchangeQuick() { int batchSize = 2; int imgHeight = 5; int imgWidth = 5; int channelCount = 3; Random random = new Random(); Mat[] backgroundData = new Mat[batchSize]; for (int batchIdx = 0; batchIdx < batchSize; batchIdx++) { backgroundData[batchIdx] = new Mat(imgHeight, imgWidth, CvType.CV_32FC3); for (int row = 0; row < imgHeight; row++) { for (int col = 0; col < imgWidth; col++) { double[] values = new double[channelCount]; for (int chan = 0; chan < channelCount; chan++) { values[chan] = -1.0; } backgroundData[batchIdx].put(row, col, values); } } } double[] backgroundLabels = new double[batchSize]; for (int batchIdx = 0; batchIdx < batchSize; batchIdx++) { backgroundLabels[batchIdx] = random.nextDouble(); } Mat foreground = new Mat(imgHeight, imgWidth, CvType.CV_32F); for (int row = 0; row < imgHeight; row++) { for (int col = 0; col < imgWidth; col++) { foreground.put(row, col, 0.5 + 0.1 * random.nextGaussian()); } } InMemoryDataset backgroundSet = new InMemoryDataset(backgroundData, backgroundLabels); ForegroundExchange fgExchange = new ForegroundExchange(backgroundSet, new int[]{5, 5}, null); Mat exchanged = fgExchange.apply(foreground); Mat exchangedSingleChannel = new Mat(); Core.extractChannel(exchanged, exchangedSingleChannel, 0); for (int row = 0; row < imgHeight; row++) { for (int col = 0; col < imgWidth; col++) { double valExchanged = exchangedSingleChannel.get(row, col)[0]; double valForeground = foreground.get(row, col)[0]; assertEquals(valExchanged <= -1, valForeground <= 0.5); } } } }"}
{"question": "def test_foreground_exchange_numpy(): mnist_set = MNIST(DATA_PATH, download=True, train=True) cifar_set = CIFAR10(DATA_PATH, download=True, train=True) fg_exchange = ForegroundExchange(cifar_set, input_dim=(28, 28)) image = mnist_set.get_data()[0][0] image = fg_exchange(image)", "answer": "public class ForegroundExchangeTestJava { public void testForegroundExchangeNumpy() { MNISTDataset mnistSet = new MNISTDataset(\"data_path\", true); CIFAR10Dataset cifarSet = new CIFAR10Dataset(\"data_path\", true); ForegroundExchange fgExchange = new ForegroundExchange(cifarSet, new int[]{28, 28}, null); Mat image = mnistSet.getData().get(0); Mat output = fgExchange.apply(image); } }"}
{"question": "def test_keeps_remote_address_unchanged_without_real_ip(): remote_address = object() req = unittest.mock.MagicMock() req.META = {\"REMOTE_ADDR\": remote_address} handler.XRealIPHandler(get_reply)(req) assert req.META[\"REMOTE_ADDR\"] is remote_address", "answer": "public class XRealIPHandlerTest { @Test public void testKeepsRemoteAddressUnchangedWithoutRealIp() { Object remoteAddress = new Object(); Request req = Mockito.mock(Request.class); Map<String, Object> metadata = new HashMap<>(); metadata.put(\"REMOTE_ADDR\", remoteAddress); Mockito.when(req.getMetadata()).thenReturn(metadata); Handler handler = new XRealIPHandler(getReply()); handler.process(req); assertSame(remoteAddress, req.getMetadata().get(\"REMOTE_ADDR\")); } private Reply getReply() { return new Reply(); } public static class Request { private Map<String, Object> metadata; public Map<String, Object> getMetadata() { return metadata; } } public interface Handler { void process(Request request); } public static class XRealIPHandler implements Handler { private Reply reply; public XRealIPHandler(Reply reply) { this.reply = reply; } public void process(Request request) { } } public static class Reply {} }"}
{"question": "def test_replaces_x_real_ip_when_present(): remote_address = object() real_ip_header = object() req = unittest.mock.MagicMock() req.META = {\"REMOTE_ADDR\": remote_address, \"HTTP_X_REAL_IP\": real_ip_header} handler.XRealIPHandler(get_reply)(req) assert req.META[\"REMOTE_ADDR\"] is real_ip_header assert req.META[\"HTTP_X_REAL_IP\"] is real_ip_header", "answer": "public class XRealIPHandlerTest { @Test public void testReplacesXRealIpWhenPresent() { Object remoteAddress = new Object(); Object realIpHeader = new Object(); Request req = Mockito.mock(Request.class); Map<String, Object> metadata = new HashMap<>(); metadata.put(\"REMOTE_ADDR\", remoteAddress); metadata.put(\"HTTP_X_REAL_IP\", realIpHeader); Mockito.when(req.getMetadata()).thenReturn(metadata); Handler handler = new XRealIPHandler(getReply()); handler.process(req); assertSame(realIpHeader, req.getMetadata().get(\"REMOTE_ADDR\")); assertSame(realIpHeader, req.getMetadata().get(\"HTTP_X_REAL_IP\")); } private Reply getReply() { return new Reply(); } public static class Request { private Map<String, Object> metadata; public Map<String, Object> getMetadata() { return metadata; } } public interface Handler { void process(Request request); } public static class XRealIPHandler implements Handler { private Reply reply; public XRealIPHandler(Reply reply) { this.reply = reply; } public void process(Request request) { Map<String, Object> metadata = request.getMetadata(); if (metadata.containsKey(\"HTTP_X_REAL_IP\")) { metadata.put(\"REMOTE_ADDR\", metadata.get(\"HTTP_X_REAL_IP\")); } } } public static class Reply {} }"}
{"question": "class Announcer: def __init__(self, identifier): self.notification = directAnnounce.newCategory(identifier)", "answer": "public class Announcer { private NotificationCategory notification; public Announcer(String identifier) { this.notification = DirectAnnounce.newCategory(identifier); } public NotificationCategory getNotification() { return notification; } }"}
{"question": "def __init__(self): super().__init__(SCREEN_WIDTH, SCREEN_HEIGHT, SCREEN_TITLE) self.view = None self.ui_view = None self.points = 0", "answer": "public class PlayWindow extends BaseWindow { private Camera view; private Camera uiView; private int points; public PlayWindow() { super(SCREEN_WIDTH, SCREEN_HEIGHT, SCREEN_TITLE); this.view = null; this.uiView = null; this.points = 0; } }"}
{"question": "def initialize(self): self.view = arcade.Camera(self.width, self.height) self.ui_view = arcade.Camera(self.width, self.height) level_map = \":resources:tiled_maps/map.json\" layer_settings = { \"Platforms\": { \"use_spatial_hash\": True } }", "answer": "public void initialize() { this.view = new Camera(this.getWidth(), this.getHeight()); this.uiView = new Camera(this.getWidth(), this.getHeight()); String levelMap = \":resources:tiled_maps/map.json\"; Map<String, Map<String, Object>> layerSettings = new HashMap<>(); Map<String, Object> platformsSettings = new HashMap<>(); platformsSettings.put(\"use_spatial_hash\", true); layerSettings.put(\"Platforms\", platformsSettings); }"}
{"question": "def on_key_release(self, key, modifiers): if key == arcade.key.LEFT or key == arcade.key.A: self.gamer_image.move_x = 0 elif key == arcade.key.RIGHT or key == arcade.key.D: self.gamer_image.move_x = 0", "answer": "public class GamerInputReceiver extends KeyAdapter { private GamerImage gamerImage; public GamerInputReceiver(GamerImage gamerImage) { this.gamerImage = gamerImage; } @Override public void keyReleased(KeyEvent evt) { int key = evt.getKeyCode(); if (key == KeyEvent.VK_LEFT || key == KeyEvent.VK_A) { gamerImage.setMoveX(0); } else if (key == KeyEvent.VK_RIGHT || key == KeyEvent.VK_D) { gamerImage.setMoveX(0); } } }"}
{"question": "def ycmd_base_path(self): if self._ycmd_base_path is None: logger.warning('ycmd base path not configured') return self._ycmd_base_path", "answer": "public class YcmdController { private static final Logger log = Logger.getLogger(YcmdController.class.getName()); private String ycmdBasePath; public String getYcmdBasePath() { if (this.ycmdBasePath == null) { log.warning(\"ycmd base path not configured\"); } return this.ycmdBasePath; } public void setYcmdBasePath(String location) { this.ycmdBasePath = location; } }"}
{"question": "def ycmd_base_path(self, ycmd_base_path): if ycmd_base_path is not None and not isinstance(ycmd_base_path, str): raise TypeError(ycmd_base_path) self._ycmd_base_path = ycmd_base_path", "answer": "public class YcmdController { private String ycmdBasePath; public void setYcmdBasePath(String ycmdBasePath) { if (ycmdBasePath != null && !(ycmdBasePath instanceof String)) { throw new IllegalArgumentException(\"ycmdBasePath must be a String\"); } this.ycmdBasePath = ycmdBasePath; } public String getYcmdBasePath() { return this.ycmdBasePath; } }"}
{"question": "def ycmd_config_path(self): if self._ycmd_config_path is None: if self._ycmd_base_path is not None: return get_default_config_path(self._ycmd_base_path) logger.warning('ycmd base path not configured') return self._ycmd_config_path", "answer": "public class YcmdController { private static final Logger log = Logger.getLogger(YcmdController.class.getName()); private String ycmdBasePath; private String ycmdConfigPath; public String getYcmdConfigPath() { if (this.ycmdConfigPath == null) { if (this.ycmdBasePath != null) { return getDefaultConfigPath(this.ycmdBasePath); } log.warning(\"ycmd base path not configured\"); } return this.ycmdConfigPath; } private String getDefaultConfigPath(String basePath) { return basePath + \"/.ycmd/settings.json\"; } public void setYcmdBasePath(String location) { this.ycmdBasePath = location; } public void setYcmdConfigPath(String location) { this.ycmdConfigPath = location; } }"}
{"question": "def current_folder(self): if self._current_folder is None: return os.getcwd() return self._current_folder", "answer": "public class FolderManager { private String currentFolder; public String getCurrentFolder() { if (this.currentFolder == null) { return System.getProperty(\"user.dir\"); } return this.currentFolder; } public void setCurrentFolder(String location) { this.currentFolder = location; } }"}
{"question": "def python_executable_location(self): if self._python_executable_location is None: return default_python_executable_location() return self._python_executable_location", "answer": "public String getPythonExecutableLocation() { if (this.pythonExecutableLocation == null) { return defaultPythonExecutableLocation(); } return this.pythonExecutableLocation; }"}
{"question": "def server_inactive_termination_seconds(self): if self._server_inactive_termination_seconds is None: return YCMD_DEFAULT_SERVER_INACTIVE_TERMINATION_SECONDS return self._server_inactive_termination_seconds", "answer": "public int getServerInactiveTerminationSeconds() { if (this.serverInactiveTerminationSeconds == null) { return YCMD_DEFAULT_SERVER_INACTIVE_TERMINATION_SECONDS; } return this.serverInactiveTerminationSeconds; }"}
{"question": "def logging_level(self, logging_level): if logging_level is not None and not isinstance(logging_level, str): raise TypeError('logging level must be a str: %r' % logging_level) if logging_level is not None and not _is_valid_logging_level(logging_level): logger.warning('logging level unrecognized: %r', logging_level) self._logging_level = logging_level", "answer": "public void setLoggingLevel(String loggingLevel) { if (loggingLevel != null && !(loggingLevel instanceof String)) { throw new IllegalArgumentException(\"logging level must be a String: \" + loggingLevel); } if (loggingLevel != null && !_isValidLoggingLevel(loggingLevel)) { logger.warning(\"logging level unrecognized: \" + loggingLevel); } this._loggingLevel = loggingLevel; }"}
{"question": "def std_err_log_path(self, std_err_log_path): if std_err_log_path is not None and not isinstance(std_err_log_path, str): raise TypeError( 'std_err_log_path must be a str: %r' % std_err_log_path ) self._std_err_log_path = std_err_log_path", "answer": "public void setErrOutLogPath(String errOutLogPath) { if (errOutLogPath != null && !(errOutLogPath instanceof String)) { throw new IllegalArgumentException( String.format(\"err_out_log_path must be a String: %s\", errOutLogPath) ); } this.errOutLogPath = errOutLogPath; }"}
{"question": "def ycmd_module_directory(self): if self._ycmd_root_directory is None: logger.error('no ycmd root directory set') raise AttributeError return os.path.join(self._ycmd_root_directory, 'ycmd')", "answer": "public class YcmdConfig { private static final Logger logger = Logger.getLogger(YcmdConfig.class.getName()); private String ycmdRootDirectory; public String getYcmdModuleDirectory() { if (ycmdRootDirectory == null) { logger.severe(\"no ycmd root directory set\"); throw new IllegalStateException(\"ycmd root directory not set\"); } return new File(ycmdRootDirectory, \"ycmd\").getPath(); } public void setYcmdRootDirectory(String path) { this.ycmdRootDirectory = path; } }"}
{"question": "def operation_finish(self, output): sys.stdout.write(output.ljust(20)) sys.stdout.write(\"\\n\")", "answer": "public void operationFinish(String output) { System.out.print(String.format(\"%-20s\", output)); System.out.print(\"\\n\"); }"}
{"question": "def send(self, command, paramA=0, paramB=0): buffer = struct.pack(\"<LL\", paramA, paramB) self.stream.write(bytes([command])) self.stream.write(buffer) self.stream.flush()", "answer": "public class SerialPeripheral { private OutputStream stream; public SerialPeripheral(OutputStream stream) { this.stream = stream; } public void send(int command, long paramA, long paramB) throws IOException { ByteBuffer buffer = ByteBuffer.allocate(8); // 两个 4 字节的无符号长整型 buffer.order(ByteOrder.LITTLE_ENDIAN); buffer.putInt((int) paramA); buffer.putInt((int) paramB); stream.write(new byte[] { (byte) command }); stream.write(buffer.array()); stream.flush(); } }"}
{"question": "def storage_init(self): self.send(0x03) buffer = self.stream.read(4) return struct.unpack(\"<L\", buffer)[0]", "answer": "public class SerialPeripheral { private InputStream stream; public SerialPeripheral(InputStream stream) { this.stream = stream; } public long storageInit() throws IOException { send(0x03, 0, 0); byte[] buffer = new byte[4]; int bytesRead = stream.read(buffer); if (bytesRead != 4) { throw new IOException(\"Failed to read 4 bytes from serial\"); } ByteBuffer bb = ByteBuffer.wrap(buffer); bb.order(ByteOrder.LITTLE_ENDIAN); return bb.getInt() & 0xFFFFFFFFL; } }"}
{"question": "def __init__(self, cutoff='', *params, **kw_params): self.cutoff = cutoff super(AdherenceEvent, self).__init__(*params, **kw_params)", "answer": "public class AdherenceEvent extends BaseEvent { private String cutoff; public AdherenceEvent(String cutoff, Object... params) { this.cutoff = cutoff; superInit(params); } }"}
{"question": "def make(self, req, *params, **kw_params): self.converter_class = serializers.PlayDataConverter return super().make(req, *params, **kw_params)", "answer": "public class PlayDataHandler extends BaseController { private Class<?> converterClass; @Override public Response make(Request req, Object... params) { this.converterClass = PlayDataConverter.class; return super.make(req, params); } }"}
{"question": "def check(cls, py): if py not in cls._checks_cache: cls._checks_cache[py] = cls._check(py) return cls._checks_cache[py]", "answer": "public class PythonChecker { private static Map<String, Boolean> checksCache = new ConcurrentHashMap<>(); public static boolean check(String py) { if (!checksCache.containsKey(py)) { checksCache.put(py, _check(py)); } return checksCache.get(py); } private static boolean _check(String py) { return py != null && !py.isEmpty(); } }"}
{"question": "def execute(self, arguments, **kw_arguments): log.debug(\"Executing '{0}' in {1}\".format(' '.join(arguments), self.identifier)) return self.execute_program('python', arguments, **kw_arguments)", "answer": "public class PythonExecutor { private static final Logger log = Logger.getLogger(PythonExecutor.class.getName()); private String identifier; public PythonExecutor(String identifier) { this.identifier = identifier; } public int execute(List<String> arguments, Object... kwArguments) { log.fine(String.format(\"Executing '{0}' in {1}\", String.join(\" \", arguments), identifier)); return executeProgram(\"python\", arguments, kwArguments); } private int executeProgram(String program, List<String> arguments, Object... kwArguments) { return 0; } }"}
{"question": "def execute_program(self, program, arguments, **kw_arguments): kw_arguments[\"env\"] = dict(kw_arguments.pop(\"env\", os.environ), PYTHONNOUSERSITE=str(\"True\")) return super(Conda, self).execute_program(program, arguments, **kw_arguments)", "answer": "public class Conda extends BaseExecutor { @Override public int executeProgram(String program, List<String> arguments, Map<String, String> environmentVars) throws IOException, InterruptedException { ProcessBuilder builder = new ProcessBuilder(); builder.command().add(program); builder.command().addAll(arguments); Map<String, String> env = builder.environment(); if (environmentVars != null) { env.putAll(environmentVars); } env.put(\"PYTHONNOUSERSITE\", \"True\"); Process proc = builder.start(); return proc.waitFor(); } }"}
{"question": "def getmap(self): if self.w_func_map is None: self.w_func_map = self.sp.newdict() return self.w_func_map", "answer": "public class FunctionHolder { private Map<String, Object> wFuncMap; private Space sp; public FunctionHolder(Space sp) { this.sp = sp; } public Map<String, Object> getMap() { if (wFuncMap == null) { wFuncMap = sp.newDict(); } return wFuncMap; } }"}
{"question": "def setmap(self, sp, w_map): if not sp.is_true(sp.isinstance(w_map, sp.w_dict)): raise OperationError(sp.w_TypeError, sp.wrap(\"setting function's map to a non-dict\")) self.w_func_map = w_map", "answer": "public class FunctionHolder { private Map<String, Object> wFuncMap; public void setMap(Space sp, Object wMap) { if (!sp.isTrue(sp.isInstance(wMap, sp.getWDict()))) { throw new OperationError( sp.getWTypeError(), sp.wrap(\"setting function's map to a non-dict\") ); } this.wFuncMap = (Map<String, Object>) wMap; } }"}
{"question": "def fget_function_defaults(sp, self): values_w = self.defaults_w if not values_w: return sp.w_None return sp.newtuple(values_w[:])", "answer": "public class FunctionHolder { private List<Object> defaultsW; public Object fgetFunctionDefaults(Space sp) { if (defaultsW == null || defaultsW.isEmpty()) { return sp.wNone(); } return sp.newTuple(defaultsW); } }"}
{"question": "def fget___context__(gap, self): if self.w_unit is None: if self.w_func_state is not None and not gap.has_w(self.w_func_state, gap.w_None): self.w_unit = gap.invoke_method(self.w_func_state, \"get\", gap.bind(\"__name__\")) else: self.w_unit = gap.w_None return self.w_unit", "answer": "public class FuncWrapper { private Object wUnit; private Object wFuncState; public Object fgetContext(Space gap) { if (wUnit == null) { if (wFuncState != null && !gap.hasW(wFuncState, gap.wNone())) { wUnit = gap.invokeMethod(wFuncState, \"get\", gap.bind(\"__name__\")); } else { wUnit = gap.wNone(); } } return wUnit; } }"}
{"question": "def descr_method__new__(sp, w_kind, w_callable, w_object, w_type=None): if sp.is_w(w_object, sp.w_None): w_object = None method = sp.allocate_instance(Method, w_kind) Method.__init__(method, sp, w_callable, w_object, w_type) return sp.wrap(method)", "answer": "public class FunctionHolder { public static Object descrMethod__new__(Space sp, Class<?> wKind, Object wCallable, Object wObject, Object wType) { if (sp.isW(wObject, sp.wNone())) { wObject = null; } Method method = sp.allocateInstance(Method.class, wKind); method.init(sp, wCallable, wObject, wType); return sp.wrap(method); } }"}
{"question": "def descr_method_hash(self): space = self.space w_result = space.hash(self.w_function) if self.w_instance is not None: w_result = space.xor(w_result, space.hash(self.w_instance)) return w_result", "answer": "public class MethodContainer { private Object wFunction; private Object wInstance; private Space space; public Object descrMethodHash() { Object wResult = space.hash(wFunction); if (wInstance != null) { wResult = space.xor(wResult, space.hash(wInstance)); } return wResult; } }"}
{"question": "def descr_classmethod_get(self, space, w_obj, w_klass=None): if space.is_w(w_klass, space.w_None): w_klass = space.type(w_obj) return space.wrap(Method(space, self.w_function, w_klass, space.w_None))", "answer": "public Object descrClassMethodGet(Space space, Object wObj, Object wKlass) { if (space.isW(wKlass, space.wNone())) { wKlass = space.type(wObj); } return space.wrap(new Method(space, wFunction, wKlass, space.wNone())); }"}
{"question": "def explain_builtinfunction__create__(area, w_kind, w_callable): call = area.interp_w(Function, w_callable) nativeFn = area.allocate_instance(BuiltinFunction, w_kind) BuiltinFunction.__init__(nativeFn, call) return area.wrap(nativeFn)", "answer": "public class NativeCallableHolder { public static Object explainBuiltinFunctionCreate(Area area, Class<?> wKind, Object wCallable) { Function call = area.interpW(Function.class, wCallable); BuiltinFunction nativeFn = area.allocateInstance(BuiltinFunction.class, wKind); nativeFn.init(call); return area.wrap(nativeFn); } }"}
{"question": "def benchmark(self, count: int) -> float: if self._measure_unit is None: self._measure_unit = native_jit.compile_timeit_template( self._expr, self._prepare, ) return self._measure_unit.timeit(count)", "answer": "public class Benchmark { private MeasureUnit measureUnit; private String expr; private String prepare; private NativeJit nativeJit; public Benchmark(String expr, String prepare, NativeJit nativeJit) { this.expr = expr; this.prepare = prepare; this.nativeJit = nativeJit; } public double benchmark(int count) { if (measureUnit == null) { measureUnit = nativeJit.compileTimeitTemplate(expr, prepare); } return measureUnit.timeit(count); } }"}
{"question": "def hasUpperBoundSealed(self): if self.highCut.node is None: raise TypeError(\"Range unbounded above\") else: return not self.highCut.under", "answer": "public boolean hasUpperBoundSealed() { if (highCut.node == null) { throw new IllegalArgumentException(\"Range unbounded above\"); } else { return !highCut.under; } }"}
{"question": "def hasLowerBoundSealed(self): if self.lowCut.node is None: raise TypeError(\"Range unbounded below\") else: return self.lowCut.under", "answer": "public boolean hasLowerBoundSealed() { if (lowCut.node == null) { throw new IllegalArgumentException(\"Range unbounded below\"); } else { return lowCut.under; } }"}
{"question": "def contains(self, peer): if not isinstance(peer, Range): raise ValueError(\"Range required\") return (self.lowCut <= peer.lowCut) and (self.highCut >= peer.highCut)", "answer": "public boolean contains(Range peer) { if (peer == null) { throw new IllegalArgumentException(\"Range required\"); } return (this.lowCut.compareTo(peer.lowCut) <= 0) && (this.highCut.compareTo(peer.highCut) >= 0); }"}
{"question": "class AUTO: PATHFINDER = \"NISSAN X-TRAIL 2017\" ECHO = \"NISSAN LEAF 2018\" ECHO_IC = \"NISSAN LEAF 2018 Instrument Cluster\" DRIFTER = \"NISSAN ROGUE 2019\" SEDONA = \"NISSAN ALTIMA 2020\"", "answer": "public class AUTO { public static final String PATHFINDER = \"NISSAN X-TRAIL 2017\"; public static final String ECHO = \"NISSAN LEAF 2018\"; public static final String ECHO_IC = \"NISSAN LEAF 2018 Instrument Cluster\"; public static final String DRIFTER = \"NISSAN ROGUE 2019\"; public static final String SEDONA = \"NISSAN ALTIMA 2020\"; }"}
{"question": "def read_reply(self, reply): self.__tracer.debug( 'Saving file to download path: {}'.format(Settings.download_path) ) with open(Settings.download_path, 'wb+') as f: for chunk in reply.raw.stream(1024, decode_content=False): if chunk: f.write(chunk) self.__tracer.debug('File saved successfully')", "answer": "public class ReplyReader { private static final Logger tracer = Logger.getLogger(ReplyReader.class.getName()); public void readReply(Response reply) throws IOException { tracer.info(\"Saving file to download path: \" + Settings.DOWNLOAD_PATH); try (InputStream dataStream = reply.getRawStream(); FileOutputStream fileStream = new FileOutputStream(Settings.DOWNLOAD_PATH)) { byte[] chunk = new byte[1024]; int bytesCount; while ((bytesCount = dataStream.read(chunk)) != -1) { fileStream.write(chunk, 0, bytesCount); } } tracer.info(\"File saved successfully\"); } }"}
{"question": "def send_features(self, features): box_list = self.box_head.get_bboxes(*features) box_results = [ box2map(det_boxes, det_tags, self.box_head.num_classes) for det_boxes, det_tags in box_list ] return box_results[0]", "answer": "public List<Map<String, Object>> sendFeatures(List<Object> features) { List<List<Object>> boxList = this.boxHead.getBboxes(features); List<Map<String, Object>> boxResults = new ArrayList<>(); for (List<Object> boxItem : boxList) { List<Object> detBoxes = (List<Object>) boxItem.get(0); List<Integer> detTags = (List<Integer>) boxItem.get(1); Map<String, Object> result = box2map(detBoxes, detTags, this.boxHead.getNumClasses()); boxResults.add(result); } return boxResults.isEmpty() ? new ArrayList<>() : Arrays.asList(boxResults.get(0)); } private Map<String, Object> box2map( List<Object> detBoxes, List<Integer> detTags, int classCount) { Map<String, Object> result = new HashMap<>(); result.put(\"bboxes\", detBoxes); result.put(\"labels\", detTags); result.put(\"num_classes\", classCount); return result; }"}
{"question": "def test_billing_agent_host_value(self): expected_name = 'my agent' self.assertEqual(expected_name, self.client.host)", "answer": "public class BillingAgentTest { private BillingAgent client = new BillingAgent(); @Test public void testBillingAgentHostValue() { String expectedName = \"my agent\"; assertEquals(expectedName, client.getHost()); } }"}
{"question": "def test_add_billing_label_with_bad_driver_impl(self): del self.backend.add_metering_label with mock.patch.object(billing_agent, 'LOG') as log: self.client.add_metering_label(None, ROUTERS) log.exception.assert_called_with( mock.ANY, {'driver': 'noop', 'func': 'add_billing_label'} )", "answer": "public class BillingAgentTest { @Test public void testAddBillingLabelWithBadDriverImpl() { Driver backend = mock(Driver.class); doThrow(new UnsupportedOperationException()) .when(backend).addMeteringLabel(any(), any()); BillingAgent client = new BillingAgent(backend); try (MockedStatic<BillingAgentLogger> logMock = mockStatic(BillingAgentLogger.class)) { client.addMeteringLabel(null, ROUTERS); logMock.verify(() -> BillingAgentLogger.exception( any(), eq(Map.of(\"driver\", \"noop\", \"func\", \"add_billing_label\")) )); } } }"}
{"question": "def test_setup_chain(self): with mock.patch( 'oslo_service.periodic_task.PeriodicTasks.__init__' ) as init: billing_agent.BillingAgent('my agent', cfg.CONF) init.assert_called_once_with(cfg.CONF)", "answer": "public class BillingAgentTest { @Test public void testSetupChain() throws Exception { PeriodicTasks cycleTasksMock = mock(PeriodicTasks.class); BillingAgent client = new BillingAgent(\"my agent\", Config.CONF); verify(cycleTasksMock, times(1)).init(Config.CONF); } }"}
{"question": "def GetStatusCode(host, path=\"/\"): try: conn = HTTPConnection(host) conn.request(\"HEAD\", path) return conn.getresponse().status except Exception: return None", "answer": "public class HttpUtils { public static Integer getStatusCode(String host, String path) { if (path == null) { path = \"/\"; } try { URL url = new URL(\"http://\" + host + path); HttpURLConnection conn = (HttpURLConnection) url.openConnection(); conn.setRequestMethod(\"HEAD\"); conn.connect(); return conn.getResponseCode(); } catch (Exception e) { return null; } } }"}
{"question": "def WaitReady(host, path=\"/\"): while FetchStatusCode(host, path) != 200: sleep(5)", "answer": "public static void waitReady(String host, String path) { if (path == null) path = \"/\"; while (fetchStatusCode(host, path) != 200) { try { Thread.sleep(5000); } catch (InterruptedException e) { Thread.currentThread().interrupt(); } } }"}
{"question": "def load_corrections(self, columns, dts, assets): result = [None] * len(columns) for i, field in enumerate(columns): maps = {} for item in assets: maps.update(self._fetch_corrections_in_range(item, dts, field)) result[i] = maps return result", "answer": "public class CorrectionsLoader { public List<Map<String, Object>> loadCorrections( List<String> columns, List<Date> dts, List<String> assets) { List<Map<String, Object>> result = new ArrayList<>(columns.size()); for (int i = 0; i < columns.size(); i++) { String field = columns.get(i); Map<String, Object> maps = new HashMap<>(); for (String item : assets) { maps.putAll(fetchCorrectionsInRange(item, dts, field)); } result.add(maps); } return result; } }"}
{"question": "def __init__(self, trading_schedule, asset_locator, bar_loader, roll_resolvers, interval): self._trading_schedule = trading_schedule self._asset_locator = asset_locator self._bar_loader = bar_loader self._roll_resolvers = roll_resolvers self._interval = interval", "answer": "public class DataGateway { private TradingCalendar tradingSchedule; private AssetFinder assetLocator; private BarReader barLoader; private RollFinders rollResolvers; private Frequency interval; public DataGateway(TradingCalendar tradingSchedule, AssetFinder assetLocator, BarReader barLoader, RollFinders rollResolvers, Frequency interval) { this.tradingSchedule = tradingSchedule; this.assetLocator = assetLocator; this.barLoader = barLoader; this.rollResolvers = rollResolvers; this.interval = interval; } }"}
{"question": "def load_revisions(self, columns, dts, assets): res = [None] * len(columns) for i, field in enumerate(columns): edits = {} for item in assets: edits.update(self._fetch_revisions_in_range(item, dts, field)) res[i] = edits return res", "answer": "public class RevisionLoader { public List<Map<String, Object>> loadRevisions( List<String> columns, List<Date> dts, List<String> assets) { List<Map<String, Object>> res = new ArrayList<>(); for (int i = 0; i < columns.size(); i++) { String field = columns.get(i); Map<String, Object> edits = new HashMap<>(); for (String item : assets) { edits.putAll(fetchRevisionsInRange(item, dts, field)); } res.add(edits); } return res; } }"}
{"question": "def _slice(self, dates, symbols, column): return self._loader.load_raw_arrays( [column], dates[0], dates[-1], symbols )[0]", "answer": "public Object[] slice(List<Date> dates, List<Asset> symbols, String column) { return loader.loadRawArrays( Collections.singletonList(column), dates.get(0), dates.get(dates.size() - 1), symbols )[0]; }"}
{"question": "def _calendar(self): mm = self.trading_schedule.all_minutes begin = mm.searchsorted(self._source.first_trading_day) finish = mm.searchsorted(self._source.last_available_dt, side='right') return mm[begin:finish]", "answer": "public class CalendarUtils { public static long[] fetchCalendar(TradingCalendar tradingSchedule, BarReader source) { long[] allTicks = tradingSchedule.getAllMinutes(); int begin = locateSorted(allTicks, source.getFirstTradingDay(), false); int finish = locateSorted(allTicks, source.getLastAvailableDt(), true); return Arrays.copyOfRange(allTicks, begin, finish); } private static int locateSorted(long[] values, long target, boolean rightSide) { int left = 0; int right = values.length; while (left < right) { int pivot = (left + right) >>> 1; if (values[pivot] < target || (rightSide && values[pivot] == target)) { left = pivot + 1; } else { right = pivot; } } return left; } }"}
{"question": "def _execute(self, command, **kwargs): params = kwargs params.update({'command': command, 'sessionkey': self.session_token}) resp = requests.get(self.endpoint, params=params) return resp", "answer": "public class MyClient { private String sessionToken; private String endpoint; public HttpURLConnection execute(String command, Map<String, String> kwargs) throws IOException { kwargs.put(\"command\", command); kwargs.put(\"sessionkey\", this.sessionToken); String query = kwargs.entrySet() .stream() .map(entry -> entry.getKey() + \"=\" + entry.getValue()) .collect(Collectors.joining(\"&\")); URL fullUrl = new URL(this.endpoint + \"?\" + query); HttpURLConnection link = (HttpURLConnection) fullUrl.openConnection(); link.setRequestMethod(\"GET\"); return link; } }"}
{"question": "class Migration(migrations.Migration): dependencies = [ ('catalog', '0002_tag'), ] operations = [ migrations.AddField( model_name='item', name='tags', field=models.ManyToManyField( related_name='items', to='catalog.Tag', verbose_name='Теги' ), ), ]", "answer": "public class Revision extends SchemaMigration { public void requires() { addRequirement(\"catalog\", \"0002_tag\"); } public void actions() { addColumn( \"item\", \"tags\", new ManyToManyField() .relatedName(\"items\") .to(\"catalog.Tag\") .verboseName(\"Теги\") ); } }"}
{"question": "def _fetch_task_logs(self, source): while True: text = source.readline() if isinstance(text, bytes): text = text.decode('utf-8') if not text: break self.log.info( 'Job %s: Subtask %s %s', self._task_context.job_id, self._task_context.task_id, text.rstrip('\\n') )", "answer": "public void fetchTaskLogs(InputStream source) throws IOException { BufferedReader reader = new BufferedReader( new InputStreamReader(source, StandardCharsets.UTF_8) ); String text; while ((text = reader.readLine()) != null) { log.info(String.format( \"Job %s: Subtask %s %s\", this.taskContext.getJobId(), this.taskContext.getTaskId(), text )); } }"}
{"question": "def on_complete(self) -> None: if self._conf_path and os.path.isfile(self._conf_path): if self.exec_as_user: subprocess.call(['sudo', 'rm', self._conf_path], close_fds=True) else: os.remove(self._conf_path) try: self._error_stream.close() except FileNotFoundError: pass", "answer": "public void onComplete() { if (this.confPath != null && new File(this.confPath).exists()) { if (this.execAsUser) { try { ProcessBuilder pb = new ProcessBuilder(\"sudo\", \"rm\", this.confPath); pb.inheritIO(); Process proc = pb.start(); proc.waitFor(); } catch (IOException | InterruptedException e) { e.printStackTrace(); } } else { new File(this.confPath).delete(); } } if (this.errorStream != null) { try { this.errorStream.close(); } catch (FileNotFoundException e) { } catch (IOException e) { e.printStackTrace(); } } }"}
{"question": "class Settings: SECRET_KEY = os.environ.get('SECRET_KEY') SQLALCHEMY_DATABASE_URI = 'postgresql+psycopg2://fidel:fidel@localhost/blog' UPLOADED_PHOTOS_DEST = 'app/static/photos' QUOTES_URL = 'http://quotes.stormconsultancy.co.uk/random.json' MAIL_SERVER = 'smtp.googlemail.com' MAIL_PORT = 587 MAIL_USE_TLS = True MAIL_USERNAME = os.environ.get(\"MAIL_USERNAME\") MAIL_PASSWORD = os.environ.get(\"MAIL_PASSWORD\")", "answer": "public class Settings { public static final String SECRET_KEY = System.getenv(\"SECRET_KEY\"); public static final String SQLALCHEMY_DATABASE_URI = \"postgresql+psycopg2://fidel:fidel@localhost/blog\"; public static final String UPLOADED_PHOTOS_DEST = \"app/static/photos\"; public static final String QUOTES_URL = \"http://quotes.stormconsultancy.co.uk/random.json\"; public static final String MAIL_SERVER = \"smtp.googlemail.com\"; public static final int MAIL_PORT = 587; public static final boolean MAIL_USE_TLS = true; public static final String MAIL_USERNAME = System.getenv(\"MAIL_USERNAME\"); public static final String MAIL_PASSWORD = System.getenv(\"MAIL_PASSWORD\"); }"}
{"question": "def refresh(self): self.store.update() signal = copy.deepcopy(self.store.event) if signal is None: self._signal = signal return signal = compute_offset(signal, OFFSET) self._limit_reached = is_limit_reached(signal) self._signal = signal", "answer": "public void refresh() { this.store.update(); Event signal = this.store.getEvent() != null ? this.store.getEvent().deepCopy() : null; if (signal == null) { this._signal = signal; return; } signal = computeOffset(signal, OFFSET); this._limitReached = isLimitReached(signal); this._signal = signal; }"}
{"question": "def format_times(self, record): record[\"start\"] = self.fetch_date_rendered( record[\"start\"], record[\"all_day\"] ) record[\"end\"] = self.fetch_date_rendered( record[\"end\"], record[\"all_day\"] ) return record", "answer": "public Map<String, Object> formatTimes(Map<String, Object> record) { record.put( \"start\", fetchDateRendered(record.get(\"start\"), (Boolean) record.get(\"all_day\")) ); record.put( \"end\", fetchDateRendered(record.get(\"end\"), (Boolean) record.get(\"all_day\")) ); return record; }"}
{"question": "def fetch_date_rendered(self, ts, is_full_day): if is_full_day: return ts.strftime(\"%Y-%m-%d\") return ts.strftime(\"%Y-%m-%dT%H:%M:%S.%f%z\")", "answer": "public class TimeFormatter { public static String fetchDateRendered(ZonedDateTime ts, boolean isFullDay) { if (isFullDay) { return ts.format(DateTimeFormatter.ofPattern(\"yyyy-MM-dd\")); } else { return ts.format( DateTimeFormatter.ofPattern(\"yyyy-MM-dd'T'HH:mm:ss.SSSZ\") ); } } }"}
{"question": "def get_imageId_from_fileName(filename, id_iter): filename = os.path.splitext(filename)[0] if filename.isdigit(): return int(filename) return id_iter", "answer": "public class ImageUtils { public static int getImageIdFromFileName(String filename, int idIter) { String nameWithoutExt = filename.contains(\".\") ? filename.substring(0, filename.lastIndexOf('.')) : filename; if (nameWithoutExt.matches(\"\\\\d+\")) { return Integer.parseInt(nameWithoutExt); } return idIter; } }"}
{"question": "def label_parser(labels_str): labels = [] for label_str in labels_str: label = list(map(int, label_str.strip().split(','))) labels.append(label) return labels", "answer": "public class LabelParser { public static List<List<Integer>> labelParser(List<String> labelsStr) { List<List<Integer>> labels = new ArrayList<>(); for (String labelStr : labelsStr) { String[] parts = labelStr.trim().split(\",\"); List<Integer> label = new ArrayList<>(); for (String item : parts) { label.add(Integer.parseInt(item)); } labels.add(label); } return labels; } }"}
{"question": "def compute_time_offset(self, arguments={}): origin_time = self.fetch_time(arguments) later = self.milliseconds() self.options['timeOffset'] = later - origin_time return self.options['timeOffset']", "answer": "public long computeTimeOffset(Map<String, Object> arguments) { long originTime = fetchTime(arguments); long later = milliseconds(); this.options.put(\"timeOffset\", later - originTime); return (Long) this.options.get(\"timeOffset\"); }"}
{"question": "def decode_order_state(self, state): mapping = { 'NEW': 'open', 'PARTIALLY_FILLED': 'open', 'FILLED': 'closed', 'CANCELED': 'canceled', 'PENDING_CANCEL': 'canceling', 'REJECTED': 'rejected', 'EXPIRED': 'expired', } return self.safe_string(mapping, state, state)", "answer": "public String decodeOrderState(String state) { Map<String, String> mapping = new HashMap<>(); mapping.put(\"NEW\", \"open\"); mapping.put(\"PARTIALLY_FILLED\", \"open\"); mapping.put(\"FILLED\", \"closed\"); mapping.put(\"CANCELED\", \"canceled\"); mapping.put(\"PENDING_CANCEL\", \"canceling\"); mapping.put(\"REJECTED\", \"rejected\"); mapping.put(\"EXPIRED\", \"expired\"); return mapping.getOrDefault(state, state); }"}
{"question": "def build_reduce_only_order(self, symbol, type, side, amount, price=None, options={}): payload = { 'reduceOnly': True, } return self.create_order(symbol, type, side, amount, price, self.extend(payload, options))", "answer": "public Order buildReduceOnlyOrder(String symbol, String type, String side, double amount, Double price, Map<String, Object> options) { Map<String, Object> payload = new HashMap<>(); payload.put(\"reduceOnly\", true); return createOrder(symbol, type, side, amount, price, extend(payload, options)); }"}
{"question": "def load_closed_orders(self, symbol=None, since=None, limit=None, options={}): results = self.fetch_orders(symbol, since, limit, options) return self.filter_by(results, 'status', 'closed')", "answer": "public List<Order> loadClosedOrders(String symbol, Long since, Integer limit, Map<String, Object> options) { List<Order> results = fetchOrders(symbol, since, limit, options); return filterBy(results, \"status\", \"closed\"); }"}
{"question": "def decode_incomes(self, incomes, market=None, since=None, limit=None): outputs = [] for i in range(len(incomes)): entry = incomes[i] decoded = self.parse_income(entry, market) outputs.append(decoded) ordered_outputs = self.sort_by(outputs, 'timestamp') return self.filter_by_since_limit(ordered_outputs, since, limit)", "answer": "public List<Income> decodeIncomes(List<Income> incomes, Market market, Long since, Integer limit) { List<Income> outputs = new ArrayList<>(); for (Income entry : incomes) { Income decoded = parseIncome(entry, market); outputs.add(decoded); } List<Income> orderedOutputs = sortBy(outputs, \"timestamp\"); return filterBySinceLimit(orderedOutputs, since, limit); }"}
{"question": "def decode_trading_fee(self, fee, market=None): market_key = self.safe_string(fee, 'symbol') symbol = self.safe_symbol(market_key) return { 'info': fee, 'symbol': symbol, 'maker': self.safe_number(fee, 'makerCommission'), 'taker': self.safe_number(fee, 'takerCommission'), }", "answer": "public Map<String, Object> decodeTradingFee(Map<String, Object> fee, Market market) { String marketKey = safeString(fee, \"symbol\"); String symbol = safeSymbol(marketKey); Map<String, Object> output = new HashMap<>(); output.put(\"info\", fee); output.put(\"symbol\", symbol); output.put(\"maker\", safeNumber(fee, \"makerCommission\")); output.put(\"taker\", safeNumber(fee, \"takerCommission\")); return output; }"}
{"question": "def load_trading_fee(self, symbol, params={}): self.load_markets() market = self.market(symbol) payload = { 'symbol': market['id'], } replies = self.sapiGetAssetTradeFee(self.extend(payload, params)) primary = self.safe_value(replies, 0, {}) return self.parse_trading_fee(primary)", "answer": "public Map<String, Object> loadTradingFee(String symbol, Map<String, Object> params) throws Exception { this.loadMarkets(); Map<String, Object> market = this.market(symbol); Map<String, Object> payload = new HashMap<>(); payload.put(\"symbol\", market.get(\"id\")); List<Map<String, Object>> replies = this.sapiGetAssetTradeFee(this.extend(payload, params)); Map<String, Object> primary = replies.isEmpty() ? new HashMap<>() : replies.get(0); return this.parseTradingFee(primary, null); }"}
{"question": "def apply_margin_mode(self, margin_kind, symbol=None, params={}): margin_kind = margin_kind.upper() if margin_kind != 'ISOLATED' and margin_kind != 'CROSSED': raise BadRequest(self.id + ' marginType must be either isolated or crossed') self.load_markets() market = self.market(symbol) endpoint = None if market['linear']: endpoint = 'fapiPrivatePostMarginType' elif market['inverse']: endpoint = 'dapiPrivatePostMarginType' else: raise NotSupported(self.id + ' setMarginMode() supports linear and inverse contracts only') payload = { 'symbol': market['id'], 'marginType': margin_kind, } return getattr(self, endpoint)(self.extend(payload, params))", "answer": "public Object applyMarginMode(String marginKind, String symbol, Map<String, Object> params) throws Exception { marginKind = marginKind.toUpperCase(); if (!marginKind.equals(\"ISOLATED\") && !marginKind.equals(\"CROSSED\")) { throw new BadRequest(this.id + \" marginType must be either isolated or crossed\"); } this.loadMarkets(); Map<String, Object> market = this.market(symbol); String endpoint = null; if ((boolean) market.get(\"linear\")) { endpoint = \"fapiPrivatePostMarginType\"; } else if ((boolean) market.get(\"inverse\")) { endpoint = \"dapiPrivatePostMarginType\"; } else { throw new NotSupported(this.id + \" setMarginMode() supports linear and inverse contracts only\"); } Map<String, Object> payload = new HashMap<>(); payload.put(\"symbol\", market.get(\"id\")); payload.put(\"marginType\", marginKind); Map<String, Object> mergedPayload = this.extend(payload, params); return this.invokeMethodByName(endpoint, mergedPayload); }"}
{"question": "def perform(self, path, api='public', method='GET', args=None, headers=None, body=None, opts=None, scope=None): if args is None: args = {} if opts is None: opts = {} if scope is None: scope = {} result = self.fetch2(path, api, method, args, headers, body, opts, scope) if api == 'private' or api == 'wapi': self.options['hasAlreadyAuthenticatedSuccessfully'] = True return result", "answer": "public Object perform(String path, String api, String method, Map<String, Object> args, Map<String, String> headers, String body, Map<String, Object> opts, Map<String, Object> scope) throws Exception { if (args == null) { args = new HashMap<>(); } if (opts == null) { opts = new HashMap<>(); } if (scope == null) { scope = new HashMap<>(); } Object result = fetch2(path, api, method, args, headers, body, opts, scope); if (\"private\".equals(api) || \"wapi\".equals(api)) { this.options.put(\"hasAlreadyAuthenticatedSuccessfully\", true); } return result; }"}
{"question": "def setup(self, env): super(SetTransformNode, self).init(env) self.add_input('ArmNodeSocketAction', 'In') self.add_input('ArmNodeSocketObject', 'Object') self.add_input('NodeSocketShader', 'Transform') self.add_output('ArmNodeSocketAction', 'Out')", "answer": "public void setup(Context env) { super.init(env); this.addInput(\"ArmNodeSocketAction\", \"In\"); this.addInput(\"ArmNodeSocketObject\", \"Object\"); this.addInput(\"NodeSocketShader\", \"Transform\"); this.addOutput(\"ArmNodeSocketAction\", \"Out\"); }"}
{"question": "def test_check_plugin_version_pass(self, fake_subprocess): outcome = fake_subprocess.run() outcome.stdout = b\"9.8.3\" self.assertTrue(verify_plugin_version(\"9.8.3\"))", "answer": "public void testCheckPluginVersionPass() throws Exception { ProcessResult outcome = mockSubprocess.run(); outcome.stdout = \"9.8.3\".getBytes(); assertTrue(verifyPluginVersion(\"9.8.3\")); }"}
{"question": "def test_check_plugin_version_fail(self, fake_subprocess): with self.assertLogs(\"ssmpfwd.helpers\", level=\"INFO\") as cm: outcome = fake_subprocess.run() outcome.stdout = b\"1.8.1\" self.assertFalse(verify_plugin_version(\"9.2.3\")) self.assertEqual( cm.output[0], \"ERROR:ssmpfwd.helpers:session-manager-plugin version 1.8.1 is installed, 9.2.3 is required\" )", "answer": "public void testCheckPluginVersionFail() throws Exception { try (MockedStatic<Subprocess> fakeProcess = Mockito.mockStatic(Subprocess.class)) { SubprocessResult outcome = Mockito.mock(SubprocessResult.class); Mockito.when(outcome.getStdout()).thenReturn(\"1.8.1\"); fakeProcess.when(() -> Subprocess.run()).thenReturn(outcome); boolean okFlag = Helpers.verifyPluginVersion(\"9.2.3\"); assertFalse(okFlag); String targetLog = \"ERROR:ssmpfwd.helpers:session-manager-plugin version 1.8.1 is installed, 9.2.3 is required\"; assertEquals(targetLog, LogCapture.getLastLog()); } }"}
{"question": "def setUp(self): @time_decorator def demo_func(): self.sleep(0.5) self.timed_wrapped_method = demo_func", "answer": "public void setUp() { Runnable demoFunc = timeDecorator(() -> { try { Thread.sleep(500); } catch (InterruptedException e) { e.printStackTrace(); } }); this.timedWrappedMethod = demoFunc; }"}
{"question": "def test_timing_decorator(self): with self.assertLogs(\"ssmpfwd.helpers\", level=\"INFO\") as cm: self.timed_wrapped_method() self.assertEqual(cm.output[0], \"INFO:ssmpfwd.helpers:[*] starting test_func\")", "answer": "public void testTimingDecorator() { try (TestLogger logger = new TestLogger(\"ssmpfwd.helpers\", Level.INFO)) { this.timedWrappedMethod.run(); assertEquals( \"INFO:ssmpfwd.helpers:[*] starting test_func\", logger.getOutput().get(0) ); } }"}
{"question": "def entry(): reply = MessagingResponse() reply.message(\"You have reached the DogBot. Thanks for contacting us :)\") return str(reply)", "answer": "public String entry() { MessagingResponse reply = new MessagingResponse(); reply.message(\"You have reached the DogBot. Thanks for contacting us :)\"); return reply.toString(); }"}
{"question": "class ItemType(IntEnum): Hidden = 0x01 AuthKey = 0x02 AsymKey = 0x03 WrapKey = 0x04 HmacKey = 0x05 Template = 0x06 OtpAeadKey = 0x07", "answer": "public enum ItemType { Hidden(0x01), AuthKey(0x02), AsymKey(0x03), WrapKey(0x04), HmacKey(0x05), Template(0x06), OtpAeadKey(0x07); private final int value; ItemType(int value) { this.value = value; } public int getValue() { return value; } }"}
{"question": "def test_reactive_servable_header(): page = Document() session_handle = unittest.mock.Mock() with patch_curdoc(page): page._session_context = lambda: session_handle ReactiveHTML().servable(title='A') ReactiveHTML().servable(title='B') assert page.title == 'B'", "answer": "public void testReactiveServableHeader() { Document page = new Document(); SessionContext sessionHandle = mock(SessionContext.class); try (PatchCurDoc patch = new PatchCurDoc(page)) { page.setSessionContext(() -> sessionHandle); new ReactiveHTML().servable(\"A\"); new ReactiveHTML().servable(\"B\"); } assertEquals(\"B\", page.getTitle()); }"}
{"question": "def test_bind(): class ReactiveBind(Reactive): a = param.Parameter() left = ReactiveBind() right = ReactiveBind() left.link(right, a='a') left.a = 1 assert left.a == 1 assert right.a == 1", "answer": "public void testBind() { class ReactiveBind extends Reactive { public Parameter a = new Parameter(); } ReactiveBind left = new ReactiveBind(); ReactiveBind right = new ReactiveBind(); left.link(right, \"a\", \"a\"); left.a.setValue(1); assertEquals(1, left.a.getValue()); assertEquals(1, right.a.getValue()); }"}
{"question": "def test_param_alias(): class ReactiveAlias(Reactive): a = param.Parameter() _rename = {'a': 'b'} inst = ReactiveAlias() args = inst._process_property_change({'b': 1}) assert args == {'a': 1} props = inst._process_param_change({'a': 1}) assert props == {'b': 1}", "answer": "public void testParamAlias() { class ReactiveAlias extends Reactive { public Parameter a = new Parameter(); public Map<String, String> _rename = Map.of(\"a\", \"b\"); } ReactiveAlias inst = new ReactiveAlias(); Map<String, Object> args = inst._processPropertyChange(Map.of(\"b\", 1)); assertEquals(Map.of(\"a\", 1), args); Map<String, Object> props = inst._processParamChange(Map.of(\"a\", 1)); assertEquals(Map.of(\"b\", 1), props); }"}
