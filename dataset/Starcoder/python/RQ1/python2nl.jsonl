{"question": "def table_iter (self) : root = self.tree.getroot () for div in root.findall (\".//%s\" % tag (\"div\")) : if div.get ('id') == 'maincontent' : break tbl = div.find (\".//%s\" % tag (\"table\")) if tbl is None : return for tr in tbl : if tr [0].tag == tag ('th') : continue yield (self.tree.get_text (x) for x in tr)", "answer": "This function locates the first table within the 'maincontent' section of an XML/HTML tree and yields the text content of each non-header row."}
{"question": "def parse (self) : self.neighbors = {} for l in self.table_iter () : neighbor, ip, lq, nlq, etx = l lq, nlq, etx = (float (x) for x in (lq, nlq, etx)) self.neighbors [neighbor] = [ip, lq, nlq, etx]", "answer": "This function iterates over table data to populate a dictionary mapping each neighbor to its associated IP address and numeric link quality metrics."}
{"question": "def limit(img, std_hash, count): cmp_hash = calc_hash(img) diff = compare(std_hash, cmp_hash) if diff <= DIFF_THRES: if count >= LIMIT: return 'remove' else: return 'update_std' return 'continue'", "answer": "This function compares an image's hash to a standard hash and returns whether to remove it, update the standard, or continue based on the difference and a count limit."}
{"question": "def resize(img): width = np.shape(img)[1] height = np.shape(img)[0] if width > RESIZE: scale = RESIZE / width resized_img = cv2.resize( img, (RESIZE, math.floor(height / scale)), cv2.INTER_AREA) return resized_img return img", "answer": "This function resizes an image to a specified maximum width while maintaining its aspect ratio, returning the original image if no resizing is needed."}
{"question": "class Room_Item(QWidget,Ui_Form): def __init__(self,parent=None,room_data=None): super(Room_Item,self).__init__(parent) self.setupUi(self) self.data = room_data self.setRoomInfo()", "answer": "This class initializes a room item widget with provided room data and sets up its user interface."}
{"question": "def print_stack_trace(cls, stack_trace_line): for level in stack_trace_line.split(\"', '\"): for line in level.split(\"\\\\n\"): if line: print(line)", "answer": "This function prints each non-empty line from a given stack trace string by splitting it into levels and lines."}
{"question": "def run_app(self): try: self.create() self.native.ThreadException += self.winforms_thread_exception self.loop.run_forever(self.app_context) except: # NOQA traceback.print_exc()", "answer": "This function initializes the application, sets up a thread exception handler, runs the event loop indefinitely, and prints any exceptions that occur."}
{"question": "def _create_app_commands(self): self.interface.commands.add( toga.Command( lambda w: self.open_file, label='Open...', shortcut=Key.MOD_1 + 'o', group=toga.Group.FILE, section=0 ) )", "answer": "This function adds an \"Open...\" command with a keyboard shortcut to the application's file menu."}
{"question": "def featureSelection_variance(X, thrd): sel = VarianceThreshold(threshold=thrd) X_selected = sel.fit_transform(X) mask = sel.get_support() return X_selected, mask", "answer": "This function selects and returns features from a dataset whose variance exceeds a specified threshold, along with a mask indicating the selected features."}
{"question": "def init_hdf5(file_path, mode=\"w\", cam_type=\"davis\"): if mode == \"w\": dataset = h5py.File(file_path, mode=mode) dataset.create_group(\"dvs\") dataset.create_group(\"extra\") if cam_type == \"davis\": dataset.create_group(\"aps\") dataset.create_group(\"imu\") elif mode == \"r\": dataset = h5py.File(file_path, mode=mode) return dataset", "answer": "This function initializes and returns an HDF5 file with specific data groups based on the file mode and camera type."}
{"question": "def GetRootAsFloatingPoint(cls, buf, offset): n = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset) x = FloatingPoint() x.Init(buf, n + offset) return x", "answer": "This function reads a floating-point object from a FlatBuffers-encoded buffer at a given offset and returns it."}
{"question": "def Precision(self): o = flatbuffers.number_types.UOffsetTFlags.py_type( self._tab.Offset(4) ) if o != 0: return self._tab.Get( flatbuffers.number_types.Int16Flags, o + self._tab.Pos ) return 0", "answer": "This function retrieves and returns a 16-bit integer precision value from a FlatBuffers table, defaulting to 0 if the value is not present."}
{"question": "def avg(self): sum = float(self.sum) if not self.window_size: return 0 return sum / self.window_size / self.window_interval", "answer": "This function calculates and returns the average value by dividing the stored sum by both the window size and window interval, or returns 0 if the window size is not set."}
{"question": "def keys(self): result = set() for key in self.manager.counters: if key[:len(self._keys)] == self._keys: key = key[len(self._keys):] result.add(key[0] if key else '__value__') return result", "answer": "This function returns a set of subkeys or a default value extracted from keys in a counter manager that start with a specified prefix."}
{"question": "def to_dict(self, get_value=None): result = {} for key, value in iteritems(self): if isinstance(value, BaseCounter): if get_value is not None: value = getattr(value, get_value) result[key] = value else: result[key] = value.to_dict(get_value) return result", "answer": "This function converts the object and any nested structures into a dictionary, optionally extracting a specific attribute from `BaseCounter` instances."}
{"question": "def load(self, filename): try: with open(filename) as fp: self.counters = cPickle.load(fp) except: logging.debug(\"can't load counter from file: %s\" % filename) return False return True", "answer": "This function attempts to load serialized counter data from a specified file into the object, returning True on success and False on failure."}
{"question": "def dfs(i, j): if i == len(grid): return 0 if memo[i][j] == UNKNOWN: memo[i][j] = grid[i][j] + max(dfs(i + 1, j), dfs(i + 1, j + 1)) return memo[i][j] return dfs(0, 0)", "answer": "This function uses depth-first search with memoization to compute the maximum path sum from the top to the bottom of a grid by moving to adjacent cells in the next row."}
{"question": "def kornia_color_jitter_numpy(img, setting): if setting * 255 > 1: # I'm using Kornia's ColorJitter, which requires pytorch arrays in b,c,h,w format. img = torch.from_numpy(img).permute(2,0,1).unsqueeze(0) img = ColorJitter(setting, setting, setting, setting)(img) img = img.squeeze(0).permute(1,2,0).numpy() return img", "answer": "This function applies a Kornia ColorJitter transformation with the specified setting to a NumPy image if the setting exceeds a threshold, returning the modified image."}
{"question": "def reset_random(self): if 'random_seed' in self.opt.keys(): self.rand = random.Random(self.opt['random_seed']) else: self.rand = random.Random()", "answer": "This function initializes the object's random number generator using a specified seed if provided, or a default seed otherwise."}
{"question": "def get_rand(self): r = self.rand.random() if self.cosine_bias: return 1 - cos(r * pi / 2) else: return r", "answer": "This function returns a random number between 0 and 1, optionally transformed using a cosine-based bias."}
{"question": "def test_hue_shift_limit_value( quality_lower, quality_upper, expected, message): try: Tfda.JpegCompression( quality_lower=quality_lower, quality_upper=quality_upper) actual = TestResult.OK except ValueError: actual = TestResult.Error assert expected == actual, message", "answer": "This function tests whether creating a `JpegCompression` object with given quality bounds succeeds or raises a `ValueError` and asserts the result matches the expected outcome."}
{"question": "def test_bg_swap_fast(): bg_x = np.ones(shape=[2, 5, 5, 3]) * -1 bg_y = np.random.rand(2) fg = np.random.normal(loc=.5, scale=.1, size=[5, 5]) bg = InMemoryDataset(bg_x, bg_y) bg_swap = BackgroundSwap(bg, input_dim=(5, 5), normalize_bg=None) spliced_1_channel = bg_swap(fg)[:, :, 0] assert np.array_equal((spliced_1_channel <= -1), (fg <= .5))", "answer": "This function tests that a background swapping operation correctly replaces foreground pixels below a threshold with background values."}
{"question": "def test_background_swap_numpy(): mnist = MNIST(DATA_PATH, download=True, train=True) cifar = CIFAR10(DATA_PATH, download=True, train=True) bg_swap = BackgroundSwap(cifar, input_dim=(28, 28)) im = mnist.get_data()[0][0] im = bg_swap(im)", "answer": "This function loads MNIST and CIFAR-10 datasets, creates a background swapper using CIFAR-10 images, and applies it to the first MNIST image."}
{"question": "def test_leaves_remote_addr_alone_if_no_real_ip(): remote_addr = object() request = unittest.mock.MagicMock() request.META = {\"REMOTE_ADDR\": remote_addr} middleware.XRealIPMiddleware(get_response)(request) assert request.META[\"REMOTE_ADDR\"] is remote_addr", "answer": "This function tests that the XRealIPMiddleware leaves the REMOTE_ADDR value unchanged when no real IP header is present in the request."}
{"question": "def test_switches_out_x_real_ip_if_available(): remote_addr = object() x_real_ip = object() request = unittest.mock.MagicMock() request.META = {\"REMOTE_ADDR\": remote_addr, \"HTTP_X_REAL_IP\": x_real_ip} middleware.XRealIPMiddleware(get_response)(request) assert request.META[\"REMOTE_ADDR\"] is x_real_ip assert request.META[\"HTTP_X_REAL_IP\"] is x_real_ip", "answer": "This function tests that the XRealIPMiddleware replaces the request's REMOTE_ADDR with the HTTP_X_REAL_IP value when available."}
{"question": "class Notifier: def __init__(self, name): self.notify = directNotify.newCategory(name)", "answer": "This class initializes a notifier instance with a named notification category created via directNotify."}
{"question": "def __init__(self): super().__init__(SCREEN_WIDTH, SCREEN_HEIGHT, SCREEN_TITLE) self.camera = None self.gui_camera = None self.score = 0", "answer": "This function initializes an object with screen dimensions and title, sets up camera attributes, and initializes the score to zero."}
{"question": "def setup(self): self.camera = arcade.Camera(self.width, self.height) self.gui_camera = arcade.Camera(self.width, self.height) map_name = \":resources:tiled_maps/map.json\" layer_options = { \"Platforms\": { \"use_spatial_hash\": True } }", "answer": "This function initializes two camera objects for the game view and GUI, specifies a map resource, and configures spatial hashing for the \"Platforms\" layer."}
{"question": "def on_key_release(self, key, modifiers): if key == arcade.key.LEFT or key == arcade.key.A: self.player_sprite.change_x = 0 elif key == arcade.key.RIGHT or key == arcade.key.D: self.player_sprite.change_x = 0", "answer": "This function stops the player's horizontal movement when the left, right, A, or D keys are released."}
{"question": "def ycmd_root_directory(self): if self._ycmd_root_directory is None: logger.warning('no ycmd root directory has been set') return self._ycmd_root_directory", "answer": "This function returns the stored ycmd root directory and logs a warning if it has not been set."}
{"question": "def ycmd_root_directory(self, ycmd_root_directory): if ycmd_root_directory is not None and not isinstance(ycmd_root_directory, str): raise TypeError(ycmd_root_directory) self._ycmd_root_directory = ycmd_root_directory", "answer": "This function sets the `_ycmd_root_directory` attribute, raising a `TypeError` if the provided value is not a string or `None`."}
{"question": "def ycmd_settings_path(self): if self._ycmd_settings_path is None: if self._ycmd_root_directory is not None: return get_default_settings_path(self._ycmd_root_directory) logger.warning('no ycmd root directory has been set') return self._ycmd_settings_path", "answer": "This function returns the stored ycmd settings path or, if unset, attempts to derive it from the root directory, logging a warning if no root directory is available."}
{"question": "def working_directory(self): if self._working_directory is None: return os.getcwd() return self._working_directory", "answer": "This function returns the stored working directory if set, otherwise it returns the current working directory of the system."}
{"question": "def python_binary_path(self): if self._python_binary_path is None: return default_python_binary_path() return self._python_binary_path", "answer": "This function returns a stored Python binary path if available, otherwise it returns a default Python binary path."}
{"question": "def server_idle_suicide_seconds(self): if self._server_idle_suicide_seconds is None: return YCMD_DEFAULT_SERVER_IDLE_SUICIDE_SECONDS return self._server_idle_suicide_seconds", "answer": "This function returns the configured server idle timeout in seconds, or a default value if none is set."}
{"question": "def log_level(self, log_level): if log_level is not None and not isinstance(log_level, str): raise TypeError('log level must be a str: %r' % log_level) if log_level is not None and not _is_valid_log_level(log_level): logger.warning('log level unrecognized: %r', log_level) self._log_level = log_level", "answer": "This function sets the object's log level, raising an error if it's not a string and issuing a warning if the provided string is not a recognized log level."}
{"question": "def stderr_log_path(self, stderr_log_path): if stderr_log_path is not None and not isinstance(stderr_log_path, str): raise TypeError( 'stderr_log_path must be a str: %r' % stderr_log_path ) self._stderr_log_path = stderr_log_path", "answer": "This function sets the object's stderr log path, ensuring it is either a string or None, and raises a TypeError otherwise."}
{"question": "def ycmd_module_directory(self): if self._ycmd_root_directory is None: logger.error('no ycmd root directory set') raise AttributeError return os.path.join(self._ycmd_root_directory, 'ycmd')", "answer": "This function returns the path to the 'ycmd' subdirectory within the stored root directory, raising an error if the root directory is not set."}
{"question": "def opEnd(self, result): sys.stdout.write(result.ljust(20)) sys.stdout.write(\"\\n\")", "answer": "This function outputs the given result left-justified to 20 characters followed by a newline."}
{"question": "def cmd(self, cmd, argA=0, argB=0): buffer = struct.pack(\"<LL\", argA, argB) self.serial.write(bytes([cmd])) self.serial.write(buffer) self.serial.flush()", "answer": "This function sends a command byte followed by two packed 32-bit arguments over a serial connection and flushes the output."}
{"question": "def flashInit(self): self.cmd(0x03) buffer = self.serial.read(4) return struct.unpack(\"<L\", buffer)[0]", "answer": "This function sends a command to a device, reads four bytes from its serial connection, and returns the data as a 32-bit little-endian integer."}
{"question": "def __init__(self, deadline='', *args, **kw_args): self.deadline = deadline super(ComplianceEvent, self).__init__(*args, **kw_args)", "answer": "This constructor initializes a ComplianceEvent object by setting its deadline and passing any additional arguments to its superclass initializer."}
{"question": "def create(self, request, *args, **kwargs): self.serializer_class = serializers.GameDataSerializer return super().create(request, *args, **kwargs)", "answer": "This function sets the serializer to `GameDataSerializer` and then calls the parent class's create method to handle the request."}
{"question": "def matches(cls, python): if python not in cls._matches_cache: cls._matches_cache[python] = cls._matches(python) return cls._matches_cache[python]", "answer": "This function retrieves a cached match result for a given input or computes and stores it if not already cached."}
{"question": "def run(self, args, **kwargs): log.debug(\"Running '{0}' in {1}\".format(' '.join(args), self.name)) return self.run_executable('python', args, **kwargs)", "answer": "This function logs a debug message about executing a Python command with given arguments in the current context and then runs the command using a specified executable handler."}
{"question": "def run_executable(self, executable, args, **kwargs): kwargs[\"env\"] = dict(kwargs.pop(\"env\", os.environ), PYTHONNOUSERSITE=str(\"True\")) return super(Conda, self).run_executable(executable, args, **kwargs)", "answer": "This function runs a specified executable with given arguments while ensuring the environment variable `PYTHONNOUSERSITE` is set to `\"True\"`."}
{"question": "def getdict(self): if self.w_func_dict is None: self.w_func_dict = self.space.newdict() return self.w_func_dict", "answer": "This function returns an existing dictionary or creates and stores a new one if it does not already exist."}
{"question": "def setdict(self, space, w_dict): if not space.is_true(space.isinstance(w_dict, space.w_dict)): raise OperationError(space.w_TypeError, space.wrap(\"setting function's dictionary to a non-dict\")) self.w_func_dict = w_dict", "answer": "This function sets the function's dictionary to the provided value if it is a valid dictionary, otherwise raising a type error."}
{"question": "def fget_func_defaults(space, self): values_w = self.defs_w if not values_w: return space.w_None return space.newtuple(values_w[:])", "answer": "This function returns a tuple of the default argument values if they exist, otherwise it returns None."}
{"question": "def fget___module__(space, self): if self.w_module is None: if self.w_func_globals is not None and not space.is_w(self.w_func_globals, space.w_None): self.w_module = space.call_method(self.w_func_globals, \"get\", space.wrap(\"__name__\")) else: self.w_module = space.w_None return self.w_module", "answer": "This function retrieves and caches the module name associated with a given object, defaulting to None if unavailable."}
{"question": "def descr_method__new__(space, w_subtype, w_function, w_instance, w_class=None): if space.is_w(w_instance, space.w_None): w_instance = None method = space.allocate_instance(Method, w_subtype) Method.__init__(method, space, w_function, w_instance, w_class) return space.wrap(method)", "answer": "This function creates and returns a wrapped Method instance using the provided subtype, function, instance, and optional class."}
{"question": "def descr_method_hash(self): space = self.space w_result = space.hash(self.w_function) if self.w_instance is not None: w_result = space.xor(w_result, space.hash(self.w_instance)) return w_result", "answer": "This function computes and returns a hash value for a stored function, optionally combined with the hash of an associated instance."}
{"question": "def descr_classmethod_get(self, space, w_obj, w_klass=None): if space.is_w(w_klass, space.w_None): w_klass = space.type(w_obj) return space.wrap(Method(space, self.w_function, w_klass, space.w_None))", "answer": "This function returns a wrapped method object for a given function and class, defaulting the class to the type of the provided object if none is specified."}
{"question": "def descr_builtinfunction__new__(space, w_subtype, w_func): func = space.interp_w(Function, w_func) bltin = space.allocate_instance(BuiltinFunction, w_subtype) BuiltinFunction.__init__(bltin, func) return space.wrap(bltin)", "answer": "This function creates and returns a wrapped instance of a BuiltinFunction initialized with a given Function object."}
{"question": "def timeit(self, number: int) -> float: if self._timeit_module is None: self._timeit_module = cpp_jit.compile_timeit_template( self._stmt, self._setup, ) return self._timeit_module.timeit(number)", "answer": "This function compiles a timing module if not already available and uses it to measure the execution time of a statement for a specified number of runs."}
{"question": "def isUpperBoundClosed(self): if self.upperCut.point is None: raise TypeError(\"Range unbounded above\") else: return not self.upperCut.below", "answer": "This function checks whether the upper bound of a range is closed, raising an error if the range is unbounded above."}
{"question": "def isLowerBoundClosed(self): if self.lowerCut.point is None: raise TypeError(\"Range unbounded below\") else: return self.lowerCut.below", "answer": "This function checks whether the lower bound of a range is closed, raising an error if the range is unbounded below."}
{"question": "def encloses(self, other): if not isinstance(other, Range): raise ValueError(\"Range required\") return (self.lowerCut <= other.lowerCut) and (self.upperCut >= other.upperCut)", "answer": "This function checks whether the current range fully contains another range, raising an error if the input is not a Range."}
{"question": "class CAR: XTRAIL = \"NISSAN X-TRAIL 2017\" LEAF = \"NISSAN LEAF 2018\" LEAF_IC = \"NISSAN LEAF 2018 Instrument Cluster\" ROGUE = \"NISSAN ROGUE 2019\" ALTIMA = \"NISSAN ALTIMA 2020\"", "answer": "This class defines constants representing specific Nissan car models and their variants by name and year."}
{"question": "def parse_response(self, response): self.__logger.debug('Saving file to download path: {}'.format(Settings.download_path)) with open(Settings.download_path, 'wb+') as f: for chunk in response.raw.stream(1024, decode_content=False): if chunk: f.write(chunk) self.__logger.debug('File saved successfully')", "answer": "This function logs the download path, writes streamed binary data from a response to a file, and logs when the file is successfully saved."}
{"question": "def foward_features(self, features): bbox_list = self.bbox_head.get_bboxes(*features) bbox_results = [ bbox2result(det_bboxes, det_labels, self.bbox_head.num_classes) for det_bboxes, det_labels in bbox_list ] return bbox_results[0]", "answer": "This function processes input features through a bounding box head to generate and return the first set of formatted detection results."}
{"question": "def test_metering_agent_host_value(self): expected_host = 'my agent' self.assertEqual(expected_host, self.agent.host)", "answer": "This function verifies that the metering agent's host property matches the expected value \"my agent\"."}
{"question": "def test_add_metering_label_with_bad_driver_impl(self): del self.driver.add_metering_label with mock.patch.object(metering_agent, 'LOG') as log: self.agent.add_metering_label(None, ROUTERS) log.exception.assert_called_with( mock.ANY, {'driver': 'noop', 'func': 'add_metering_label'} )", "answer": "This function tests that an exception is logged when the metering label addition is attempted without a valid driver implementation."}
{"question": "def test_init_chain(self): with mock.patch( 'oslo_service.periodic_task.PeriodicTasks.__init__' ) as init: metering_agent.MeteringAgent('my agent', cfg.CONF) init.assert_called_once_with(cfg.CONF)", "answer": "This function tests that initializing a `MeteringAgent` calls the `PeriodicTasks` constructor exactly once with the given configuration."}
{"question": "def GetStatusCode(host, path=\"/\"): try: conn = HTTPConnection(host) conn.request(\"HEAD\", path) return conn.getresponse().status except Exception: return None", "answer": "This function sends an HTTP HEAD request to a specified host and path and returns the response status code or None if an error occurs."}
{"question": "def WaitOK(host, path=\"/\"): while GetStatusCode(host, path) != 200: sleep(5)", "answer": "This function repeatedly checks a given host and path until it returns an HTTP 200 status code, pausing five seconds between attempts."}
{"question": "def load_adjustments(self, columns, dts, assets): out = [None] * len(columns) for i, column in enumerate(columns): adjs = {} for asset in assets: adjs.update(self._get_adjustments_in_range(asset, dts, column)) out[i] = adjs return out", "answer": "This function retrieves and aggregates adjustment data for each specified column across given assets and date ranges, returning the results as a list."}
{"question": "def __init__(self, trading_calendar, asset_finder, bar_reader, roll_finders, frequency): self._trading_calendar = trading_calendar self._asset_finder = asset_finder self._bar_reader = bar_reader self._roll_finders = roll_finders self._frequency = frequency", "answer": "This constructor initializes an object with the provided trading calendar, asset finder, bar reader, roll finders, and frequency settings."}
{"question": "def load_adjustments(self, columns, dts, assets): out = [None] * len(columns) for i, column in enumerate(columns): adjs = {} for asset in assets: adjs.update(self._get_adjustments_in_range(asset, dts, column)) out[i] = adjs return out", "answer": "This function builds and returns a list of adjustment dictionaries for each specified column by aggregating adjustments for all given assets over the provided date range."}
{"question": "def _array(self, dts, assets, field): return self._reader.load_raw_arrays( [field], dts[0], dts[-1], assets )[0]", "answer": "This function retrieves and returns the first raw data array for a specified field, date range, and set of assets from the reader."}
{"question": "def _calendar(self): mm = self.trading_calendar.all_minutes start = mm.searchsorted(self._reader.first_trading_day) end = mm.searchsorted(self._reader.last_available_dt, side='right') return mm[start:end]", "answer": "This function returns the range of trading minutes between the first trading day and the last available date from the trading calendar."}
{"question": "def _command(self, command, **kwargs): params = kwargs params.update({'command': command, 'sessionkey': self.sessionkey}) res = requests.get(self.url, params=params) return res", "answer": "This function sends an HTTP GET request to a specified URL with the given command, session key, and additional parameters, and returns the response."}
{"question": "class Migration(migrations.Migration): dependencies = [ ('catalog', '0002_tag'), ] operations = [ migrations.AddField( model_name='item', name='tags', field=models.ManyToManyField( related_name='items', to='catalog.Tag', verbose_name='Теги' ), ), ]", "answer": "This migration adds a many-to-many \"tags\" field to the Item model linking it to the Tag model in the catalog app."}
{"question": "def _read_task_logs(self, stream): while True: line = stream.readline() if isinstance(line, bytes): line = line.decode('utf-8') if not line: break self.log.info( 'Job %s: Subtask %s %s', self._task_instance.job_id, self._task_instance.task_id, line.rstrip('\\n') )", "answer": "This function continuously reads lines from a given stream, decodes them if necessary, and logs each line with associated job and task identifiers until the stream ends."}
{"question": "def on_finish(self) -> None: if self._cfg_path and os.path.isfile(self._cfg_path): if self.run_as_user: subprocess.call(['sudo', 'rm', self._cfg_path], close_fds=True) else: os.remove(self._cfg_path) try: self._error_file.close() except FileNotFoundError: pass", "answer": "This function deletes a configuration file if it exists, using elevated privileges if required, and then attempts to close an associated error file."}
{"question": "class Config: SECRET_KEY = os.environ.get('SECRET_KEY') SQLALCHEMY_DATABASE_URI = 'postgresql+psycopg2://fidel:fidel@localhost/blog' UPLOADED_PHOTOS_DEST = 'app/static/photos' QUOTES_URL = 'http://quotes.stormconsultancy.co.uk/random.json' MAIL_SERVER = 'smtp.googlemail.com' MAIL_PORT = 587 MAIL_USE_TLS = True MAIL_USERNAME = os.environ.get(\"MAIL_USERNAME\") MAIL_PASSWORD = os.environ.get(\"MAIL_PASSWORD\")", "answer": "This class defines configuration settings for a web application, including security keys, database connection, file upload location, external API URL, and email server credentials."}
{"question": "def update(self): self.data.update() event = copy.deepcopy(self.data.event) if event is None: self._event = event return event = calculate_offset(event, OFFSET) self._offset_reached = is_offset_reached(event) self._event = event", "answer": "This function updates the object's data, processes and offsets its event, checks if the offset condition is met, and stores the resulting event."}
{"question": "def format_dates(self, event): event[\"start\"] = self.get_date_formatted(event[\"start\"], event[\"all_day\"]) event[\"end\"] = self.get_date_formatted(event[\"end\"], event[\"all_day\"]) return event", "answer": "This function formats the start and end dates of an event based on whether it is an all-day event and returns the updated event."}
{"question": "def get_date_formatted(self, dt, is_all_day): if is_all_day: return dt.strftime(\"%Y-%m-%d\") return dt.strftime(\"%Y-%m-%dT%H:%M:%S.%f%z\")", "answer": "This function returns a date as a formatted string, using only the date for all-day events and a full timestamp with timezone for timed events."}
{"question": "def get_imageId_from_fileName(filename, id_iter): filename = os.path.splitext(filename)[0] if filename.isdigit(): return int(filename) return id_iter", "answer": "This function extracts an integer ID from a filename if it is numeric, otherwise returns a provided fallback ID."}
{"question": "def anno_parser(annos_str): annos = [] for anno_str in annos_str: anno = list(map(int, anno_str.strip().split(','))) annos.append(anno) return annos", "answer": "This function converts a list of comma-separated numeric strings into a list of integer lists."}
{"question": "def load_time_difference(self, params={}): serverTime = self.fetch_time(params) after = self.milliseconds() self.options['timeDifference'] = after - serverTime return self.options['timeDifference']", "answer": "This function calculates and stores the difference between the local time and the server time, then returns that difference."}
{"question": "def parse_order_status(self, status): statuses = { 'NEW': 'open', 'PARTIALLY_FILLED': 'open', 'FILLED': 'closed', 'CANCELED': 'canceled', 'PENDING_CANCEL': 'canceling', 'REJECTED': 'rejected', 'EXPIRED': 'expired', } return self.safe_string(statuses, status, status)", "answer": "This function maps a given order status code to a standardized status description, returning the original code if no match is found."}
{"question": "def create_reduce_only_order(self, symbol, type, side, amount, price=None, params={}): request = { 'reduceOnly': True, } return self.create_order(symbol, type, side, amount, price, self.extend(request, params))", "answer": "This function creates a reduce-only trading order by merging specified parameters with a reduce-only flag and passing them to the order creation method."}
{"question": "def fetch_closed_orders(self, symbol=None, since=None, limit=None, params={}): orders = self.fetch_orders(symbol, since, limit, params) return self.filter_by(orders, 'status', 'closed')", "answer": "This function retrieves a list of orders and returns only those with a status of \"closed.\""}
{"question": "def parse_incomes(self, incomes, market=None, since=None, limit=None): result = [] for i in range(len(incomes)): entry = incomes[i] parsed = self.parse_income(entry, market) result.append(parsed) sorted_result = self.sort_by(result, 'timestamp') return self.filter_by_since_limit(sorted_result, since, limit)", "answer": "This function parses a list of income entries, sorts them by timestamp, and returns the filtered results based on optional date and limit criteria."}
{"question": "def parse_trading_fee(self, fee, market=None): marketId = self.safe_string(fee, 'symbol') symbol = self.safe_symbol(marketId) return { 'info': fee, 'symbol': symbol, 'maker': self.safe_number(fee, 'makerCommission'), 'taker': self.safe_number(fee, 'takerCommission'), }", "answer": "This function extracts and returns a structured trading fee object containing the market symbol and maker/taker commission values from the given fee data."}
{"question": "def fetch_trading_fee(self, symbol, params={}): self.load_markets() market = self.market(symbol) request = { 'symbol': market['id'], } response = self.sapiGetAssetTradeFee(self.extend(request, params)) first = self.safe_value(response, 0, {}) return self.parse_trading_fee(first)", "answer": "This function retrieves and parses the trading fee information for a specified market symbol."}
{"question": "def set_margin_mode(self, marginType, symbol=None, params={}): marginType = marginType.upper() if marginType != 'ISOLATED' and marginType != 'CROSSED': raise BadRequest(self.id + ' marginType must be either isolated or crossed') self.load_markets() market = self.market(symbol) method = None if market['linear']: method = 'fapiPrivatePostMarginType' elif market['inverse']: method = 'dapiPrivatePostMarginType' else: raise NotSupported(self.id + ' setMarginMode() supports linear and inverse contracts only') request = { 'symbol': market['id'], 'marginType': marginType, } return getattr(self, method)(self.extend(request, params))", "answer": "This function sets the margin mode to either isolated or crossed for a specified trading symbol, ensuring it is supported and sending the appropriate API request based on the contract type."}
{"question": "def request(self, path, api='public', method='GET', params=None, headers=None, body=None, config=None, context=None): if params is None: params = {} if config is None: config = {} if context is None: context = {} response = self.fetch2(path, api, method, params, headers, body, config, context) if api == 'private' or api == 'wapi': self.options['hasAlreadyAuthenticatedSuccessfully'] = True return response", "answer": "This function sends an HTTP request using specified parameters and updates the authentication status if the API type is private or wapi."}
{"question": "def init(self, context): super(SetTransformNode, self).init(context) self.add_input('ArmNodeSocketAction', 'In') self.add_input('ArmNodeSocketObject', 'Object') self.add_input('NodeSocketShader', 'Transform') self.add_output('ArmNodeSocketAction', 'Out')", "answer": "This function initializes a SetTransformNode by calling its parent initializer and defining specific input and output sockets for actions, objects, and transforms."}
{"question": "def test_verify_plugin_version_success(self, mock_subprocess): result = mock_subprocess.run() result.stdout = b\"9.8.3\" self.assertTrue(verify_plugin_version(\"9.8.3\"))", "answer": "This function tests that the `verify_plugin_version` function returns true when the plugin version matches the expected value \"9.8.3\"."}
{"question": "def test_verify_plugin_version_fail(self, mock_subprocess): with self.assertLogs(\"ssmpfwd.helpers\", level=\"INFO\") as cm: result = mock_subprocess.run() result.stdout = b\"1.8.1\" self.assertFalse(verify_plugin_version(\"9.2.3\")) self.assertEqual( cm.output[0], \"ERROR:ssmpfwd.helpers:session-manager-plugin version 1.8.1 is installed, 9.2.3 is required\" ) }", "answer": "This test verifies that the plugin version check fails when the installed version differs from the required version and logs an appropriate error message."}
{"question": "def setUp(self): @time_decorator def test_func(): self.sleep(0.5) self.time_decorated_method = test_func", "answer": "This function defines a decorated test method that sleeps for half a second and assigns it to an instance attribute."}
{"question": "def test_time_decorator(self): with self.assertLogs(\"ssmpfwd.helpers\", level=\"INFO\") as cm: self.time_decorated_method() self.assertEqual(cm.output[0], \"INFO:ssmpfwd.helpers:[*] starting test_func\")", "answer": "This function tests that calling a time-decorated method logs the expected start message at the INFO level."}
{"question": "def main(): resp = MessagingResponse() resp.message(\"You have reached the DogBot. Thanks for contacting us :)\") return str(resp)", "answer": "This function creates a Twilio messaging response that sends a thank-you message from DogBot and returns it as a string."}
{"question": "class ObjectType(IntEnum): Opaque = 0x01 AuthenticationKey = 0x02 AsymmetricKey = 0x03 WrapKey = 0x04 HmacKey = 0x05 Template = 0x06 OtpAeadKey = 0x07", "answer": "This code defines an enumeration of integer constants representing different object types such as keys, templates, and opaque data."}
{"question": "def test_reactive_servable_title(): doc = Document() session_context = unittest.mock.Mock() with patch_curdoc(doc): doc._session_context = lambda: session_context ReactiveHTML().servable(title='A') ReactiveHTML().servable(title='B') assert doc.title == 'B'", "answer": "This function tests that when multiple ReactiveHTML components are served with different titles, the document's title is set to the last one provided."}
{"question": "def test_link(): class ReactiveLink(Reactive): a = param.Parameter() obj = ReactiveLink() obj2 = ReactiveLink() obj.link(obj2, a='a') obj.a = 1 assert obj.a == 1 assert obj2.a == 1", "answer": "This function tests that linking two ReactiveLink objects synchronizes the value of their shared parameter `a`."}
{"question": "def test_param_rename(): class ReactiveRename(Reactive): a = param.Parameter() _rename = {'a': 'b'} obj = ReactiveRename() params = obj._process_property_change({'b': 1}) assert params == {'a': 1} properties = obj._process_param_change({'a': 1}) assert properties == {'b': 1}", "answer": "This function tests that a parameter in a reactive class can be correctly renamed and mapped between property and parameter changes."}
