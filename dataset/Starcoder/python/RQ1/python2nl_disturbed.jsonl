{"question": "def grid_scan (self) : base = self.tree.getroot () for section in base.findall (\".//%s\" % tag (\"div\")) : if section.get ('id') == 'maincontent' : break grid = section.find (\".//%s\" % tag (\"table\")) if grid is None : return for table_row in grid : if table_row [0].tag == tag ('th') : continue yield (self.tree.get_text (item) for item in table_row)", "answer": "This function locates a specific table within the 'maincontent' section of an XML/HTML tree and yields the text content of each non-header row."}
{"question": "def process (self) : self.connections = {} for row in self.grid_scan () : node, address, link_quality, neighbor_link_quality, etx_value = row link_quality, neighbor_link_quality, etx_value = (float (val) for val in (link_quality, neighbor_link_quality, etx_value)) self.connections [node] = [address, link_quality, neighbor_link_quality, etx_value]", "answer": "This function scans a grid of network data and stores each node’s address and link metrics in a connections dictionary."}
{"question": "def restrict(image, ref_hash, num): comp_hash = compute_hash(image) difference = compare(ref_hash, comp_hash) if difference <= DIFF_LIMIT: if num >= THRESHOLD: return 'remove' else: return 'update_std' return 'continue'", "answer": "This function compares an image's computed hash to a reference hash and returns an action string based on the difference and a numeric threshold."}
{"question": "def scale(image): width = np.shape(image)[1] height = np.shape(image)[0] if width > TARGET_SIZE: ratio = TARGET_SIZE / width scaled_image = cv2.resize( image, (TARGET_SIZE, math.floor(height / ratio)), cv2.INTER_AREA) return scaled_image return image", "answer": "This function resizes an image to a specified target width while maintaining its aspect ratio if the original width exceeds the target size."}
{"question": "class Space_Element(QWidget,Ui_Form): def __init__(self,parent=None,space_info=None): super(Space_Element,self).__init__(parent) self.setupUi(self) self.info = space_info self.configureSpaceInfo()", "answer": "This class initializes a UI widget with provided space information and configures it accordingly."}
{"question": "def log_exception_trace(cls, exception_trace_line): for segment in exception_trace_line.split(\"', '\"): for entry in segment.split(\"\\\\n\"): if entry: print(entry)", "answer": "This function splits an exception trace string into segments and lines, then prints each non-empty line."}
{"question": "def execute_app(self): try: self.initialize() self.native.ThreadException += self.windows_thread_error self.processor.run_continuously(self.app_ctx) except: # NOQA traceback.print_exc()", "answer": "This function initializes the application, sets up a thread exception handler, runs a processor continuously with the application context, and prints any exceptions that occur."}
{"question": "def _setup_application_actions(self): self.interface.actions.add( toga.Command( lambda widget: self.load_document, label='Open...', shortcut=Key.MOD_1 + 'o', group=toga.Group.FILE, section=0 ) )", "answer": "This function adds an \"Open...\" command with a keyboard shortcut to the application's file menu for loading a document."}
{"question": "def attribute_selection_variance(X, limit): selector = VarianceThreshold(threshold=limit) X_chosen = selector.fit_transform(X) filter = selector.get_support() return X_chosen, filter", "answer": "This function selects and returns features from a dataset whose variance exceeds a specified threshold along with a boolean mask indicating the selected features."}
{"question": "def setup_hdf5(path, mode=\"w\", cam_type=\"davis\"): if mode == \"w\": file = h5py.File(path, mode=mode) file.create_group(\"dvs\") file.create_group(\"extra\") if cam_type == \"davis\": file.create_group(\"aps\") file.create_group(\"imu\") elif mode == \"r\": file = h5py.File(path, mode=mode) return file", "answer": "This function creates or opens an HDF5 file at the specified path, initializing specific data groups based on the mode and camera type."}
{"question": "def ObtainRootAsDoubleValue(cls, buffer, position): index = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buffer, position) value = DoubleValue() value.Init(buffer, index + position) return value", "answer": "This function reads a root object from a FlatBuffers buffer at a given position and returns it as a `DoubleValue` instance."}
{"question": "def Accuracy(self): offset = flatbuffers.number_types.UOffsetTFlags.py_type( self._table.Offset(4) ) if offset != 0: return self._table.Get( flatbuffers.number_types.Int16Flags, offset + self._table.Pos ) return 0", "answer": "This function retrieves a 16-bit integer accuracy value from a FlatBuffers table, returning 0 if the value is not present."}
{"question": "def mean(self): total = float(self.total) if not self.window_length: return 0 return total / self.window_length / self.window_span", "answer": "This function calculates and returns the mean value by dividing the total by both the window length and window span, or returns 0 if the window length is zero."}
{"question": "def identifiers(self): output = set() for id in self.controller.metrics: if id[:len(self._identifiers)] == self._identifiers: id = id[len(self._identifiers):] output.add(id[0] if id else '__value__') return output", "answer": "This function returns a set of unique metric identifier suffixes or a default value for metrics whose names start with a specified prefix."}
{"question": "def as_dictionary(self, retrieve_value=None): output = {} for key, value in iteritems(self): if isinstance(value, BasicCounter): if retrieve_value is not None: value = getattr(value, retrieve_value) output[key] = value else: output[key] = value.as_dictionary(retrieve_value) return output", "answer": "This function converts the object and its nested elements into a dictionary, optionally retrieving a specific attribute from any `BasicCounter` instances."}
{"question": "def load_file(self, filepath): try: with open(filepath) as file_ptr: self.metrics = cPickle.load(file_ptr) except: logging.debug(\"cannot load metric from file: %s\" % filepath) return False return True", "answer": "This function attempts to load serialized metrics from a specified file into the object's `metrics` attribute, returning `True` on success and `False` on failure."}
{"question": "def traverse(row, col): if row == len(matrix): return 0 if cache[row][col] == UNDEFINED: cache[row][col] = matrix[row][col] + max(traverse(row + 1, col), traverse(row + 1, col + 1)) return cache[row][col] return traverse(0, 0)", "answer": "This function recursively computes and caches the maximum path sum from the top to the bottom of a matrix by moving to adjacent columns in the next row."}
{"question": "def kornia_color_perturbation_numpy(image, parameter): if parameter * 255 > 1: image = torch.from_numpy(image).permute(2,0,1).unsqueeze(0) image = ColorPerturbation(parameter, parameter, parameter, parameter)(image) image = image.squeeze(0).permute(1,2,0).numpy() return image", "answer": "This function applies a color perturbation to a NumPy image using Kornia if the scaled parameter exceeds a threshold."}
{"question": "def initialize_random(self): if 'random_seed' in self.options.keys(): self.random = random.Random(self.options['random_seed']) else: self.random = random.Random()", "answer": "This function initializes a random number generator using a specified seed from the options if available, or without a seed otherwise."}
{"question": "def obtain_random(self): value = self.random.random() if self.cosine_skew: return 1 - cos(value * pi / 2) else: return value", "answer": "This function generates a random number and optionally applies a cosine-based transformation to skew its distribution."}
{"question": "def verify_hue_shift_threshold( quality_min, quality_max, expected, description): try: Tfda.JpegCompression( quality_lower=quality_min, quality_upper=quality_max) result = TestOutcome.PASS except ValueError: result = TestOutcome.FAIL assert expected == result, description", "answer": "This function tests JPEG compression within a specified quality range and asserts that the outcome matches the expected result."}
{"question": "def test_fg_exchange_quick(): background_data = np.ones(shape=[2, 5, 5, 3]) * -1 background_labels = np.random.rand(2) foreground = np.random.normal(loc=.5, scale=.1, size=[5, 5]) background_set = InMemoryDataset(background_data, background_labels) fg_exchange = ForegroundExchange(background_set, input_dim=(5, 5), normalize_bg=None) exchanged_single_channel = fg_exchange(foreground)[:, :, 0] assert np.array_equal((exchanged_single_channel <= -1), (foreground <= .5))", "answer": "This function tests that the ForegroundExchange correctly replaces background pixels with foreground values based on a threshold condition."}
{"question": "def test_foreground_exchange_numpy(): mnist_set = MNIST(DATA_PATH, download=True, train=True) cifar_set = CIFAR10(DATA_PATH, download=True, train=True) fg_exchange = ForegroundExchange(cifar_set, input_dim=(28, 28)) image = mnist_set.get_data()[0][0] image = fg_exchange(image)", "answer": "This function loads MNIST and CIFAR-10 datasets, creates a ForegroundExchange transformer, and applies it to the first MNIST image."}
{"question": "def test_keeps_remote_address_unchanged_without_real_ip(): remote_address = object() req = unittest.mock.MagicMock() req.META = {\"REMOTE_ADDR\": remote_address} handler.XRealIPHandler(get_reply)(req) assert req.META[\"REMOTE_ADDR\"] is remote_address", "answer": "This function tests that the XRealIPHandler leaves the request's remote address unchanged when no real IP is provided."}
{"question": "def test_replaces_x_real_ip_when_present(): remote_address = object() real_ip_header = object() req = unittest.mock.MagicMock() req.META = {\"REMOTE_ADDR\": remote_address, \"HTTP_X_REAL_IP\": real_ip_header} handler.XRealIPHandler(get_reply)(req) assert req.META[\"REMOTE_ADDR\"] is real_ip_header assert req.META[\"HTTP_X_REAL_IP\"] is real_ip_header", "answer": "This function tests that the XRealIPHandler replaces the REMOTE_ADDR value with the HTTP_X_REAL_IP value when the latter is present in the request metadata."}
{"question": "class Announcer: def __init__(self, identifier): self.notification = directAnnounce.newCategory(identifier)", "answer": "This class initializes an Announcer object that creates a new notification category using the provided identifier."}
{"question": "def __init__(self): super().__init__(SCREEN_WIDTH, SCREEN_HEIGHT, SCREEN_TITLE) self.view = None self.ui_view = None self.points = 0", "answer": "This constructor initializes the object with predefined screen settings and sets up view attributes and a points counter."}
{"question": "def initialize(self): self.view = arcade.Camera(self.width, self.height) self.ui_view = arcade.Camera(self.width, self.height) level_map = \":resources:tiled_maps/map.json\" layer_settings = { \"Platforms\": { \"use_spatial_hash\": True } }", "answer": "This function initializes camera views for the game and sets up layer settings for a specified level map."}
{"question": "def on_key_release(self, key, modifiers): if key == arcade.key.LEFT or key == arcade.key.A: self.gamer_image.move_x = 0 elif key == arcade.key.RIGHT or key == arcade.key.D: self.gamer_image.move_x = 0", "answer": "This function stops the horizontal movement of the player when the left or right movement keys are released."}
{"question": "def ycmd_base_path(self): if self._ycmd_base_path is None: logger.warning('ycmd base path not configured') return self._ycmd_base_path", "answer": "This function returns the stored ycmd base path and logs a warning if it has not been configured."}
{"question": "def ycmd_base_path(self, ycmd_base_path): if ycmd_base_path is not None and not isinstance(ycmd_base_path, str): raise TypeError(ycmd_base_path) self._ycmd_base_path = ycmd_base_path", "answer": "This function sets the `_ycmd_base_path` attribute, raising a `TypeError` if the provided value is not a string or `None`."}
{"question": "def ycmd_config_path(self): if self._ycmd_config_path is None: if self._ycmd_base_path is not None: return get_default_config_path(self._ycmd_base_path) logger.warning('ycmd base path not configured') return self._ycmd_config_path", "answer": "This function returns the stored ycmd configuration path or, if unset but a base path is available, generates and returns a default configuration path, otherwise logs a warning."}
{"question": "def current_folder(self): if self._current_folder is None: return os.getcwd() return self._current_folder", "answer": "This function returns the stored current folder path if set, otherwise it returns the system's current working directory."}
{"question": "def python_executable_location(self): if self._python_executable_location is None: return default_python_executable_location() return self._python_executable_location", "answer": "This function returns a stored Python executable location if available, otherwise it returns a default location."}
{"question": "def server_inactive_termination_seconds(self): if self._server_inactive_termination_seconds is None: return YCMD_DEFAULT_SERVER_INACTIVE_TERMINATION_SECONDS return self._server_inactive_termination_seconds", "answer": "This function returns the configured server inactive termination time in seconds, or a default value if none is set."}
{"question": "def logging_level(self, logging_level): if logging_level is not None and not isinstance(logging_level, str): raise TypeError('logging level must be a str: %r' % logging_level) if logging_level is not None and not _is_valid_logging_level(logging_level): logger.warning('logging level unrecognized: %r', logging_level) self._logging_level = logging_level", "answer": "This function validates and sets the logging level, raising an error for invalid types and warning for unrecognized values."}
{"question": "def std_err_log_path(self, std_err_log_path): if std_err_log_path is not None and not isinstance(std_err_log_path, str): raise TypeError( 'std_err_log_path must be a str: %r' % std_err_log_path ) self._std_err_log_path = std_err_log_path", "answer": "This function sets the object's standard error log path, ensuring it is either a string or None, and raises a TypeError otherwise."}
{"question": "def ycmd_component_directory(self): if self._ycmd_base_path is None: logger.error('ycmd base path not configured') raise AttributeError return os.path.join(self._ycmd_base_path, 'ycmd')", "answer": "This function returns the path to the \"ycmd\" directory within the configured base path, raising an error if the base path is not set."}
{"question": "def operation_finish(self, output): sys.stdout.write(output.ljust(20)) sys.stdout.write(\"\\n\")", "answer": "This function writes the given output left-justified to 20 characters followed by a newline to the standard output."}
{"question": "def send(self, command, paramA=0, paramB=0): buffer = struct.pack(\"<LL\", paramA, paramB) self.stream.write(bytes([command])) self.stream.write(buffer) self.stream.flush()", "answer": "This function sends a command followed by two integer parameters to a stream and then flushes the stream."}
{"question": "def storage_init(self): self.send(0x03) buffer = self.stream.read(4) return struct.unpack(\"<L\", buffer)[0]", "answer": "This function sends an initialization command and reads a 4-byte response from a stream, returning it as an unsigned 32-bit integer."}
{"question": "def __init__(self, cutoff='', *params, **kw_params): self.cutoff = cutoff super(AdherenceEvent, self).__init__(*params, **kw_params)", "answer": "This constructor initializes an AdherenceEvent object by setting its cutoff value and passing additional parameters to its superclass initializer."}
{"question": "def make(self, req, *params, **kw_params): self.converter_class = serializers.PlayDataConverter return super().make(req, *params, **kw_params)", "answer": "This function sets the converter class to `PlayDataConverter` and then calls the parent class's `make` method with the provided arguments."}
{"question": "def check(cls, py): if py not in cls._checks_cache: cls._checks_cache[py] = cls._check(py) return cls._checks_cache[py]", "answer": "This function retrieves a cached check result for a given input or computes and stores it if not already cached."}
{"question": "def execute(self, arguments, **kw_arguments): log.debug(\"Executing '{0}' in {1}\".format(' '.join(arguments), self.identifier)) return self.execute_program('python', arguments, **kw_arguments)", "answer": "This function logs the execution of a Python program with specified arguments and then runs it using the object's execute_program method."}
{"question": "def execute_program(self, program, arguments, **kw_arguments): kw_arguments[\"env\"] = dict(kw_arguments.pop(\"env\", os.environ), PYTHONNOUSERSITE=str(\"True\")) return super(Conda, self).execute_program(program, arguments, **kw_arguments)", "answer": "This function runs a specified program with given arguments while ensuring the environment variable `PYTHONNOUSERSITE` is set to `\"True\"`."}
{"question": "def getmap(self): if self.w_func_map is None: self.w_func_map = self.sp.newdict() return self.w_func_map", "answer": "This function returns the object's function map, creating and storing a new one if it does not already exist."}
{"question": "def setmap(self, sp, w_map): if not sp.is_true(sp.isinstance(w_map, sp.w_dict)): raise OperationError(sp.w_TypeError, sp.wrap(\"setting function's map to a non-dict\")) self.w_func_map = w_map", "answer": "This function sets the object's function map to the given dictionary, raising a type error if the provided value is not a dictionary."}
{"question": "def fget_function_defaults(sp, self): values_w = self.defaults_w if not values_w: return sp.w_None return sp.newtuple(values_w[:])", "answer": "This function returns a tuple of the object's default values or a None value if no defaults are set."}
{"question": "def fget___context__(gap, self): if self.w_unit is None: if self.w_func_state is not None and not gap.has_w(self.w_func_state, gap.w_None): self.w_unit = gap.invoke_method(self.w_func_state, \"get\", gap.bind(\"__name__\")) else: self.w_unit = gap.w_None return self.w_unit", "answer": "This function retrieves and caches a unit value from a given context object, defaulting to a predefined \"None\" value if unavailable."}
{"question": "def descr_method__new__(sp, w_kind, w_callable, w_object, w_type=None): if sp.is_w(w_object, sp.w_None): w_object = None method = sp.allocate_instance(Method, w_kind) Method.__init__(method, sp, w_callable, w_object, w_type) return sp.wrap(method)", "answer": "This function creates and returns a wrapped Method instance using the provided kind, callable, object, and optional type."}
{"question": "def explain_method_hash(self): area = self.area w_output = area.hash(self.w_callable) if self.w_object is not None: w_output = area.xor(w_output, area.hash(self.w_object)) return w_output", "answer": "This function generates a hash value for a callable and optionally combines it with the hash of an associated object using XOR."}
{"question": "def explain_classmethod_fetch(self, area, w_target, w_type=None): if area.is_w(w_type, area.w_None): w_type = area.type(w_target) return area.wrap(Method(area, self.w_callable, w_type, area.w_None))", "answer": "This function determines the appropriate type for a target object if not provided and returns a wrapped method instance using that type."}
{"question": "def explain_builtinfunction__create__(area, w_kind, w_callable): call = area.interp_w(Function, w_callable) nativeFn = area.allocate_instance(BuiltinFunction, w_kind) BuiltinFunction.__init__(nativeFn, call) return area.wrap(nativeFn)", "answer": "This function creates and returns a wrapped instance of a built-in function using the provided callable and kind within the given area."}
{"question": "def benchmark(self, count: int) -> float: if self._measure_unit is None: self._measure_unit = native_jit.compile_timeit_template( self._expr, self._prepare, ) return self._measure_unit.timeit(count)", "answer": "This function compiles a timing measurement unit if not already created and returns the execution time for running a specified number of iterations."}
{"question": "def hasUpperBoundSealed(self): if self.highCut.node is None: raise TypeError(\"Range unbounded above\") else: return not self.highCut.under", "answer": "This function checks whether the upper bound of a range is sealed, raising an error if the range has no upper bound."}
{"question": "def hasLowerBoundSealed(self): if self.lowCut.node is None: raise TypeError(\"Range unbounded below\") else: return self.lowCut.under", "answer": "This function checks if the lower bound of a range is defined and returns its \"under\" status, raising an error if the range is unbounded below."}
{"question": "def contains(self, peer): if not isinstance(peer, Range): raise ValueError(\"Range required\") return (self.lowCut <= peer.lowCut) and (self.highCut >= peer.highCut)", "answer": "This function checks whether a given Range object is fully contained within the current Range, raising an error if the input is not a Range."}
{"question": "class AUTO: PATHFINDER = \"NISSAN X-TRAIL 2017\" ECHO = \"NISSAN LEAF 2018\" ECHO_IC = \"NISSAN LEAF 2018 Instrument Cluster\" DRIFTER = \"NISSAN ROGUE 2019\" SEDONA = \"NISSAN ALTIMA 2020\"", "answer": "This class defines constant string attributes representing specific Nissan car models and their variants."}
{"question": "def read_reply(self, reply): self.__tracer.debug( 'Saving file to download path: {}'.format(Settings.download_path) ) with open(Settings.download_path, 'wb+') as f: for chunk in reply.raw.stream(1024, decode_content=False): if chunk: f.write(chunk) self.__tracer.debug('File saved successfully')", "answer": "This function logs the download path, writes streamed binary data from a reply object to a file at that path, and logs when the file is saved successfully."}
{"question": "def send_features(self, features): box_list = self.box_head.get_bboxes(*features) box_results = [ box2map(det_boxes, det_tags, self.box_head.num_classes) for det_boxes, det_tags in box_list ] return box_results[0]", "answer": "This function processes input features to generate bounding boxes with associated tags and returns the mapped results for the first set."}
{"question": "def test_billing_agent_host_value(self): expected_name = 'my agent' self.assertEqual(expected_name, self.client.host)", "answer": "This function verifies that the billing agent's host name matches the expected value \"my agent\"."}
{"question": "def test_add_billing_label_with_bad_driver_impl(self): del self.backend.add_metering_label with mock.patch.object(billing_agent, 'LOG') as log: self.client.add_metering_label(None, ROUTERS) log.exception.assert_called_with( mock.ANY, {'driver': 'noop', 'func': 'add_billing_label'} )", "answer": "This function tests that an exception is logged when attempting to add a billing label with a missing driver implementation."}
{"question": "def test_setup_chain(self): with mock.patch( 'oslo_service.periodic_task.PeriodicTasks.__init__' ) as init: billing_agent.BillingAgent('my agent', cfg.CONF) init.assert_called_once_with(cfg.CONF)", "answer": "This function tests that initializing a `BillingAgent` correctly calls the `PeriodicTasks` constructor with the provided configuration."}
{"question": "def FetchStatusCode(host, path=\"/\"): try: link = HTTPConnection(host) link.request(\"HEAD\", path) return link.getresponse().status except Exception: return None", "answer": "This function sends an HTTP HEAD request to a specified host and path, returning the response status code or None if an error occurs."}
{"question": "def WaitReady(host, path=\"/\"): while FetchStatusCode(host, path) != 200: sleep(5)", "answer": "This function repeatedly checks a given host and path until it returns an HTTP 200 status code, pausing five seconds between attempts."}
{"question": "def load_corrections(self, columns, dts, assets): result = [None] * len(columns) for i, field in enumerate(columns): maps = {} for item in assets: maps.update(self._fetch_corrections_in_range(item, dts, field)) result[i] = maps return result", "answer": "This function retrieves and aggregates correction mappings for each specified column across multiple assets within a given date range."}
{"question": "def __init__(self, trading_schedule, asset_locator, bar_loader, roll_resolvers, interval): self._trading_schedule = trading_schedule self._asset_locator = asset_locator self._bar_loader = bar_loader self._roll_resolvers = roll_resolvers self._interval = interval", "answer": "This constructor initializes an object with provided trading schedule, asset locator, bar loader, roll resolvers, and interval settings."}
{"question": "def load_revisions(self, columns, dts, assets): res = [None] * len(columns) for i, field in enumerate(columns): edits = {} for item in assets: edits.update(self._fetch_revisions_in_range(item, dts, field)) res[i] = edits return res", "answer": "This function retrieves and aggregates revision data for specified columns across multiple assets within a given date range, returning the results as a list of dictionaries."}
{"question": "def _slice(self, dates, symbols, column): return self._loader.load_raw_arrays( [column], dates[0], dates[-1], symbols )[0]", "answer": "This function retrieves a specific data column for given dates and symbols from the loader and returns the first resulting array."}
{"question": "def _calendar(self): mm = self.trading_schedule.all_minutes begin = mm.searchsorted(self._source.first_trading_day) finish = mm.searchsorted(self._source.last_available_dt, side='right') return mm[begin:finish]", "answer": "This function returns the range of trading minutes between the first trading day and the last available date from the trading schedule."}
{"question": "def _execute(self, command, **kwargs): params = kwargs params.update({'command': command, 'sessionkey': self.session_token}) resp = requests.get(self.endpoint, params=params) return resp", "answer": "This function sends a GET request to a specified endpoint with the given command and session token included in the request parameters."}
{"question": "class Migration(migrations.Migration): dependencies = [ ('catalog', '0002_tag'), ] operations = [ migrations.AddField( model_name='item', name='tags', field=models.ManyToManyField( related_name='items', to='catalog.Tag', verbose_name='Теги' ), ), ]", "answer": "This migration adds a many-to-many \"tags\" field to the Item model linking it to the Tag model in the catalog app."}
{"question": "def _fetch_task_logs(self, source): while True: text = source.readline() if isinstance(text, bytes): text = text.decode('utf-8') if not text: break self.log.info( 'Job %s: Subtask %s %s', self._task_context.job_id, self._task_context.task_id, text.rstrip('\\n') )", "answer": "This function continuously reads lines from a given source, decodes them if necessary, and logs each line with associated job and task identifiers until no more data is available."}
{"question": "def on_complete(self) -> None: if self._conf_path and os.path.isfile(self._conf_path): if self.exec_as_user: subprocess.call(['sudo', 'rm', self._conf_path], close_fds=True) else: os.remove(self._conf_path) try: self._error_stream.close() except FileNotFoundError: pass", "answer": "This function deletes a configuration file if it exists, using elevated privileges if specified, and then attempts to close an associated error stream."}
{"question": "class Settings: SECRET_KEY = os.environ.get('SECRET_KEY') SQLALCHEMY_DATABASE_URI = 'postgresql+psycopg2://fidel:fidel@localhost/blog' UPLOADED_PHOTOS_DEST = 'app/static/photos' QUOTES_URL = 'http://quotes.stormconsultancy.co.uk/random.json' MAIL_SERVER = 'smtp.googlemail.com' MAIL_PORT = 587 MAIL_USE_TLS = True MAIL_USERNAME = os.environ.get(\"MAIL_USERNAME\") MAIL_PASSWORD = os.environ.get(\"MAIL_PASSWORD\")", "answer": "This class defines configuration settings for a web application, including database connection, file upload location, external API URL, and email server credentials."}
{"question": "def refresh(self): self.store.update() signal = copy.deepcopy(self.store.event) if signal is None: self._signal = signal return signal = compute_offset(signal, OFFSET) self._limit_reached = is_limit_reached(signal) self._signal = signal", "answer": "This function updates the store, processes its event with an offset, checks if a limit is reached, and stores the resulting signal."}
{"question": "def format_times(self, record): record[\"start\"] = self.fetch_date_rendered( record[\"start\"], record[\"all_day\"] ) record[\"end\"] = self.fetch_date_rendered( record[\"end\"], record[\"all_day\"] ) return record", "answer": "This function updates a record's start and end times by rendering them with a date formatting method that accounts for all-day events."}
{"question": "def fetch_date_rendered(self, ts, is_full_day): if is_full_day: return ts.strftime(\"%Y-%m-%d\") return ts.strftime(\"%Y-%m-%dT%H:%M:%S.%f%z\")", "answer": "This function returns a formatted date string from a timestamp, using a date-only format for full-day events and a detailed datetime format otherwise."}
{"question": "def fetch_image_id_from_path_name(path_name, id_cursor): path_name = os.path.splitext(path_name)[0] if path_name.isdigit(): return int(path_name) return id_cursor", "answer": "This function returns the numeric ID extracted from a file path name if it is entirely digits, otherwise it returns the provided fallback ID."}
{"question": "def label_parser(labels_str): labels = [] for label_str in labels_str: label = list(map(int, label_str.strip().split(','))) labels.append(label) return labels", "answer": "This function converts a list of comma-separated numeric strings into a list of integer lists."}
{"question": "def compute_time_offset(self, arguments={}): origin_time = self.fetch_time(arguments) later = self.milliseconds() self.options['timeOffset'] = later - origin_time return self.options['timeOffset']", "answer": "This function calculates and stores the difference in milliseconds between a fetched origin time and the current time."}
{"question": "def decode_order_state(self, state): mapping = { 'NEW': 'open', 'PARTIALLY_FILLED': 'open', 'FILLED': 'closed', 'CANCELED': 'canceled', 'PENDING_CANCEL': 'canceling', 'REJECTED': 'rejected', 'EXPIRED': 'expired', } return self.safe_string(mapping, state, state)", "answer": "This function translates an order state code into a corresponding human-readable status, defaulting to the original code if no match is found."}
{"question": "def build_reduce_only_order(self, symbol, type, side, amount, price=None, options={}): payload = { 'reduceOnly': True, } return self.create_order(symbol, type, side, amount, price, self.extend(payload, options))", "answer": "This function creates a reduce-only order for a specified trading symbol with given parameters and optional settings."}
{"question": "def load_closed_orders(self, symbol=None, since=None, limit=None, options={}): results = self.fetch_orders(symbol, since, limit, options) return self.filter_by(results, 'status', 'closed')", "answer": "This function retrieves orders based on given parameters and returns only those with a status of \"closed.\""}
{"question": "def decode_incomes(self, incomes, market=None, since=None, limit=None): outputs = [] for i in range(len(incomes)): entry = incomes[i] decoded = self.parse_income(entry, market) outputs.append(decoded) ordered_outputs = self.sort_by(outputs, 'timestamp') return self.filter_by_since_limit(ordered_outputs, since, limit)", "answer": "This function parses a list of income entries, sorts them by timestamp, and returns the results filtered by optional date and limit parameters."}
{"question": "def decode_trading_fee(self, fee, market=None): market_key = self.safe_string(fee, 'symbol') symbol = self.safe_symbol(market_key) return { 'info': fee, 'symbol': symbol, 'maker': self.safe_number(fee, 'makerCommission'), 'taker': self.safe_number(fee, 'takerCommission'), }", "answer": "This function extracts and returns a structured trading fee object containing the market symbol and maker/taker commission values from the given fee data."}
{"question": "def load_trading_fee(self, symbol, params={}): self.load_markets() market = self.market(symbol) payload = { 'symbol': market['id'], } replies = self.sapiGetAssetTradeFee(self.extend(payload, params)) primary = self.safe_value(replies, 0, {}) return self.parse_trading_fee(primary)", "answer": "This function retrieves and parses the trading fee information for a specified market symbol."}
{"question": "def apply_margin_mode(self, margin_kind, symbol=None, params={}): margin_kind = margin_kind.upper() if margin_kind != 'ISOLATED' and margin_kind != 'CROSSED': raise BadRequest(self.id + ' marginType must be either isolated or crossed') self.load_markets() market = self.market(symbol) endpoint = None if market['linear']: endpoint = 'fapiPrivatePostMarginType' elif market['inverse']: endpoint = 'dapiPrivatePostMarginType' else: raise NotSupported(self.id + ' setMarginMode() supports linear and inverse contracts only') payload = { 'symbol': market['id'], 'marginType': margin_kind, } return getattr(self, endpoint)(self.extend(payload, params))", "answer": "This function sets the margin mode to either isolated or crossed for a specified trading symbol, validating the type and sending the appropriate API request based on the contract type."}
{"question": "def perform(self, path, api='public', method='GET', args=None, headers=None, body=None, opts=None, scope=None): if args is None: args = {} if opts is None: opts = {} if scope is None: scope = {} result = self.fetch2(path, api, method, args, headers, body, opts, scope) if api == 'private' or api == 'wapi': self.options['hasAlreadyAuthenticatedSuccessfully'] = True return result", "answer": "This function sends an API request with specified parameters, updates authentication status if using certain APIs, and returns the response."}
{"question": "def setup(self, env): super(SetTransformNode, self).init(env) self.add_input('ArmNodeSocketAction', 'In') self.add_input('ArmNodeSocketObject', 'Object') self.add_input('NodeSocketShader', 'Transform') self.add_output('ArmNodeSocketAction', 'Out')", "answer": "This function initializes a SetTransformNode instance with specified input and output sockets for action, object, and transform data."}
{"question": "def test_check_plugin_version_pass(self, fake_subprocess): outcome = fake_subprocess.run() outcome.stdout = b\"9.8.3\" self.assertTrue(verify_plugin_version(\"9.8.3\"))", "answer": "This function tests that the plugin version verification passes when the subprocess output matches the expected version \"9.8.3\"."}
{"question": "def test_check_plugin_version_fail(self, fake_subprocess): with self.assertLogs(\"ssmpfwd.helpers\", level=\"INFO\") as cm: outcome = fake_subprocess.run() outcome.stdout = b\"1.8.1\" self.assertFalse(verify_plugin_version(\"9.2.3\")) self.assertEqual( cm.output[0], \"ERROR:ssmpfwd.helpers:session-manager-plugin version 1.8.1 is installed, 9.2.3 is required\" )", "answer": "This function tests that when the installed plugin version differs from the required version, the verification fails and logs an appropriate error message."}
{"question": "def setUp(self): @time_decorator def demo_func(): self.sleep(0.5) self.timed_wrapped_method = demo_func", "answer": "This function defines a decorated method that sleeps for half a second and assigns it to an instance variable for later use."}
{"question": "def test_timing_decorator(self): with self.assertLogs(\"ssmpfwd.helpers\", level=\"INFO\") as cm: self.timed_wrapped_method() self.assertEqual(cm.output[0], \"INFO:ssmpfwd.helpers:[*] starting test_func\")", "answer": "This test verifies that calling the decorated method logs an INFO message indicating the start of the function execution."}
{"question": "def entry(): reply = MessagingResponse() reply.message(\"You have reached the DogBot. Thanks for contacting us :)\") return str(reply)", "answer": "This function creates and returns a text message response indicating the user has reached DogBot and thanking them for making contact."}
{"question": "class ItemType(IntEnum): Hidden = 0x01 AuthKey = 0x02 AsymKey = 0x03 WrapKey = 0x04 HmacKey = 0x05 Template = 0x06 OtpAeadKey = 0x07", "answer": "This code defines an enumeration of item types with specific integer values representing different kinds of keys and templates."}
{"question": "def test_reactive_servable_header(): page = Document() session_handle = unittest.mock.Mock() with patch_curdoc(page): page._session_context = lambda: session_handle ReactiveHTML().servable(title='A') ReactiveHTML().servable(title='B') assert page.title == 'B'", "answer": "This function tests that when multiple ReactiveHTML components are made servable with different titles, the page's title is set to the last one provided."}
{"question": "def test_bind(): class ReactiveBind(Reactive): a = param.Parameter() left = ReactiveBind() right = ReactiveBind() left.link(right, a='a') left.a = 1 assert left.a == 1 assert right.a == 1", "answer": "This function tests that linking two `ReactiveBind` instances synchronizes their `a` parameter values."}
{"question": "def test_param_alias(): class ReactiveAlias(Reactive): a = param.Parameter() _rename = {'a': 'b'} inst = ReactiveAlias() args = inst._process_property_change({'b': 1}) assert args == {'a': 1} props = inst._process_param_change({'a': 1}) assert props == {'b': 1}", "answer": "This function tests that a parameter alias correctly maps changes between its internal name and external name in both directions."}
