{"question": "Write a function that write a method to take perSiteResults dictionary in and add a column Ca5C", "answer": "def useLDAmodel(self, kinetics, pos, model, up, down): \"\"\" Test out LDA model \"\"\" res = np.zeros((up + down + 1, 5)) ind = 0 # range from -down to +up for offset in range(-down, (up + 1)): a = pos + offset # res[ind,] = [kinetics[a][\"tMean\"], kinetics[a][\"modelPrediction\"], kinetics[a][\"tErr\"], kinetics[a][\"coverage\"]] res[ind, ] = [kinetics[a][\"tMean\"], kinetics[a][\"modelPrediction\"], kinetics[a][\"tErr\"], kinetics[a][\"coverage\"], np.exp(kinetics[a][\"tStatistic\"]) - 0.01] ind += 1 apply = np.hstack(np.log(res + 0.01).transpose()) tmp = sum(np.multiply(apply, model[1:])) + model[0] return tmp"}
{"question": "Write a function that write string to each open file descriptor in the list", "answer": "def writeres(s, fdlist): for x in fdlist: x.write(s) x.flush() if x.fileno() != 1: os.fsync(x.fileno())"}
{"question": "Write a function that Write a function called next_fib. next_fib should take have two parameters: a list of integers and a single integer. For this description, we'll call the single integer n. next_fib should modify the list to add the next n pseudo- Fibonacci numbers to the end of the sequence. A pseudo- Fibonacci number is the sum of the previous two numbers in the sequence, but in our case, the previous two numbers may not be the original numbers from the Fibonacci sequence. For example, if the original list given was: a_list = [5, 5, 10, 15, 25, 40, 65] Then next_fib(a_list, 3) would return: [5, 5, 10, 15, 25, 40, 65, 105, 170, 275] All the original numbers in the list are still there, and three new ones have been added. You may assume the list parameter will always have at least two numbers. HINT: Python gets mad if you try to change a list while iterating over it with a for-each loop. You'll have to get clever with a for or while loop to do this! Add your code here!", "answer": "def next_fib( a_list , num ): while num > 0: last = a_list.pop() next_to_last = a_list.pop() new = last + next_to_last a_list.append(next_to_last) a_list.append(last) a_list.append(new) num -= 1 return a_list"}
{"question": "Write a function that Write a python script to find the repeated items of a tuple", "answer": "def find_duplicates(ls): dup_items = [] for i in range(len(ls)): if ls.count(ls[i]) > 1: dup_items.append(ls[i]) return list(set(dup_items))"}
{"question": "Write a function that Write a Python program to calculate midpoints of a line", "answer": "def mid(x1,y1,x2,y2): xm = (x1+x2)/2 ym = (y1+y2)/2 return xm,ym"}
{"question": "Write a function that Write a function that combines two lists by alternatingly taking elements. For example: given the two lists [a, b, c] and [1, 2, 3], the function should return [a, 1, b, 2, c, 3].", "answer": "def alternatively_combine(list1, list2): result = [] bigger_list_len = len(list1) > len(list2) and len(list1) or len(list2) for i in range(0, bigger_list_len): if len(list1) > i: result.append(list1[i]) if len(list2) > i: result.append(list2[i]) return result"}
{"question": "Write a function that Write a program (function!) that takes a list and returns a new list that contains all the elements of the first list minus all the duplicates. Extras: #Write two different functions to do this - one using a loop and constructing a list, and another using sets. #Go back and do Exercise 5 using sets, and write the solution for that in a different function.", "answer": "def unique_list(list): unique = [] for i in list: if i not in unique: unique.append(i) return unique"}
{"question": "Write a function that Write timer callback. Emulate hardware: if there's data in the buffer write some or all of it", "answer": "def do_output(self, t): if self.wch: self.wbuf[self.widx] = self.wch self.widx += 1 if self.wch == ord('\\n'): self.wprint_len = self.widx # Save for schedule micropython.schedule(printbuf, self) self.widx = 0 self.wch = b''"}
{"question": "Write a function that Write a program to check whether a number is an even multiple of 3 for more info on this quiz, go to this url: http://www.programmr.com/even-multiple-3", "answer": "def even_multiple_of_3(number): if number % 3 == 0 and number % 2 == 0: return True else: return False"}
{"question": "Write a function that Write a function that when given a URL as a string, parses out just the domain name and returns it as a string. For example: domain_name(\"http://github.com/carbonfive/raygun\") == \"github\" domain_name(\"http://www.zombie-bites.com\") == \"zombie-bites\" domain_name(\"https://www.cnet.com\") == \"cnet\"", "answer": "def domain_name(url): \"\"\" url: url of a website to split from \"/\" and \".\" return: domain name from the url \"\"\" domain_list = ([elt.split(\".\") for elt in url.split(\"/\")]) for elt in domain_list: name = ([elt[i] for i in range(len(elt)) if elt[i] != \"www\" and elt[i] != \"http:\" and elt[i] != \"https:\" and elt[i] != \"\"]) if name != []: return name[0]"}
{"question": "Write a function that Write data from the device in a file for future analysis", "answer": "def writeData(device,data): with open('visuapp/static/data/'+device+'.json', 'w') as outfile: json.dump(data, outfile) outfile.close()"}
{"question": "Write a function that Write a function that checks whether an element occurs in a list.", "answer": "def check_element(list_1, a): if a in list_1: print(a, \"element occurs in a list\") else: print(a,\"element not occurs in a list\")"}
{"question": "Write a function that write test cases with arguments 85 and 63 for recursive_decimal_binary function", "answer": "def test_rdb_w_base(self): self.assertEqual('00000000',recursive_decimal_binary(0,7))"}
{"question": "Write a function that Write a function that takes a list of words as an input argument and returns True if the list is sorted and returns False otherwise.", "answer": "def sorted(line): lista1 = [] lista2 = [] for x in line: lista1 += (x[0]) lista2 += (x[0]) lista2.sort() return lista1 == lista2"}
{"question": "Write a function that Write a program to catch at least 3 exceptions while manipulating the dictionary data structure.", "answer": "def square(num): print(\"The square is\", num**2)"}
{"question": "Write a function that Write a single register cmd = 0x32 value = 0x80 bus.write_byte_data(self.MCUI2CAddress, cmd, value) Write an array of registers values = [0xff, 0xff, 0xff, 0xff, 0xff, 0xff] bus.write_i2c_block_data(self.MCUI2CAddress, cmd, values)", "answer": "def sendToMCU(self, cmdId, value): self.i2cBus.write_byte_data(self.MCUI2CAddress, cmdId, value) return"}
{"question": "Write a function that Write text to file, or save it in a buffer, or ignore it", "answer": "def write(self, *args): try: text = ''.join(args) except: print(args) raise TypeError if self.savetext is not None: self.savetext = self.savetext + text elif self.nodefp: self.nodefp.write(text) elif self.node: self.node.write(text)"}
{"question": "Write a function that Write a byte to our writefd, which will unblock the call to select() inside run() This allows us to write data out (if len(packages) > 0) or exit this thread", "answer": "def update(self) : os.write(self.writefd, bytes([0]))"}
{"question": "Write a function that write a recursive function that will print n integers in first decreasing and then in increasing order", "answer": "def print_decreasing_increasing(n): if n==0: return else: print(n) print_decreasing_increasing(n-1) print(n)"}
{"question": "Write a function that Write a function here that creates a turtle and draws a shape with it.", "answer": "def triangle_boogie(color, start): t = turtle.Turtle() t.speed(0) t.right(start) for shape in range(6): if shape % 2 == 0: t.color(\"purple\") t.width(shape) else: t.color(color) t.width(shape) for side in range(3): t.forward(100) t.right(120) t.right(15) t.hideturtle()"}
{"question": "Write a function that Write out a prototype for a C-style command to populate a Dispatch table self the ApiDumpOutputGenerator object", "answer": "def outputDispatchPrototypes(self): table_helper = '\\n' table_helper += '// Prototype for dispatch table helper function\\n' table_helper += 'void GeneratedXrPopulateDispatchTable(struct XrGeneratedDispatchTable *table,\\n' table_helper += ' XrInstance instance,\\n' table_helper += ' PFN_xrGetInstanceProcAddr get_inst_proc_addr);\\n' return table_helper"}
{"question": "Write a function that write a character to lcd (or character rom) 0x09: backlight | RS=DR< works!", "answer": "def write_char(self, charvalue, mode=1): self.write_four_bits(mode | (charvalue & 0xF0)) self.write_four_bits(mode | ((charvalue << 4) & 0xF0))"}
{"question": "Write a function that Write list functions that carry out the following tasks for a list of integers. For each function, provide a test program. h. Return true if the list is currently sorted in increasing order. FUNCTIONS", "answer": "def is_sorted(list): sortedBool = False for i in range(0, len(list) - 1): if list[i] < list[i + 1]: sortedBool = True else: return False return sortedBool"}
{"question": "Write a function that Generate SQL to materialize a query envelope in EPSG:3857. Densify the edges a little so the envelope can be safely converted to other coordinate systems.", "answer": "def envelopeToBoundsSQL(self, env): DENSIFY_FACTOR = 4 env['segSize'] = (env['xmax'] - env['xmin'])/DENSIFY_FACTOR sql_tmpl = 'ST_Segmentize(ST_MakeEnvelope({xmin}, {ymin}, {xmax}, {ymax}, 3857),{segSize})' return sql_tmpl.format(**env)"}
{"question": "Write a function that generate the distribution of STY from mappings (as a list of 4-element lists, e1, e2, cui, sty, see above)", "answer": "def generate_dist_STY(mappings): dict_onto_STY_freq = defaultdict(int) for m in mappings: dict_onto_STY_freq[m[3]] += 1 #rank cntr_dict_onto_STY_freq = Counter(dict_onto_STY_freq) list_STY_freq_precent = [] for STY,freq in cntr_dict_onto_STY_freq.most_common(): percent = float(freq)/len(mappings) list_STY_freq_precent.append(STY.replace(',','_') + ',' + str(freq) + ',' + '%.2f%%' % (percent*100)) return list_STY_freq_precent"}
{"question": "Write a function that Generate the different renderings and concatenate the diffuse an specular renderings.", "answer": "def __generateRenderings(self, renderer): diffuses = helpers.tf_generateDiffuseRendering(self.batchSize, self.nbDiffuseRendering, self.targets, self.outputs, renderer) speculars = helpers.tf_generateSpecularRendering(self.batchSize, self.nbSpecularRendering, self.surfaceArray, self.targets, self.outputs, renderer) targetsRendered = tf.concat([diffuses[0],speculars[0]], axis = 1) outputsRendered = tf.concat([diffuses[1],speculars[1]], axis = 1) return targetsRendered, outputsRendered"}
{"question": "Write a function that Generate an invalid (maybe) sample adapted to the given teacher.", "answer": "def sampleGeneration_invalid(teacher, upperGuard, length): assert length > 0 sample_prefix = None while sample_prefix is None: sample_prefix = sampleGeneration_valid(teacher, upperGuard, length) action = random.choice(teacher.inputs) time = random.randint(0, upperGuard * 3 + 1) if time % 2 == 0: time = time // 2 else: time = time // 2 + 0.1 index = random.randint(0, len(sample_prefix) - 1) sample_prefix[index] = TimedWord(action, time) return sample_prefix"}
{"question": "Write a function that Generate code to check for a specific condition before executing validation code", "answer": "def genConditionalCall(self, prefix, condition, exprs): checkedExpr = [] localIndent = '' formattedCondition = condition.format(prefix) checkedExpr.append(localIndent + 'if ({})\\n'.format(formattedCondition)) checkedExpr.append(localIndent + '{\\n') localIndent = self.incIndent(localIndent) for expr in exprs: checkedExpr.append(localIndent + expr) localIndent = self.decIndent(localIndent) checkedExpr.append(localIndent + '}\\n') return [checkedExpr]"}
{"question": "Write a function that Generate the struct member check code from the captured data", "answer": "def processStructMemberData(self): indent = self.incIndent(None) for struct in self.structMembers: # # The string returned by genFuncBody will be nested in an if check for a NULL pointer, so needs its indent incremented lines, unused = self.genFuncBody('{funcName}', struct.members, '{valuePrefix}', '{displayNamePrefix}', struct.name) if lines: self.validatedStructs[struct.name] = lines"}
{"question": "Write a function that generate python, numpy and mxnet datasets with the given seed", "answer": "def gen_data(seed=None): with random_seed(seed): python_data = [rnd.random() for _ in range(size)] np_data = np.random.rand(size) mx_data = mx.random.uniform(shape=shape, ctx=ctx).asnumpy() return (seed, python_data, np_data, mx_data)"}
{"question": "Write a function that Generate AssemblyInfo.cs files with the right version numbers by using ``AssemblyInfo.cs.in`` files as a template", "answer": "def mk_all_assembly_infos(major, minor, build, revision): for c in get_components(): if c.has_assembly_info(): c.make_assembly_info(major, minor, build, revision)"}
{"question": "Write a function that Generate a .def based on the files at c.export_files slot.", "answer": "def mk_def_file(c): defname = '%s.def' % os.path.join(c.src_dir, c.name) dll_name = c.dll_name export_header_files = [] for dot_h in c.export_files: dot_h_c = c.find_file(dot_h, c.name) api = os.path.join(dot_h_c.src_dir, dot_h) export_header_files.append(api) mk_genfile_common.mk_def_file_internal(defname, dll_name, export_header_files) if VERBOSE: print(\"Generated '%s'\" % defname)"}
{"question": "Write a function that Generate the requested sector immediately, so the following show_block's work self.terraingen.generate_sector(sector)", "answer": "def hide_sector(self, sector): #TODO: remove from memory; save #for position in self.sectors.get(sector, ()): # if position in self.shown: # self.hide_block(position) pass"}
{"question": "Write a function that generate bearer token to authenticate with PAS portal, Input : Client ID, Client Secret", "answer": "def handle_auth(**kwargs): post_data = {\"grant_type\": \"client_credentials\", \"scope\": kwargs['oauth_scope']} response = requests.post(kwargs['endpoint'], data=post_data, auth=(kwargs['client_id'], kwargs['client_password']), verify=True, timeout=(5, 30)) raise_for_status(response) try: return response.json()['access_token'] except KeyError: raise RuntimeError('OAuth request to tenant was unsuccessful')"}
{"question": "Write a function that generate weights for each slot based on its number of iterations", "answer": "def reward_slot_weights(slot_iterations, iteration): slot_weights = [] for x in range(len(slot_iterations)): slot_weights.append(reward_slot_weight(slot_iterations, x, iteration)) return slot_weights"}
{"question": "Write a function that generate client ID with pub prefix randomly client_id = f'rpi-dht-mqtt-{random.randint(0, 1000)}' username = 'emqx' password = 'public'", "answer": "def connect_mqtt(broker, port, client_id): def on_connect(client, userdata, flags, rc): if rc == 0: print(\"Connected to MQTT Broker!\") else: print(\"Failed to connect, return code %d\\n\", rc) client = mqtt.Client(client_id) # client.username_pw_set(username, password) client.on_connect = on_connect client.connect(broker, port) return client"}
{"question": "Write a function that Generate text data with spurious features make the labels to be correlated with color, not the digit itself or the other way", "answer": "def sample_uniform(): feature = np.zeros((6)) feature[0] = np.random.randint(2) #character feature[1] = np.random.uniform() #x feature[2] = np.random.uniform() #y feature[3] = 0 feature[4] = np.random.uniform() # shade feature[5] = 0 return feature"}
{"question": "Write a function that Generate a new bottom row of random values for the flames", "answer": "def generate_line(start=MIN_BRIGHTNESS, end=MAX_BRIGHTNESS): \"start and end define range of dimmest to brightest 'flames'\" return [start + random.randrange(end-start) for i in range(DISPLAY_WIDTH)]"}
{"question": "Write a function that Generate list of submodules path in repository, excluding the path in IGNORES_SUBMODULES_LIST.", "answer": "def get_all_submodules(): info_dict = {} repo = Repo(REPO_PATH) for submodule in repo.submodules: path = submodule.abspath.replace(REPO_PATH+'/', '') if path not in IGNORE_SUBMODULES_LIST: #print(path,':',submodule.module().head.commit) info_dict[path] = submodule.module().head.commit return info_dict"}
{"question": "Write a function that generate a sequence of frames of a dot moving across an image", "answer": "def build_frames(timesteps,width,height, ch=1): frames = list() # create the first frame frame = np.zeros((width,height)) step = random.randint(0, timesteps-1) # decide if we are heading left or right right = 1 if random.random() < 0.5 else 0 col = 0 if right else timesteps-1 frame[step, col] = 1 frames.append(frame) # create all remaining frames for i in range(1, timesteps): col = i if right else timesteps-1-i frame, step = next_frame(step, frame, col) frames.append(frame) return frames, right"}
{"question": "Write a function that generate multiple sequences of frames and reshape for network input", "answer": "def generate_examples(n_patterns,timesteps,width,height,channels): X, y = list(), list() for _ in range(n_patterns): frames, right = build_frames(timesteps,width,height, ch=channels) X.append(frames) y.append(right) import pdb;pdb.set_trace() # resize as [samples, timesteps, width, height, channels] X = np.array(X).reshape(n_patterns, timesteps,width,height, channels) y = np.array(y).reshape(n_patterns, 1) return X, y"}
{"question": "Write a function that Generate a copy of the key except that the is_diff is True.", "answer": "def make_diff_key(self) -> 'MetricKey': return self._replace(is_diff=True)"}
{"question": "Write a function that Generate a copy of the key with a different model name and is_diff False.", "answer": "def make_baseline_key(self, model_name: Text) -> 'MetricKey': return self._replace(model_name=model_name, is_diff=False)"}
{"question": "Write a function that generate ground truth measurement vector gz, noisy measurement vector z", "answer": "def gen_measurement(x_true): # x position [m], y position [m] gz = hx @ x_true z = gz + z_noise @ np.random.randn(4, 1) return z.astype(float)"}
{"question": "Write a function that Generate the list of <input> subexpression as specified by grammar for ArithmeticGenericOp", "answer": "def _generate_input_desc(categories_idx, integers, reals): input_desc = \"\" for i, (category, idx) in enumerate(categories_idx): if category == \"edge\": input_desc += \"&{}\".format(idx) elif category == \"integer\": input_desc += \"${}:{}\".format(idx, _to_type_desc(integers[idx])) elif category == \"real\": input_desc += \"${}:{}\".format(idx, _to_type_desc(reals[idx])) if i < len(categories_idx) - 1: input_desc += \" \" return input_desc"}
{"question": "Write a function that generate python, numpy and mxnet datasets with the given seed", "answer": "def gen_data(seed=None): with random_seed(seed): python_data = [rnd.random() for _ in range(size)] np_data = np.random.rand(size) mx_data = mx.nd.random_uniform(shape=shape, ctx=ctx).asnumpy() return (seed, python_data, np_data, mx_data)"}
{"question": "Write a function that Generate a line chart that visualizes the readings in the months", "answer": "def line_chart(df,period,col): \"\"\" A line chart that visualizes the readings in the months This function accepts the dataframe df ,period(day/month/year) and col(feature), which plots the aggregated value of the feature based on the periods. Ensure the period labels are properly named. Keyword arguments: df - Pandas dataframe which has the data. period - Period of time over which you want to aggregate the data col - Feature of the dataframe \"\"\" plt.plot(period,df[col], color = 'blue') plt.ylabel(col) plt.xticks(rotation = 90) plt.show()"}
{"question": "Write a function that generate single mutants for those positions that experimental data and alignment are available", "answer": "def mutate_single(wt,mutation_data,offset=0,index=0): mutants=[] prev=int(mutation_data[0][1])-offset for md in mutation_data: if prev!=int(md[1])-offset: index+=1 prev=int(md[1])-offset mutant=[md[2] if i==index else wt[i] for i in range (len(wt))] mutants.append(mutant) return mutants"}
{"question": "Write a function that generate poems from a file out: list of poem lines", "answer": "def generate_poems(filename): g = [] # get to the first poem in the file with open(filename, 'r') as f: for line in f: line = line.rstrip() if line.startswith( delineator ) and g: yield g g = [] if line: g.append(line) yield g"}
{"question": "Write a function that generate M distinct random patterns with N clusters and C units per cluster the maximum possible number of such patterns is C^N", "answer": "def generate_random_patterns(n_clusters, cluster_size, total_patterns, rng: np.random.RandomState = DEFAULT_RNG) \\ -> nd.NDArray: \"\"\"Patterns uniformly sampled from the space of possible patterns of this size\"\"\" # encode each cluster as a number. # pick n independent random numbers to select the active neuron in that # cluster patterns = rng.randint(0, cluster_size, size=(total_patterns, n_clusters)) # patterns = nd.random_randint(0, cluster_size, shape=(total_patterns, # n_clusters)) return nd.array(patterns)"}
{"question": "Write a function that Generate a PortRef for this port on the given SimObject with the given name", "answer": "def makeRef(self, simobj): return PortRef(simobj, self.name, self.role)"}
{"question": "Write a function that Generate a keypair using the point P of order n on the given curve. The private key is a positive integer d smaller than n, and the public key is Q = dP.", "answer": "def generate_keypair(curve, P, n): sysrand = SystemRandom() d = sysrand.randrange(1, n) Q = curve.mult(P, d) print(\"Priv key: d = \" + str(d)) print(\"Publ key: Q = \" + str(Q)) return (d, Q)"}
{"question": "Write a function that Generate a PortRef for this port on the given SimObject with the given name", "answer": "def makeRef(self, simobj): return PortRef(simobj, self.name, self.role)"}
{"question": "Write a function that generate a random alphanumeric code fix(clean): merge with other similar functions", "answer": "def generate_access_code(length): letter_choices = string.ascii_uppercase + string.digits letters = [random.SystemRandom().choice(letter_choices) for x in range(length)] return ''.join(letters)"}
{"question": "Write a function that Generate opponent choice and return winner (True - player / False - opponent)", "answer": "def get_winner(player_choice): opponent_choice = choices_list[random.randint(0,4)] if player_choice == \"rock\" and (opponent_choice == \"scissors\" or opponent_choice == \"lizard\"): return True, opponent_choice elif player_choice == \"paper\" and (opponent_choice == \"rock\" or opponent_choice == \"spock\"): return True, opponent_choice elif player_choice == \"scissors\" and (opponent_choice == \"paper\" or opponent_choice == \"lizard\"): return True, opponent_choice elif player_choice == \"lizard\" and (opponent_choice == \"spock\" or opponent_choice == \"paper\"): return True, opponent_choice elif player_choice == \"spock\" and (opponent_choice == \"scissors\" or opponent_choice == \"rock\"): return True, opponent_choice else: return False, opponent_choice"}
{"question": "Write a function that Generate Receipt Not able to be tested as it uses random function (other getter/setters already tested inside this function and have passed) Return payment settlement from take Payment Function in Checkout", "answer": "def test_take_payment(self): checkout_2.set_sale_amount(45.0) payment_taken = 50 actual = checkout_2.take_payment(payment_taken) expected_change = 5 self.assertEqual(expected_change, actual)"}
{"question": "Write a function that Generate the power using the interpolator and the z and k arrays Power = PK.P(z,k)", "answer": "def dimpower(Pk,z,k): delta = Pk.P(z,k) * k**3/(2*np.pi**2) return delta"}
{"question": "Write a function that Generate response file for all includes. ARM, GCC, IAR cross compatible", "answer": "def get_inc_file(self, includes): include_file = join(self.build_dir, \".includes_%s.txt\" % self.inc_md5) if not exists(include_file): with open(include_file, \"wb\") as f: cmd_list = [] for c in includes: if c: c = c.replace(\"\\\\\", \"/\") if self.CHROOT: c = c.replace(self.CHROOT, '') cmd_list.append('-I%s' % c) string = \" \".join(cmd_list) f.write(string) return include_file"}
{"question": "Write a function that Generate response file for all objects when linking. ARM, GCC, IAR cross compatible", "answer": "def get_link_file(self, cmd): link_file = join(self.build_dir, \".link_files.txt\") with open(link_file, \"wb\") as f: cmd_list = [] for c in cmd: if c: c = c.replace(\"\\\\\", \"/\") if self.CHROOT: c = c.replace(self.CHROOT, '') cmd_list.append(('\"%s\"' % c) if not c.startswith('-') else c) string = \" \".join(cmd_list) f.write(string) return link_file"}
{"question": "Write a function that Generate response file for all objects when archiving. ARM, GCC, IAR cross compatible", "answer": "def get_arch_file(self, objects): archive_file = join(self.build_dir, \".archive_files.txt\") with open(archive_file, \"wb\") as f: o_list = [] for o in objects: o_list.append('\"%s\"' % o) string = \" \".join(o_list).replace(\"\\\\\", \"/\") f.write(string) return archive_file"}
{"question": "Write a function that Generate the stack push operations for this program It pushes the necessary context to the stack like RA, T0,loop registers etc. The stack pointer(SP) is reduced by the amount the stack space allocated to this program.", "answer": "def gen_stack_enter_instr(self): allow_branch = 0 if (self.illegal_instr_pct > 0 or self.hint_instr_pct > 0) else 1 allow_branch &= not cfg.no_branch_jump try: with vsc.randomize_with(self.program_stack_len): self.program_stack_len in vsc.rangelist(vsc.rng(cfg.min_stack_len_per_program, cfg.max_stack_len_per_program)) # Keep stack len word aligned to avoid unaligned load/store self.program_stack_len % (rcs.XLEN // 8) == 0 except Exception: logging.critical(\"Cannot randomize program_stack_len\") sys.exit(1) self.instr_stack_enter.push_start_label = self.label_name + \"_stack_p\" self.instr_stack_enter.gen_push_stack_instr(self.program_stack_len, allow_branch = allow_branch) self.instr_stream.instr_list.extend((self.instr_stack_enter.instr_list))"}
{"question": "Write a function that generate matplotlib handles to create a legend of the features we put in our map.", "answer": "def generate_handles(labels, colors, edge='k', alpha=1): lc = len(colors) # get the length of the color list handles = [] for i in range(len(labels)): handles.append(mpatches.Rectangle((0, 0), 1, 1, facecolor=colors[i % lc], edgecolor=edge, alpha=alpha)) return handles"}
{"question": "Write a function that generate one-hot representation of words to form sentences word embeddings are in the first fully connected layer during training", "answer": "def next_batch(data, vocabulary_size): idx = np.random.randint(len(data)) batch_tokens = np.zeros((sentence_len, vocabulary_size)) batch_tokens[np.arange(sentence_len), data[idx]] = 1 return batch_tokens"}
{"question": "Write a function that Generate a variable the loader can use to indicate what API version it is. self the UtiliitySourceOutputGenerator object", "answer": "def outputUtilityVersionDefine(self): cur_loader_version = '\\n// Current API version of the utililties\\n#define XR_UTILITIES_API_VERSION ' cur_loader_version += self.api_version_define cur_loader_version += '\\n' return cur_loader_version"}
{"question": "Write a function that generate a random graph with degree between a and b", "answer": "def generate_graph(degree_start=10, degree_end=15, size=5000): z=[random.randint(degree_start, degree_end) for i in range(size)] # if sum of degree sequence is odd, make it even if sum(z) % 2 != 0: z[random.randint(0, size)] += 1 G=nx.configuration_model(z) # remove self-loops and parallel edges G=nx.Graph(G) G.remove_edges_from(G.selfloop_edges()) return G"}
{"question": "Write a function that generate and return 3d matrix as in the format matrix[h][w][d]", "answer": "def generateMatrix(level, box, width, depth, height): matrix = Matrix(level, box, height, width, depth) return matrix"}
{"question": "Write a function that generate and return a settlement in the form of a deck composed with a specific number of buildings", "answer": "def generateCityDeck(type, width, height): return CityDeck(type, width, height)"}
{"question": "Write a function that Generate the blinding factors and commitments for a given output. Can optionally get a \"custom\" VBF, normally used for the last input where the VBF is not random, but generated accordingly to all the others. `hash_prevouts` and `output_index` have the same meaning as in the `get_blinding_factor` call. NOTE: the `asset_id` should be passed as it is normally displayed, so reversed compared to the \"consensus\" representation.", "answer": "def get_commitments(self, asset_id, value, hash_prevouts, output_index, vbf=None): params = {'asset_id': asset_id, 'value': value, 'hash_prevouts': hash_prevouts, 'output_index': output_index} if vbf is not None: params['vbf'] = vbf return self._jadeRpc('get_commitments', params)"}
{"question": "Write a function that Generate output suitable for reading into another copy of program running in driven or benchmark mode First line is header \"STEP\" as identifier Second line of form \"N R\", where N is number of nodes, and R is number of rats Each successive line then lists the number of rats at each node Terminate with line \"END\"", "answer": "def driveOut(self, f = sys.stdout, display = True): f.write(\"STEP %d %d\\n\" % (len(self.nodes), self.ratCount())) if display: for nd in self.nodes: f.write(\"%d\\n\" % nd.ratCount) f.write(\"END\\n\")"}
{"question": "Write a function that generate a list of Agents (with kind and same_preference) that can be iterated over", "answer": "def _kind_picker(i): if i < round(num_agents * params['proportion_r']): return 'red' else: return 'blue'"}
{"question": "Write a function that Generates sample inputs for reduction ops that contain the input tensor and dim and keepdim kwargs. If a reduction op needs to test additional args/kwargs then create a separate sample_inputs function", "answer": "def fn(op_info, device, dtype, requires_grad, **kwargs): inputs = [] for t in _generate_nan_reduction_inputs(device, dtype, requires_grad): # Add case without dim and keepdim kwargs inputs.append(SampleInput(t.clone().requires_grad_(requires_grad))) for kwargs in _generate_reduction_kwargs(t.ndim, supports_multiple_dims): inputs.append(SampleInput(t.clone().requires_grad_(requires_grad), kwargs=kwargs)) return inputs"}
{"question": "Write a function that Generates a n-dim CSF datastructure of dim**4 to populate arrays", "answer": "def gen_n_comp_arrs(n=1, dim=4): crd_arrs = [] seg_arrs = [] return gen_n_comp_arrs_helper(1, crd_arrs, seg_arrs, n, n, dim)"}
{"question": "Write a function that Generates batches of size 1 (converts x to dense vectors)", "answer": "def gen(data_x, data_y, shuffle=True): while True: for x, y in zip(data_x, data_y): idx = [v[0] for v in x] val = [v[1] for v in x] z = np.zeros(N) z[idx] = val yield np.reshape(z, (1, -1)), np.reshape(y, (1, -1)) data.shuffle() # shuffle at epoch end"}
{"question": "Write a function that generates a random string with numAlph alphabets and numNum numbers", "answer": "def randomCode(numAlph,numNum): code =\"\" for i in range(numAlph): code += random.choice(string.ascii_uppercase) for i in range(numNum): code += random.choice(string.digits) finalCode = \"\" for i in random.sample(code,len(code)): finalCode += i return finalCode"}
{"question": "Write a function that Generates sample inputs for reduction ops that contain the input tensor and dim and keepdim kwargs. If a reduction op needs to test additional args/kwargs then create a separate sample_inputs function", "answer": "def fn(op_info, device, dtype, requires_grad): inputs = [] for t in _generate_reduction_inputs(device, dtype, requires_grad): # Add case without dim and keepdim kwargs inputs.append(SampleInput(t)) for kwargs in _generate_reduction_kwargs(t.ndim, supports_multiple_dims): inputs.append(SampleInput(t, kwargs=kwargs)) return inputs"}
{"question": "Write a function that Generates a new stream after a data transformation is applied", "answer": "def __expand(self): stream = DataStream(self.env) assert (self.dst_operator_id is not None) stream.src_operator_id = self.dst_operator_id stream.dst_operator_id = None return stream"}
{"question": "Write a function that Generates character.js that stores the JSON representation of characters and image paths", "answer": "def generateCharacterFile(inputPath, outputPath): outputFile = open(os.path.join(outputPath, \"characters.js\"), \"w\") outputFile.write(\"let characters = {\\n\") for filename in os.listdir(inputPath): inputFilePath = os.path.join(inputPath, filename) if os.path.isfile(inputFilePath): outputFile.write(createCharacterObject(filename)) outputFile.write(\"\\n};\\n\") outputFile.write(\"\\nconst getDetailsFor = name => characters[name];\\n\") outputFile.close()"}
{"question": "Write a function that Generates sample inputs for reduction ops that contain the input tensor and dim and keepdim kwargs. If a reduction op needs to test additional args/kwargs then create a separate sample_inputs function", "answer": "def fn(op_info, device, dtype, requires_grad): inputs = [] for t in _generate_reduction_inputs(device, dtype, requires_grad): # Add case without dim and keepdim kwargs inputs.append(SampleInput(t)) for kwargs in _generate_reduction_kwargs(t.ndim, supports_multiple_dims): inputs.append(SampleInput(t, kwargs=kwargs)) return inputs"}
{"question": "Write a function that Generates new inventory and distributes it somehow to keep the network balanced for the selected locations. Returns a numpy array of shape (num_dcs,num_commodities) representing how much extra inventory is going to appear.", "answer": "def generate_new_inventory( self, network: physical_network, open_orders: List[Order] ): # todo add type when it works. pass"}
{"question": "Write a function that Generates an API signature. A signature is HMAC_SHA256(secret, verb + path + nonce + data), hex encoded. Verb must be uppercased, url is relative, nonce must be an increasing 64-bit integer and the data, if present, must be JSON without whitespace between keys. For example, in psuedocode (and in real code below): verb=POST url=/api/v1/order nonce=1416993995705 data={\"symbol\":\"XBTZ14\",\"quantity\":1,\"price\":395.01} signature = HEX(HMAC_SHA256(secret, 'POST/api/v1/order1416993995705{\"symbol\":\"XBTZ14\",\"quantity\":1,\"price\":395.01}'))", "answer": "def generate_signature(secret, verb, url, nonce, data): '''Generate a request signature compatible with BitMEX.''' # Parse the url so we can remove the base and extract just the path. parsedURL = urlparse(url) path = parsedURL.path if parsedURL.query: path = path + '?' + parsedURL.query # print \"Computing HMAC: %s\" % verb + path + str(nonce) + data message = verb + path + str(nonce) + data signature = hmac.new(bytes(secret, 'utf8'), bytes(message, 'utf8'), digestmod=hashlib.sha256).hexdigest() return signature"}
{"question": "Write a function that Generates proof list for existence of a child node Appends proof list from children Merkle tree with (childrenTree.hash, self.content.hash()) This connects the proof list to the current node", "answer": "def __getChildProofList(self, childHash): if self.mode != \"compile\": raise ValueError(\"Illegal mode: %s\"%self.mode) if not self.children: raise ValueError(\"Cannot get child proof list on leaf node\") #Get proof list of the children Merkle tree childrenTree = MerkleTreeList(self.children) childrenProof = childrenTree.proofList(crypto.ishash(childHash)) # Get proof list for existence of children Merkle tree from current node curNodeProof = [(childrenTree.hash(), self.content.hash())] return childrenProof + curNodeProof"}
{"question": "Write a function that Write a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string \"\". Example: Input: strs = [\"flower\",\"flow\",\"flight\"] Output: \"fl\" Constraints: 0 <= strs.length <= 200 0 <= strs[i].length <= 200 strs[i] consists of only lower-case English letters.", "answer": "def shortest_word(string_array): length = len(string_array[0]) for element in string_array: if length > len(element): length = len(element) return length"}
{"question": "Write a function that write a character to lcd (or character rom) 0x09: backlight | RS=DR< works!", "answer": "def lcd_write_char(self, charvalue, mode=1): self.lcd_write_four_bits(mode | (charvalue & 0xF0)) self.lcd_write_four_bits(mode | ((charvalue << 4) & 0xF0))"}
{"question": "Write a function that Writes a comment, each line prefixed by // and wrapped to 80 spaces.", "answer": "def _OutputComment(f, comment): for line in comment.splitlines(): if len(line) == 0: f.write('//') else: f.write(COMMENT_WRAPPER.fill(line)) f.write('\\n')"}
{"question": "Write a function that Writes address/size output for the registers in the node's 'reg' property", "answer": "def reg_addr_name_alias(reg): return str2ident(reg.name) + \"_BASE_ADDRESS\" if reg.name else None"}
{"question": "Write a function that Writes IRQ num and data for the interrupts in the node's 'interrupt' property", "answer": "def irq_name_alias(irq, cell_name): if not irq.name: return None alias = \"IRQ_{}\".format(str2ident(irq.name)) if cell_name != \"irq\": alias += \"_\" + str2ident(cell_name) return alias"}
{"question": "Write a function that Writes a comment, each line prefixed by // and wrapped to 80 spaces.", "answer": "def _OutputComment(f, comment): for line in comment.splitlines(): if len(line) == 0: f.write('//') else: f.write(COMMENT_WRAPPER.fill(line)) f.write('\\n')"}
{"question": "Write a function that Generate an Impartial Culture profile that adheres to the format above given a candidate map.", "answer": "def gen_impartial_culture_strict(nvotes, candmap): rankmapcounts = [] rankmap = [] voteset = gen_urn(nvotes, 0, candmap.keys()) return voteset_to_rankmap(voteset, candmap)"}
{"question": "Write a function that Generate an Impartial Anonymous Culture profile that adheres to the format above.", "answer": "def gen_impartial_aynonmous_culture_strict(nvotes, candmap): rankmapcounts = [] rankmap = [] #Use the existing functions. voteset = gen_urn(nvotes, 1, candmap.keys()) return voteset_to_rankmap(voteset, candmap)"}
{"question": "Write a function that Generate an Urn Culture with Replacement = replace profile that adheres to the format above.", "answer": "def gen_urn_culture_strict(nvotes, replace, candmap): rankmapcounts = [] rankmap = [] #Use the existing functions. voteset = gen_urn(nvotes, replace, candmap.keys()) return voteset_to_rankmap(voteset, candmap)"}
{"question": "Write a function that Generate Mallows with a particular number of reference rankings and phi's drawn iid.", "answer": "def gen_mallows_mix(nvoters, candmap, nref): #Generate the requisite number of reference rankings and phis #Mix should be a random number over each... mix = [] phis = [] refs = [] for i in range(nref): refm, refc = gen_impartial_culture_strict(1, candmap); refs.append(io.rankmap_to_order(refm[0])) phis.append(round(random.random(), 5)) mix.append(random.randint(1,100)) smix = sum(mix) mix = [float(i) / float(smix) for i in mix] return gen_mallows(nvoters, candmap, mix, phis, refs)"}
{"question": "Write a function that TODO - implement. I expect rotation might be needed for this alignment if the x-y orientation of the camera is not perfectly oriented with the microscope stage", "answer": "def __init__(self, dataSet, parameters=None, analysisName=None): self.dataSet = dataSet"}
{"question": "Write a function that if you change this stub into a real check, please try to implement the username and groupname functions above, too.", "answer": "def isowner(st): return True"}
{"question": "Write a function that cheating a little at this point. Usually the PluginTab view is of type InteractiveGraphicsView But because the live view need some extra controls, we add this class (LiveWindow) to the Plugintabs view that's why we have to implement the same methods as the our view", "answer": "def run(self): self.view.run()"}
{"question": "Write a function that Following three cases - the client side widgets have everything they need from the encoded ID. Don't implement a default on the base class though because it is good to force both Client and PDF/HTML export to deal with each new directive explicitly.", "answer": "def handle_dataset_as_image(self, line, hda): pass"}
{"question": "Write a function that Implement the function interval_intersection below. You can define other functions if it helps you decompose and solve the problem. Do not import any module that you do not use! Remember that if this were an exam problem, in order to be marked this file must meet certain requirements: - it must contain ONLY syntactically valid python code (any syntax or indentation error that stops the file from running would result in a mark of zero); - you MAY NOT use global variables; the function must use only the input provided to it in its arguments.", "answer": "def interval_intersection(lA, uA, lB, uB): if (lB >= lA and lB <= uA): if uB < uA: return uB - lB else: return uA - lB elif (lA >= lB and lA <= uB): if uA < uB: return uA - lA else: return uB - lA return 0"}
{"question": "Write a function that Mixin this class to implement IPipelineSnapshot Graphene has some strange properties that make it so that you cannot implement ABCs nor use properties in an overridable way. So the way the mixin works is that the target classes have to have a method get_represented_pipeline()", "answer": "def get_represented_pipeline(self): raise NotImplementedError()"}
{"question": "Write a function that Implement Polled Camera Node for S100 http://wiki.ros.org/camera_drivers Service request_image (polled_camera/GetPolledImage) Published Topics: /s100/image_filename (sensor_msgs/Image)", "answer": "def working_dir(): return '/tmp'"}
{"question": "Write a function that To get nice documentation about ServerViewSet actions it is necessary to implement the method. By default, ViewSet doesn't provide it.", "answer": "def get_serializer(self, *args, **kwargs): pass"}
{"question": "Write a function that <HINT> Create a submit view to create an exam submission record for a course enrollment, you may implement it based on following logic: Get user and course object, then get the associated enrollment object created when the user enrolled the course Create a submission object referring to the enrollment Collect the selected choices from exam form Add each selected choice object to the submission object Redirect to show_exam_result with the submission id", "answer": "def submit(request, course_id): user = request.user course = Course.objects.get(pk=course_id) enrollment = Enrollment.objects.get(user=user, course=course) submitted_anwsers = extract_answers(request) submission = Submission.objects.create(enrollment=enrollment) submission.chocies.set(submitted_anwsers) print(submission) return HttpResponseRedirect(reverse(viewname='onlinecourse:result', args=(course_id, submission.chocies.first().question.lesson.pk, submission.pk)))"}
