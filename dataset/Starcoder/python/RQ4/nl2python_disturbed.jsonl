{"question": "Write a function that write a method to take perSiteResults dictionary in and add a column Ca5C", "answer": "def useLDAmodel(self, kinetics, pos, model, up, down): \"\"\" Test out LDA model \"\"\" res = np.zeros((up + down + 1, 5)) ind = 0 # range from -down to +up for offset in range(-down, (up + 1)): a = pos + offset # res[ind,] = [kinetics[a][\"tMean\"], kinetics[a][\"modelPrediction\"], kinetics[a][\"tErr\"], kinetics[a][\"coverage\"]] res[ind, ] = [kinetics[a][\"tMean\"], kinetics[a][\"modelPrediction\"], kinetics[a][\"tErr\"], kinetics[a][\"coverage\"], np.exp(kinetics[a][\"tStatistic\"]) - 0.01] ind += 1 apply = np.hstack(np.log(res + 0.01).transpose()) tmp = sum(np.multiply(apply, model[1:])) + model[0] return tmp"}
{"question": "Write a function that record text to each open file descriptor in the collection", "answer": "def recordtxt(msg, fdgroup): for itm in fdgroup: itm.write(msg) itm.flush() if itm.fileno() != 1: os.fsync(itm.fileno())"}
{"question": "Write a function that Write a function called next_series. next_series should take have two parameters: a list of integers and a single integer. For this description, we'll call the single integer count. next_series should modify the list to add the next count pseudo- Fibonacci numbers to the end of the sequence. A pseudo- Fibonacci number is the sum of the previous two numbers in the sequence, but in our case, the previous two numbers may not be the original numbers from the Fibonacci sequence. For example, if the original list given was: num_list = [5, 5, 10, 15, 25, 40, 65] Then next_series(num_list, 3) would return: [5, 5, 10, 15, 25, 40, 65, 105, 170, 275] All the original numbers in the list are still there, and three new ones have been added. You may assume the list parameter will always have at least two numbers. HINT: Python gets mad if you try to change a list while iterating over it with a for-each loop. You'll have to get clever with a for or while loop to do this! Add your code here!", "answer": "def next_series( num_list , qty ): while qty > 0: tail = num_list.pop() prev_tail = num_list.pop() fresh = tail + prev_tail num_list.append(prev_tail) num_list.append(tail) num_list.append(fresh) qty -= 1 return num_list"}
{"question": "Write a function that Write a python script to find the recurrent elements of a tuple", "answer": "def locate_repeats(seq): repeat_elements = [] for idx in range(len(seq)): if seq.count(seq[idx]) > 1: repeat_elements.append(seq[idx]) return list(set(repeat_elements))"}
{"question": "Write a routine that Write a Python script to compute centers of a segment", "answer": "def center(xa,ya,xb,yb): xmid = (xa+xb)/2 ymid = (ya+yb)/2 return xmid,ymid"}
{"question": "Write a function that Write a function that merges two arrays by alternatingly retrieving elements. For example: given the two arrays [a, b, c] and [1, 2, 3], the function should return [a, 1, b, 2, c, 3].", "answer": "def alternatively_merge(array1, array2): merged = [] larger_array_len = len(array1) > len(array2) and len(array1) or len(array2) for idx in range(0, larger_array_len): if len(array1) > idx: merged.append(array1[idx]) if len(array2) > idx: merged.append(array2[idx]) return merged"}
{"question": "Write a function that Write a program (function!) that takes a collection and returns a new collection that contains all the elements of the first collection minus all the duplicates. Extras: #Write two different functions to do this - one using a loop and constructing a sequence, and another using sets. #Go back and do Exercise 5 using sets, and write the solution for that in a distinct function.", "answer": "def distinct_collection(collection): elements = [] for item in collection: if item not in elements: elements.append(item) return elements"}
{"question": "Write a function that Write timer handler. Emulate hardware: if there's content in the cache write some or all of it", "answer": "def perform_output(self, t): if self.wchar: self.wcache[self.wposition] = self.wchar self.wposition += 1 if self.wchar == ord('\\n'): self.wprint_count = self.wposition # Save for schedule micropython.schedule(printbuf, self) self.wposition = 0 self.wchar = b''"}
{"question": "Write a routine that Write a program to verify whether a value is an even divisor of 3 for more info on this quiz, go to this url: http://www.programmr.com/even-multiple-3", "answer": "def even_divisor_of_3(value): if value % 3 == 0 and value % 2 == 0: return True else: return False"}
{"question": "Write a function that Write a function that when given a URL as a string, parses out just the domain title and returns it as a string. For example: domain_label(\"http://github.com/carbonfive/raygun\") == \"github\" domain_label(\"http://www.zombie-bites.com\") == \"zombie-bites\" domain_label(\"https://www.cnet.com\") == \"cnet\"", "answer": "def domain_label(link): \"\"\" link: link of a website to split from \"/\" and \".\" return: domain title from the link \"\"\" domain_array = ([part.split(\".\") for part in link.split(\"/\")]) for part in domain_array: title = ([part[j] for j in range(len(part)) if part[j] != \"www\" and part[j] != \"http:\" and part[j] != \"https:\" and part[j] != \"\"]) if title != []: return title[0]"}
{"question": "Write a function that Record data from the gadget in a file for future analysis", "answer": "def recordInfo(gadget,info): with open('visuapp/static/data/'+gadget+'.json', 'w') as outFile: json.dump(info, outFile) outFile.close()"}
{"question": "Write a function that Write a function that verifies whether an item occurs in a list.", "answer": "def verify_item(group_1, x): if x in group_1: print(x, \"element occurs in a list\") else: print(x,\"element not occurs in a list\")"}
{"question": "Write a function that write exam cases with arguments 85 and 63 for recursive_number_binary function", "answer": "def exam_rnb_w_base(self): self.assertEqual('00000000',recursive_number_binary(0,7))"}
{"question": "Write a function that Write a function that takes a list of terms as an input argument and returns True if the group is ordered and returns False otherwise.", "answer": "def arranged(stream): arrayA = [] arrayB = [] for item in stream: arrayA += (item[0]) arrayB += (item[0]) arrayB.sort() return arrayA == arrayB"}
{"question": "Write a routine that Write a program to capture at least 3 errors while handling the dictionary data structure.", "answer": "def compute(num_val): print(\"The square is\", num_val**2)"}
{"question": "Write a function that Write a single register cmd = 0x32 value = 0x80 bus.write_byte_data(self.MCUDeviceAddress, cmd, value) Write an array of registers values = [0xff, 0xff, 0xff, 0xff, 0xff, 0xff] bus.write_i2c_block_data(self.MCUDeviceAddress, cmd, values)", "answer": "def transmitToMCU(self, cmdKey, valData): self.i2cChannel.write_byte_data(self.MCUDeviceAddress, cmdKey, valData) return"}
{"question": "Compose a function that Record text to file, or store it in a buffer, or disregard it", "answer": "def record(self, *items): try: content = ''.join(items) except: print(items) raise TypeError if self.storetext is not None: self.storetext = self.storetext + content elif self.nodefile: self.nodefile.record(content) elif self.vertex: self.vertex.record(content)"}
{"question": "Write a function that Write a byte to our outputfd, which will unblock the call to select() inside execute() This allows us to send data out (if len(bundles) > 0) or exit this thread", "answer": "def refresh(self) : os.write(self.outputfd, bytes([0]))"}
{"question": "Write a function that create a recursive routine that will display n numbers in first descending and then in ascending order", "answer": "def show_descend_ascend(n): if n==0: return else: print(n) show_descend_ascend(n-1) print(n)"}
{"question": "Write a function that Write a function here that creates a turtle and draws a shape with it.", "answer": "def triangle_boogie(color, start): t = turtle.Turtle() t.speed(0) t.right(start) for shape in range(6): if shape % 2 == 0: t.color(\"purple\") t.width(shape) else: t.color(color) t.width(shape) for side in range(3): t.forward(100) t.right(120) t.right(15) t.hideturtle()"}
{"question": "Write a function that Write out a prototype for a C-style command to populate a Dispatch table itself the ApiDumpResultsProducer entity", "answer": "def emitDispatchPrototypes(self): table_assistant = '\\n' table_assistant += '// Prototype for dispatch table helper function\\n' table_assistant += 'void GeneratedXrPopulateDispatchTable(struct XrGeneratedDispatchTable *tbl,\n' table_assistant += ' XrInstance inst,\n' table_assistant += ' PFN_xrGetInstanceProcAddr acquire_inst_proc_addr);\\n' return table_assistant"}
{"question": "Compose a routine that inscribes a symbol to lcd (or glyph rom) 0x09: backlight | RS=DR< works!", "answer": "def inscribe_symbol(self, glyphvalue, modality=1): self.write_four_bits(modality | (glyphvalue & 0xF0)) self.write_four_bits(modality | ((glyphvalue << 4) & 0xF0))"}
{"question": "Compose a routine that Create array routines that execute the following operations for a sequence of integers. For each routine, supply a trial program. h. Return true if the sequence is presently ordered in ascending fashion. ROUTINES", "answer": "def is_ordered(sequence): arrangedFlag = False for idx in range(0, len(sequence) - 1): if sequence[idx] < sequence[idx + 1]: arrangedFlag = True else: return False return arrangedFlag"}
{"question": "Write a function that Generate SQL to materialize a query boundary in EPSG:3857. Densify the sides a little so the boundary can be safely converted to other coordinate systems.", "answer": "def boundsToLimitsSQL(self, bounds): DENSIFY_RATIO = 4 bounds['segSize'] = (bounds['xmax'] - bounds['xmin'])/DENSIFY_RATIO sql_tmpl = 'ST_Segmentize(ST_MakeEnvelope({xmin}, {ymin}, {xmax}, {ymax}, 3857),{segSize})' return sql_tmpl.format(**bounds)"}
{"question": "Write a function that create the allocation of STY from mappings (as a list of 4-element lists, elem1, elem2, cui, sty, see above)", "answer": "def create_alloc_STY(mappings): dict_map_STY_count = defaultdict(int) for entry in mappings: dict_map_STY_count[entry[3]] += 1 #rank cntr_dict_map_STY_count = Counter(dict_map_STY_count) list_STY_count_ratio = [] for STY,freq in cntr_dict_map_STY_count.most_common(): ratio = float(freq)/len(mappings) list_STY_count_ratio.append(STY.replace(',','_') + ',' + str(freq) + ',' + '%.2f%%' % (ratio*100)) return list_STY_count_ratio"}
{"question": "Write a function that Create the various visualizations and merge the matte and glossy visualizations.", "answer": "def __createVisuals(self, renderer): mattes = helpers.tf_createMatteVisualization(self.batchSize, self.nbMatteVisualization, self.targets, self.outputs, renderer) glossies = helpers.tf_createGlossyVisualization(self.batchSize, self.nbGlossyVisualization, self.surfaceArray, self.targets, self.outputs, renderer) targetsVisualized = tf.concat([mattes[0],glossies[0]], axis = 1) outputsVisualized = tf.concat([mattes[1],glossies[1]], axis = 1) return targetsVisualized, outputsVisualized"}
{"question": "Write a function that Produce an invalid (maybe) example adapted to the given mentor.", "answer": "def exampleCreation_invalid(mentor, upperLimit, size): assert size > 0 sample_head = None while sample_head is None: sample_head = exampleCreation_valid(mentor, upperLimit, size) task = random.choice(mentor.inputs) moment = random.randint(0, upperLimit * 3 + 1) if moment % 2 == 0: moment = moment // 2 else: moment = moment // 2 + 0.1 idx = random.randint(0, len(sample_head) - 1) sample_head[idx] = TimedWord(task, moment) return sample_head"}
{"question": "Write a function that Generate the different renderings and concatenate the diffuse an specular renderings.", "answer": "def __generateRenderings(self, renderer): diffuses = helpers.tf_generateDiffuseRendering(self.batchSize, self.nbDiffuseRendering, self.targets, self.outputs, renderer) speculars = helpers.tf_generateSpecularRendering(self.batchSize, self.nbSpecularRendering, self.surfaceArray, self.targets, self.outputs, renderer) targetsRendered = tf.concat([diffuses[0],speculars[0]], axis = 1) outputsRendered = tf.concat([diffuses[1],speculars[1]], axis = 1) return targetsRendered, outputsRendered"}
{"question": "Write a function that Produce the struct element verify code from the recorded data", "answer": "def processStructElementInfo(self): indentVal = self.incIndent(None) for element in self.structElements: # # The string returned by genFuncBody will be nested in an if check for a NULL pointer, so needs its indent incremented codeLines, ignoredVal = self.genFuncBody('{funcName}', element.elements, '{valuePrefix}', '{displayNamePrefix}', element.name) if codeLines: self.checkedStructs[element.name] = codeLines"}
{"question": "Write a function that generate python, numpy and mxnet datasets with the given seed", "answer": "def gen_data(seed=None): with random_seed(seed): python_data = [rnd.random() for _ in range(size)] np_data = np.random.rand(size) mx_data = mx.random.uniform(shape=shape, ctx=ctx).asnumpy() return (seed, python_data, np_data, mx_data)"}
{"question": "Write a function that Generate AssemblyInfo.cs files with the right version numbers by using ``AssemblyInfo.cs.in`` files as a template", "answer": "def mk_all_assembly_infos(major, minor, build, revision): for c in get_components(): if c.has_assembly_info(): c.make_assembly_info(major, minor, build, revision)"}
{"question": "Write a function that Generate a .def based on the files at cfg.export_files slot.", "answer": "def mk_def_file(cfg): definition_name = '%s.def' % os.path.join(cfg.src_folder, cfg.title) dll_title = cfg.dll_title export_header_items = [] for header_dot in cfg.export_files: header_item = cfg.find_file(header_dot, cfg.title) api_path = os.path.join(header_item.src_folder, header_dot) export_header_items.append(api_path) mk_genfile_common.mk_def_file_internal(definition_name, dll_title, export_header_items) if VERBOSE: print(\"Generated '%s'\" % definition_name)"}
{"question": "Write a function that Generate the requested zone immediately, so the following render_block's work self.terraingen.generate_zone(zone)", "answer": "def conceal_zone(self, zone): #TODO: remove from memory; save #for position in self.areas.get(zone, ()): # if position in self.displayed: # self.conceal_block(position) pass"}
{"question": "Write a routine that produce bearer token to verify with PAS portal, Input : Client Key, Client Credential", "answer": "def process_auth(**params): post_payload = {\"grant_type\": \"client_credentials\", \"scope\": params['oauth_scope']} reply = requests.post(params['endpoint'], data=post_payload, auth=(params['client_key'], params['client_credential']), verify=True, timeout=(5, 30)) raise_for_status(reply) try: return reply.json()['access_token'] except KeyError: raise RuntimeError('OAuth request to tenant was unsuccessful')"}
{"question": "Write a function that produce measures for each slot based on its number of cycles", "answer": "def credit_slot_measures(slot_cycles, cycle): slot_measures = [] for x in range(len(slot_cycles)): slot_measures.append(credit_slot_measure(slot_cycles, x, cycle)) return slot_measures"}
{"question": "Write a function that generate client ID with pub prefix randomly client_id = f'rpi-dht-mqtt-{random.randint(0, 1000)}' username = 'emqx' password = 'public'", "answer": "def connect_mqtt(broker, port, client_id): def on_connect(client, userdata, flags, rc): if rc == 0: print(\"Connected to MQTT Broker!\") else: print(\"Failed to connect, return code %d\\n\", rc) client = mqtt.Client(client_id) # client.username_pw_set(username, password) client.on_connect = on_connect client.connect(broker, port) return client"}
{"question": "Write a method that Produce text samples with misleading features make the labels to be correlated with hue, not the numeral itself or the other way", "answer": "def draw_uniform(): trait = np.zeros((6)) trait[0] = np.random.randint(2) #character trait[1] = np.random.uniform() #x trait[2] = np.random.uniform() #y trait[3] = 0 trait[4] = np.random.uniform() # tint trait[5] = 0 return trait"}
{"question": "Write a function that Create a new bottom row of random values for the blaze", "answer": "def create_row(init=MIN_BRIGHTNESS, finish=MAX_BRIGHTNESS): \"init and finish define range of dimmest to brightest 'blaze'\" return [init + random.randrange(finish-init) for idx in range(DISPLAY_WIDTH)]"}
{"question": "Write a function that Produce list of subunits path in repository, excluding the path in SKIP_SUBMODULES_LIST.", "answer": "def fetch_all_subunits(): info_map = {} repo_item = Repo(REPO_PATH) for subunit in repo_item.submodules: path = subunit.abspath.replace(REPO_PATH+'/', '') if path not in SKIP_SUBMODULES_LIST: #print(path,':',subunit.module().head.commit) info_map[path] = subunit.module().head.commit return info_map"}
{"question": "Write a function that generate a sequence of frames of a dot moving across an image", "answer": "def build_frames(timesteps,width,height, ch=1): frames = list() # create the first frame frame = np.zeros((width,height)) step = random.randint(0, timesteps-1) # decide if we are heading left or right right = 1 if random.random() < 0.5 else 0 col = 0 if right else timesteps-1 frame[step, col] = 1 frames.append(frame) # create all remaining frames for i in range(1, timesteps): col = i if right else timesteps-1-i frame, step = next_frame(step, frame, col) frames.append(frame) return frames, right"}
{"question": "Write a function that generate multiple sequences of frames and reshape for network input", "answer": "def generate_examples(n_patterns,timesteps,width,height,channels): X, y = list(), list() for _ in range(n_patterns): frames, right = build_frames(timesteps,width,height, ch=channels) X.append(frames) y.append(right) import pdb;pdb.set_trace() # resize as [samples, timesteps, width, height, channels] X = np.array(X).reshape(n_patterns, timesteps,width,height, channels) y = np.array(y).reshape(n_patterns, 1) return X, y"}
{"question": "Write a function that Produce a copy of the credential except that the has_variance is True.", "answer": "def create_variance_credential(self) -> 'MetricKey': return self._replace(has_variance=True)"}
{"question": "Write a function that Produce a copy of the token with a different schema name and is_diff False.", "answer": "def build_standard_key(self, schema_name: Text) -> 'MetricKey': return self._replace(schema_name=schema_name, is_diff=False)"}
{"question": "Write a function that generate ground truth measurement vector gt_vec, noisy measurement vector meas_vec", "answer": "def create_measurement(pos_true): # x position [m], y position [m] gt_vec = hx @ pos_true meas_vec = gt_vec + meas_noise @ np.random.randn(4, 1) return meas_vec.astype(float)"}
{"question": "Write a function that Produce the collection of <input> subexpression as specified by grammar for ArithmeticGenericOp", "answer": "def _produce_input_spec(groups_idx, nums, floats): input_spec = \"\" for i, (group, idx) in enumerate(groups_idx): if group == \"edge\": input_spec += \"&{}\".format(idx) elif group == \"integer\": input_spec += \"${}:{}\".format(idx, _to_type_spec(nums[idx])) elif group == \"real\": input_spec += \"${}:{}\".format(idx, _to_type_spec(floats[idx])) if i < len(groups_idx) - 1: input_spec += \" \" return input_spec"}
{"question": "Write a function that produce python, numpy and mxnet datasets with the provided seed", "answer": "def create_dataset(seed=None): with random_seed(seed): python_dataset = [rnd.random() for _ in range(size)] np_dataset = np.random.rand(size) mx_dataset = mx.nd.random_uniform(shape=shape, ctx=ctx).asnumpy() return (seed, python_dataset, np_dataset, mx_dataset)"}
{"question": "Write a routine that Produce a line graph that displays the measurements in the months", "answer": "def line_graph(dataframe,timeframe,attribute): \"\"\" A line graph that displays the measurements in the months This function accepts the dataframe dataframe ,timeframe(day/month/year) and attribute(feature), which plots the aggregated value of the feature based on the periods. Ensure the period labels are properly named. Keyword arguments: dataframe - Pandas dataframe which has the data. timeframe - Period of time over which you want to aggregate the data attribute - Feature of the dataframe \"\"\" plt.plot(timeframe,dataframe[attribute], color = 'blue') plt.ylabel(attribute) plt.xticks(rotation = 90) plt.show()"}
{"question": "Write a procedure that create single variants for those places that experimental evidence and alignment are available", "answer": "def alter_single(seq,variant_info,shift=0,position=0): variants=[] prior=int(variant_info[0][1])-shift for vi in variant_info: if prior!=int(vi[1])-shift: position+=1 prior=int(vi[1])-shift variant=[vi[2] if idx==position else seq[idx] for idx in range (len(seq))] variants.append(variant) return variants"}
{"question": "Write a function that generate poems from a file out: list of poem lines", "answer": "def generate_poems(filename): g = [] # get to the first poem in the file with open(filename, 'r') as f: for line in f: line = line.rstrip() if line.startswith( delineator ) and g: yield g g = [] if line: g.append(line) yield g"}
{"question": "Write a function that produce M distinct random templates with N groups and C units per group the maximum possible number of such templates is C^N", "answer": "def produce_random_templates(n_groups, group_size, total_templates, rng: np.random.RandomState = DEFAULT_RNG) -> nd.NDArray: \"\"\"Templates uniformly sampled from the space of possible templates of this size\"\"\" # encode each group as a number. # pick n independent random numbers to select the active neuron in that # group templates = rng.randint(0, group_size, size=(total_templates, n_groups)) # templates = nd.random_randint(0, group_size, shape=(total_templates, # n_groups)) return nd.array(templates)"}
{"question": "Write a procedure that Create a PortLink for this connector on the specified SimEntity with the specified label", "answer": "def buildLink(self, simentity): return PortLink(simentity, self.label, self.position)"}
{"question": "Write a routine that Produce a keypair using the point Pt of order num on the given curveObj. The secret key is a positive integer priv smaller than num, and the public key is pub = privPt.", "answer": "def produce_keypair(curveObj, Pt, num): rndsrc = SystemRandom() priv = rndsrc.randrange(1, num) pub = curveObj.mult(Pt, priv) print(\"Priv key: priv = \" + str(priv)) print(\"Publ key: pub = \" + str(pub)) return (priv, pub)"}
{"question": "Write a function that Create a PortReference for this connector on the given SimulationItem with the specified label", "answer": "def buildReference(self, simEntity): return PortReference(simEntity, self.label, self.position)"}
{"question": "Write a function that produce a random alphanumeric key fix(clean): merge with other related functions", "answer": "def produce_entry_key(size): symbol_choices = string.ascii_uppercase + string.digits symbols = [random.SystemRandom().choice(symbol_choices) for n in range(size)] return ''.join(symbols)"}
{"question": "Write a function that Generate opponent choice and return winner (True - player / False - opponent)", "answer": "def get_winner(player_choice): opponent_choice = choices_list[random.randint(0,4)] if player_choice == \"rock\" and (opponent_choice == \"scissors\" or opponent_choice == \"lizard\"): return True, opponent_choice elif player_choice == \"paper\" and (opponent_choice == \"rock\" or opponent_choice == \"spock\"): return True, opponent_choice elif player_choice == \"scissors\" and (opponent_choice == \"paper\" or opponent_choice == \"lizard\"): return True, opponent_choice elif player_choice == \"lizard\" and (opponent_choice == \"spock\" or opponent_choice == \"paper\"): return True, opponent_choice elif player_choice == \"spock\" and (opponent_choice == \"scissors\" or opponent_choice == \"rock\"): return True, opponent_choice else: return False, opponent_choice"}
{"question": "Write a function that Produce Invoice Not able to be tested as it uses random method (other getter/setters already tested within this method and have passed) Return payment reconciliation from obtain Payment Method in Checkout", "answer": "def verify_acquire_payment(self): checkout_2.set_sale_total(45.0) funds_collected = 50 computed = checkout_2.acquire_payment(funds_collected) anticipated_change = 5 self.assertEqual(anticipated_change, computed)"}
{"question": "Write a function that Generate the power using the interpolator and the z and k arrays Power = PK.P(z,k)", "answer": "def dimpower(Pk,z,k): delta = Pk.P(z,k) * k**3/(2*np.pi**2) return delta"}
{"question": "Write a function that Generate response file for all includes. ARM, GCC, IAR cross compatible", "answer": "def get_inc_file(self, includes): include_file = join(self.build_dir, \".includes_%s.txt\" % self.inc_md5) if not exists(include_file): with open(include_file, \"wb\") as f: cmd_list = [] for c in includes: if c: c = c.replace(\"\\\\\", \"/\") if self.CHROOT: c = c.replace(self.CHROOT, '') cmd_list.append('-I%s' % c) string = \" \".join(cmd_list) f.write(string) return include_file"}
{"question": "Write a function that Produce reply file for all entities when linking. ARM, GCC, IAR cross compatible", "answer": "def fetch_link_doc(self, args): link_doc = join(self.build_dir, \".link_files.txt\") with open(link_doc, \"wb\") as file: args_list = [] for arg in args: if arg: arg = arg.replace(\"\\\\\", \"/\") if self.ROOTPATH: arg = arg.replace(self.ROOTPATH, '') args_list.append(('\"%s\"' % arg) if not arg.startswith('-') else arg) text = \" \".join(args_list) file.write(text) return link_doc"}
{"question": "Write a function that Generate response file for all objects when archiving. ARM, GCC, IAR cross compatible", "answer": "def get_arch_file(self, objects): archive_file = join(self.build_dir, \".archive_files.txt\") with open(archive_file, \"wb\") as f: o_list = [] for o in objects: o_list.append('\"%s\"' % o) string = \" \".join(o_list).replace(\"\\\\\", \"/\") f.write(string) return archive_file"}
{"question": "Write a function that Generate the stack push operations for this routine It pushes the required context to the stack like RA, T0,cycle registers etc. The stack pointer(SP) is reduced by the amount the stack memory allocated to this routine.", "answer": "def gen_stack_enter_steps(self): permit_branch = 0 if (self.invalid_instr_pct > 0 or self.hint_instr_pct > 0) else 1 permit_branch &= not cfg.no_branch_jump try: with vsc.randomize_with(self.task_stack_len): self.task_stack_len in vsc.rangelist(vsc.rng(cfg.min_stack_len_per_program, cfg.max_stack_len_per_program)) # Keep stack len word aligned to avoid unaligned load/store self.task_stack_len % (rcs.XLEN // 8) == 0 except Exception: logging.critical(\"Cannot randomize task_stack_len\") sys.exit(1) self.step_stack_enter.push_start_label = self.label_title + \"_stack_p\" self.step_stack_enter.gen_push_stack_instr(self.task_stack_len, allow_branch = permit_branch) self.instr_stream.instr_list.extend((self.step_stack_enter.instr_list))"}
{"question": "Write a function that produce matplotlib markers to create a legend of the attributes we put in our map.", "answer": "def produce_markers(tags, hues, border='k', alpha=1): lc = len(hues) # get the length of the color list markers = [] for idx in range(len(tags)): markers.append(mpatches.Rectangle((0, 0), 1, 1, facecolor=hues[idx % lc], edgecolor=border, alpha=alpha)) return markers"}
{"question": "Compose a function that creates one-hot encoding of terms to build phrases term embeddings are in the first fully connected layer during training", "answer": "def upcoming_batch(dataset, lexicon_size): index = np.random.randint(len(dataset)) token_matrix = np.zeros((sentence_len, lexicon_size)) token_matrix[np.arange(sentence_len), dataset[index]] = 1 return token_matrix"}
{"question": "Write a function that Produce a variable the loader can use to indicate what API revision it is. self the UtiliitySourceOutputCreator object", "answer": "def outputUtilityVersionDeclare(self): cur_loader_revision = '\n// Current API revision of the utililties\n#define XR_UTILITIES_API_VERSION ' cur_loader_revision += self.api_revision_define cur_loader_revision += '\n' return cur_loader_revision"}
{"question": "Write a function that create a random network with degree between a and b", "answer": "def create_network(degree_lower=10, degree_upper=15, capacity=5000): z=[random.randint(degree_lower, degree_upper) for i in range(capacity)] # if sum of degree sequence is odd, make it even if sum(z) % 2 != 0: z[random.randint(0, capacity)] += 1 G=nx.configuration_model(z) # remove self-loops and parallel edges G=nx.Graph(G) G.remove_edges_from(G.selfloop_edges()) return G"}
{"question": "Write a routine that create and return 3d array as in the format array[h][w][d]", "answer": "def createArray(stage, cube, breadth, depth, altitude): array = Matrix(stage, cube, altitude, breadth, depth) return array"}
{"question": "Write a function that generate and return a settlement in the form of a deck composed with a specific number of buildings", "answer": "def generateCityDeck(type, width, height): return CityDeck(type, width, height)"}
{"question": "Write a function that Generate the obscuring factors and pledges for a given output. Can optionally get a \"custom\" VBF, normally used for the last input where the VBF is not random, but generated accordingly to all the others. `hash_priorouts` and `output_slot` have the same meaning as in the `get_obscuring_factor` call. NOTE: the `token_id` should be passed as it is normally displayed, so reversed compared to the \"consensus\" representation.", "answer": "def get_pledges(self, token_id, amount, hash_priorouts, output_slot, vbf=None): params = {'token_id': token_id, 'amount': amount, 'hash_priorouts': hash_priorouts, 'output_slot': output_slot} if vbf is not None: params['vbf'] = vbf return self._jadeRpc('get_pledges', params)"}
{"question": "Write a function that Produce output suitable for reading into another replica of program running in guided or benchmark mode First line is header \"STEP\" as identifier Second line of form \"N R\", where N is number of vertices, and R is number of rodents Each successive line then lists the number of rodents at each vertex Terminate with line \"END\"", "answer": "def guideOut(self, f = sys.stdout, show = True): f.write(\"STEP %d %d\\n\" % (len(self.vertices), self.rodentCount())) if show: for vt in self.vertices: f.write(\"%d\\n\" % vt.rodentCount) f.write(\"END\\n\")"}
{"question": "Write a routine that generate a list of Operators (with type and same_choice) that can be iterated over", "answer": "def _type_selector(idx): if idx < round(agent_count * params['proportion_r']): return 'red' else: return 'blue'"}
{"question": "Write a function that Generates sample inputs for reduction ops that contain the input tensor and dim and keepdim kwargs. If a reduction op needs to test additional args/kwargs then create a separate sample_inputs function", "answer": "def fn(op_info, device, dtype, requires_grad, **kwargs): inputs = [] for t in _generate_nan_reduction_inputs(device, dtype, requires_grad): # Add case without dim and keepdim kwargs inputs.append(SampleInput(t.clone().requires_grad_(requires_grad))) for kwargs in _generate_reduction_kwargs(t.ndim, supports_multiple_dims): inputs.append(SampleInput(t.clone().requires_grad_(requires_grad), kwargs=kwargs)) return inputs"}
{"question": "Write a function that Builds a n-dim CSF framework of dim**4 to fill arrays", "answer": "def build_n_comp_lists(n=1, dim=4): crd_lists = [] seg_lists = [] return build_n_comp_lists_helper(1, crd_lists, seg_lists, n, n, dim)"}
{"question": "Write a routine that Produces batches of size 1 (transforms x to dense vectors)", "answer": "def produce(seq_x, seq_y, shuffle=True): while True: for feat, label in zip(seq_x, seq_y): key_idx = [pair[0] for pair in feat] key_val = [pair[1] for pair in feat] z = np.zeros(N) z[key_idx] = key_val yield np.reshape(z, (1, -1)), np.reshape(label, (1, -1)) seq.shuffle() # shuffle at epoch end"}
{"question": "Write a function that generates a random string with numLetters alphabets and numDigits numbers", "answer": "def randomToken(numLetters,numDigits): codeStr =\"\" for i in range(numLetters): codeStr += random.choice(string.ascii_uppercase) for i in range(numDigits): codeStr += random.choice(string.digits) finalToken = \"\" for i in random.sample(codeStr,len(codeStr)): finalToken += i return finalToken"}
{"question": "Write a function that Generates sample inputs for reduction ops that contain the input tensor and dim and keepdim kwargs. If a reduction op needs to test additional args/kwargs then create a separate sample_inputs function", "answer": "def fn(op_info, device, dtype, requires_grad): inputs = [] for t in _generate_reduction_inputs(device, dtype, requires_grad): # Add case without dim and keepdim kwargs inputs.append(SampleInput(t)) for kwargs in _generate_reduction_kwargs(t.ndim, supports_multiple_dims): inputs.append(SampleInput(t, kwargs=kwargs)) return inputs"}
{"question": "Write a routine that Produces a fresh stream after a data conversion is applied", "answer": "def __enlarge(self): flow = DataFlow(self.env) assert (self.dest_operator_id is not None) flow.source_operator_id = self.dest_operator_id flow.dest_operator_id = None return flow"}
{"question": "Write a function that Generates character.js that stores the JSON representation of characters and image paths", "answer": "def generateCharacterFile(inputPath, outputPath): outputFile = open(os.path.join(outputPath, \"characters.js\"), \"w\") outputFile.write(\"let characters = {\\n\") for filename in os.listdir(inputPath): inputFilePath = os.path.join(inputPath, filename) if os.path.isfile(inputFilePath): outputFile.write(createCharacterObject(filename)) outputFile.write(\"\\n};\\n\") outputFile.write(\"\\nconst getDetailsFor = name => characters[name];\\n\") outputFile.close()"}
{"question": "Write a method that Produces example inputs for reduction ops that include the input tensor and dim and keepdim kwargs. If a reduction op needs to verify additional args/kwargs then build a separate sample_inputs routine", "answer": "def method(op_data, device_unit, data_type, needs_grad): examples = [] for tensor in _produce_reduction_examples(device_unit, data_type, needs_grad): # Add case without dim and keepdim kwargs examples.append(SampleInput(tensor)) for opts in _produce_reduction_kwargs(tensor.ndim, supports_multi_dims): examples.append(SampleInput(tensor, kwargs=opts)) return examples"}
{"question": "Write a function that Produces new stockpile and allocates it somehow to keep the network balanced for the chosen locations. Returns a numpy array of shape (num_centers,num_goods) representing how much extra stockpile is going to appear.", "answer": "def produce_new_stockpile( self, network: physical_grid, open_requests: List[Request] ): # todo add type when it works. pass"}
{"question": "Write a function that Produces an API token. A token is HMAC_SHA256(passphrase, action + route + counter + payload), hex encoded. Action must be uppercased, route is relative, counter must be an increasing 64-bit integer and the payload, if present, must be JSON without whitespace between keys. For example, in psuedocode (and in real code below): action=POST route=/api/v1/order counter=1416993995705 payload={\"symbol\":\"XBTZ14\",\"quantity\":1,\"price\":395.01} token = HEX(HMAC_SHA256(passphrase, 'POST/api/v1/order1416993995705{\"symbol\":\"XBTZ14\",\"quantity\":1,\"price\":395.01}'))", "answer": "def produce_token(passphrase, action, route, counter, payload): '''Produce a request token compatible with BitMEX.''' # Parse the route so we can remove the base and extract just the path. analyzedRoute = urlparse(route) path = analyzedRoute.path if analyzedRoute.query: path = path + '?' + analyzedRoute.query # print \"Computing HMAC: %s\" % action + path + str(counter) + payload message = action + path + str(counter) + payload token = hmac.new(bytes(passphrase, 'utf8'), bytes(message, 'utf8'), digestmod=hashlib.sha256).hexdigest() return token"}
{"question": "Write a function that Generates evidence list for existence of a child node Appends evidence list from offspring Merkle tree with (offspringTree.hash, self.content.hash()) This connects the evidence list to the current node", "answer": "def __getChildEvidenceList(self, offspringHash): if self.status != \"compile\": raise ValueError(\"Illegal mode: %s\"%self.status) if not self.offspring: raise ValueError(\"Cannot get child proof list on leaf node\") #Get proof list of the children Merkle tree offspringTree = MerkleTreeList(self.offspring) offspringProof = offspringTree.proofList(crypto.ishash(offspringHash)) # Get proof list for existence of children Merkle tree from current node presentNodeProof = [(offspringTree.hash(), self.content.hash())] return offspringProof + presentNodeProof"}
{"question": "Write a function that Write a function to find the longest common prefix string amongst an array of words. If there is no common prefix, return an empty string \"\". Example: Input: word_list = [\"flower\",\"flow\",\"flight\"] Output: \"fl\" Constraints: 0 <= word_list.length <= 200 0 <= word_list[i].length <= 200 word_list[i] consists of only lower-case English letters.", "answer": "def shortest_term(word_list): span = len(word_list[0]) for entry in word_list: if span > len(entry): span = len(entry) return span"}
{"question": "Write a function that inscribe a character to lcd (or character rom) 0x09: backlight | RS=DR< works!", "answer": "def lcd_inscribe_char(self, charsymbol, mode=1): self.lcd_inscribe_four_bits(mode | (charsymbol & 0xF0)) self.lcd_inscribe_four_bits(mode | ((charsymbol << 4) & 0xF0))"}
{"question": "Write a routine that Outputs a remark, each line prefixed by // and wrapped to 80 spaces.", "answer": "def _OutputRemark(writer, remark): for text in remark.splitlines(): if len(text) == 0: writer.write('//') else: writer.write(COMMENT_WRAPPER.fill(text)) writer.write('\\n')"}
{"question": "Write a procedure that Produces location/dimension output for the registers in the node's 'reg' attribute", "answer": "def reg_location_label_alias(reg_item): return str2ident(reg_item.label) + \"_BASE_LOCATION\" if reg_item.label else None"}
{"question": "Write a routine that Writes IRQ num and information for the interrupts in the node's 'interrupt' property", "answer": "def irq_label_alias(interrupt, field_name): if not interrupt.name: return None alias = \"IRQ_{}\".format(str2ident(interrupt.name)) if field_name != \"irq\": alias += \"_\" + str2ident(field_name) return alias"}
{"question": "Write a procedure that Records a remark, each line prefixed by // and wrapped to 80 spaces.", "answer": "def _EmitRemark(writer, remark): for row in remark.splitlines(): if len(row) == 0: writer.write('//') else: writer.write(COMMENT_WRAPPER.fill(row)) writer.write('\\n')"}
{"question": "Write a routine that Produce an Neutral Culture profile that adheres to the format above given a contender map.", "answer": "def prod_neutral_culture_strict(nvotes, contendermap): rankcountmap = [] ranklistmap = [] votesgroup = gen_urn(nvotes, 0, contendermap.keys()) return votesgroup_to_ranklistmap(votesgroup, contendermap)"}
{"question": "Write a function that Produce an Unbiased Incognito Society profile that adheres to the format above.", "answer": "def create_unbiased_incognito_society_strict(ballots, contestantmap): ranklistcounts = [] ranklist = [] #Use the existing functions. ballotset = gen_urn(ballots, 1, contestantmap.keys()) return voteset_to_rankmap(ballotset, contestantmap)"}
{"question": "Write a procedure that Produce an Urn Tradition with Replacement = swap profile that follows the format above.", "answer": "def produce_urn_tradition_strict(totalvotes, swap, candidate_map): rank_counter_list = [] rank_sequence = [] #Use the existing functions. vote_group = gen_urn(totalvotes, swap, candidate_map.keys()) return voteset_to_rankmap(vote_group, candidate_map)"}
{"question": "Write a function that Create Mallows with a particular number of reference rankings and phi's drawn iid.", "answer": "def create_mallows_mix(nagents, candidate_map, nref): #Generate the requisite number of reference rankings and phis #Mix should be a random number over each... mix = [] phis = [] refs = [] for i in range(nref): refm, refc = generate_impartial_culture_strict(1, candidate_map); refs.append(io.rankmap_to_order(refm[0])) phis.append(round(random.random(), 5)) mix.append(random.randint(1,100)) smix = sum(mix) mix = [float(i) / float(smix) for i in mix] return create_mallows(nagents, candidate_map, mix, phis, refs)"}
{"question": "Write a procedure that TODO - implement. I expect pivot might be needed for this alignment if the x-y orientation of the camera is not perfectly aligned with the microscope platform", "answer": "def __init__(self, infoBundle, configs=None, evalLabel=None): self.infoBundle = infoBundle"}
{"question": "Write a function that if you change this stub into a real verify, please try to implement the userID and teamname functions above, too.", "answer": "def isproprietor(st): return True"}
{"question": "Write a procedure that tricking a bit at this moment. Usually the ExtensionTab view is of type InteractiveGraphicsPanel But because the real-time view require some additional handles, we attach this class (ActiveWindow) to the Extensiontabs view that's why we have to realize the same actions as the our panel", "answer": "def execute(self): self.panel.execute()"}
{"question": "Write a procedure that Following three cases - the customer side modules have everything they require from the encoded ID. Don't implement a default on the base class though because it is good to force both Customer and PDF/HTML export to deal with each new directive explicitly.", "answer": "def process_dataset_as_picture(self, row, hda): pass"}
{"question": "Write a function that Implement the function interval_intersection below. You can define other functions if it helps you decompose and solve the problem. Do not import any module that you do not use! Remember that if this were an exam problem, in order to be marked this file must meet certain requirements: - it must contain ONLY syntactically valid python code (any syntax or indentation error that stops the file from running would result in a mark of zero); - you MAY NOT use global variables; the function must use only the input provided to it in its arguments.", "answer": "def interval_intersection(lA, uA, lB, uB): if (lB >= lA and lB <= uA): if uB < uA: return uB - lB else: return uA - lB elif (lA >= lB and lA <= uB): if uA < uB: return uA - lA else: return uB - lA return 0"}
{"question": "Write a function that Mixin this class to implement IPipelineSnapshot Graphene has some strange properties that make it so that you cannot implement ABCs nor use properties in an overridable way. So the way the mixin works is that the target classes have to have a method fetch_represented_pipeline()", "answer": "def fetch_represented_pipeline(self): raise NotImplementedError()"}
{"question": "Write a routine that Implement Polled Camera Element for S100 http://wiki.ros.org/camera_drivers Service request_snapshot (polled_camera/GetPolledImage) Published Topics: /s100/image_label (sensor_msgs/Image)", "answer": "def active_folder(): return '/tmp'"}
{"question": "Write a function that To get nice documentation about ServerControllerSet actions it is necessary to implement the routine. By default, ControllerSet doesn't provide it.", "answer": "def fetch_serializer(self, *args, **options): pass"}
{"question": "Write a function that <HINT> Build a submit view to produce an exam submission record for a course registration, you may implement it based on following logic: Retrieve user and course entity, then get the linked registration object created when the user joined the course Construct a submission entity referring to the registration Gather the chosen options from exam form Append each chosen option entity to the submission entity Redirect to display_exam_result with the submission id", "answer": "def send(request, course_key): learner = request.user course = Course.objects.get(pk=course_key) registration = Enrollment.objects.get(user=learner, course=course) chosen_responses = extract_answers(request) submission = Submission.objects.create(enrollment=registration) submission.selections.set(chosen_responses) print(submission) return HttpResponseRedirect(reverse(viewname='onlinecourse:result', args=(course_key, submission.selections.first().question.lesson.pk, submission.pk)))"}
